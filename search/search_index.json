{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentVault: Secure &amp; Interoperable AI Agent Communication","text":"Figure 1: An artistic vision representing the potential of the AgentVault ecosystem. <p>The AI agent revolution is here, but agents often exist in isolated silos. How can diverse AI agents discover each other, communicate securely, and collaborate effectively to solve complex problems?</p> <p>AgentVault provides the open-source (Apache 2.0) foundational infrastructure layer. We build the secure, standardized \"plumbing\" \u2013 protocols, tools, and services \u2013 enabling a truly interconnected and interoperable multi-agent future.</p>"},{"location":"#unlock-collaborative-ai-potential","title":"Unlock Collaborative AI Potential","text":"<p>AgentVault empowers developers and organizations to move beyond isolated AI tools towards sophisticated, collaborative systems.</p> <ul> <li>Problem: Integrating disparate agents requires custom, brittle code; secure communication and discovery are challenging.</li> <li>Solution: AgentVault provides the standardized rails for secure discovery (Registry), communication (A2A Protocol), and credential management (KeyManager).</li> </ul> <p>\u27a1\ufe0f Live Public Registry &amp; UI</p> <p>Explore registered agents or manage your own: *   Discover Agents (UI): <code>https://agentvault-registry-api.onrender.com/ui</code></p> <ul> <li> <p>Developer Portal (UI): <code>https://agentvault-registry-api.onrender.com/ui/developer</code> (Login/Register Here)</p> </li> <li> <p>Registry API Base: <code>https://agentvault-registry-api.onrender.com/api/v1</code></p> </li> <li>(Note: Free tier hosting - may take up to 60s to wake up on first request after inactivity. Visit <code>/health</code> or the UI first.)</li> </ul>"},{"location":"#why-agentvault-the-infrastructure-layer","title":"Why AgentVault? The Infrastructure Layer","text":"<p>AgentVault focuses specifically on providing the essential, secure foundation, complementing higher-level orchestration frameworks.</p> <ul> <li>\u2728 Security-First: From the ground up, with secure local credential management (<code>KeyManager</code>), standard authentication protocols, and TEE awareness.</li> <li>\ud83c\udf10 Interoperable: Built on open standards (JSON-RPC, SSE) and clear schemas (Agent Cards, A2A Profile v0.2).</li> <li>\ud83d\udd27 Integrated Toolkit: A cohesive set of tools designed for the specific needs of A2A interaction:<ul> <li>Registry API &amp; UI: For discovery and developer management.</li> <li>Client Library (<code>agentvault</code>): For programmatic interaction.</li> <li>Server SDK: To easily build compliant agents in Python/FastAPI.</li> <li>CLI (<code>agentvault_cli</code>): For user and developer command-line access.</li> </ul> </li> <li>\ud83d\udd13 Open Source (Apache 2.0): Ensuring transparency, flexibility, and no vendor lock-in.</li> </ul>"},{"location":"#core-components-v100","title":"Core Components (v1.0.0)","text":"<ul> <li>Client Library (<code>agentvault</code>): Interact with agents (A2A/MCP), manage keys (<code>KeyManager</code>), handle Agent Cards.</li> <li>CLI (<code>agentvault_cli</code>): Manage credentials, discover agents, run tasks.</li> <li>Registry API (<code>agentvault_registry</code>): Central API &amp; Web UI for discovery and developer management.</li> <li>Server SDK (<code>agentvault-server-sdk</code>): Build A2A-compliant agents with FastAPI.</li> <li>Protocols &amp; Profiles: Definitions for A2A, MCP (Concept), and TEE.</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<ul> <li>New Users: Check the Installation Guide and learn the CLI Commands.</li> <li>Developers: Explore the Developer Guides, Examples, and start building with the Server SDK.</li> </ul>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>AgentVault is built by the community. We welcome your contributions, feedback, and ideas!</p> <ul> <li>GitHub Repository</li> <li>Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>AgentVault is licensed under the Apache License, Version 2.0. See the LICENSE file in the project root for details.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to AgentVault","text":"<p>First off, thank you for considering contributing to AgentVault! It's people like you that make open source great. Your contributions help build a robust and interoperable ecosystem for AI agents.</p> <p>Please take a moment to review this document in order to make the contribution process easy and effective for everyone involved.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository: Start by forking the main AgentVault repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.     <pre><code>git clone https://github.com/YOUR-USERNAME/AgentVault.git\ncd AgentVault\n</code></pre></li> <li>Install Prerequisites: Ensure you have Git and a compatible Python version (3.10 or 3.11) installed.</li> <li>Install Poetry: If you don't have Poetry installed, follow the instructions on the official Poetry website. Poetry is used for dependency management and packaging across the monorepo.</li> <li>Set up Virtual Environment &amp; Install Dependencies: Navigate to the project root (<code>AgentVault/</code>) and run:     <pre><code>poetry install --with dev\n</code></pre>     This command performs several crucial steps:<ul> <li>Reads the <code>pyproject.toml</code> files within each component package (<code>agentvault_library</code>, <code>agentvault_cli</code>, etc.).</li> <li>Resolves all dependencies across the entire workspace, ensuring compatibility.</li> <li>Creates a single virtual environment (usually <code>.venv/</code> in the project root) for the whole project.</li> <li>Installs all production and development dependencies (like <code>pytest</code>, <code>httpx</code>, <code>mkdocs</code>, <code>ruff</code>) into this shared virtual environment.</li> </ul> </li> <li>Activate Virtual Environment: Before running any commands, tests, or development servers, activate the virtual environment:<ul> <li>Linux/macOS (bash/zsh): <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Windows (PowerShell): <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\.venv\\Scripts\\activate.bat\n</code></pre> Your command prompt should now indicate you are inside the <code>(.venv)</code> environment.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":"<ol> <li>Find/Create an Issue: Look for existing issues or create a new one on GitHub to discuss the bug or feature you want to work on. This helps coordinate efforts.</li> <li>Branching: Create a descriptive feature branch off the <code>main</code> branch:     <pre><code>git checkout main\ngit pull origin main # Ensure your main is up-to-date\ngit checkout -b feat/my-new-feature # Or fix/resolve-issue-123\n</code></pre></li> <li>Coding:<ul> <li>Make your changes within the relevant component directory (e.g., <code>agentvault_library/src/agentvault/</code>, <code>agentvault_cli/src/agentvault_cli/</code>).</li> <li>Follow existing code style and patterns. We aim for clean, readable, and type-hinted Python code.</li> <li>Ensure new functions, classes, and modules have appropriate docstrings.</li> </ul> </li> <li>Testing:<ul> <li>Write Tests: Add new unit or integration tests for your changes within the corresponding component's <code>tests/</code> directory.</li> <li>Run Tests: Navigate to the component's directory (e.g., <code>cd agentvault_library</code>) and run <code>pytest</code>. Ensure all tests pass, including your new ones.</li> <li>Run All Tests (Optional): From the project root, you can run <code>pytest</code> to execute tests for all components (ensure <code>pytest.ini</code> at the root is configured correctly).</li> </ul> </li> <li>Linting &amp; Formatting: (Tooling setup TBD - e.g., Black, Ruff) Run the project's code formatter and linter to ensure consistency.</li> <li>Documentation: If your changes affect user-facing behavior, APIs, or architecture, update the relevant documentation pages in the <code>/docs</code> directory. Build the docs locally (<code>mkdocs serve</code> from the root) to preview your changes.</li> <li>Committing: Write clear, concise commit messages using conventional commit style (e.g., <code>feat(sdk): Add helper for SSE events</code>, <code>fix(cli): Correct handling of --output-artifacts</code>, <code>docs(library): Improve KeyManager examples</code>). Reference the relevant GitHub issue number (e.g., <code>feat(registry): Implement tag filtering (#42)</code>).</li> <li>Pull Request:<ul> <li>Push your feature branch to your fork: <code>git push origin feat/my-new-feature</code></li> <li>Go to the main AgentVault repository on GitHub and open a Pull Request (PR) from your branch to the <code>main</code> branch.</li> <li>Provide a clear title and description for your PR, explaining the changes and linking to the relevant issue(s).</li> <li>Ensure all automated checks (CI workflows like tests and dependency audits) pass on your PR. Address any failures.</li> <li>Engage in the code review process if feedback is provided.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#code-style","title":"Code Style","text":"<p>(Placeholder: This section will be updated once specific tools like Black/Ruff are enforced via pre-commit hooks or CI.)</p> <p>Generally, adhere to PEP 8 guidelines and follow the style of the existing codebase. Use type hints extensively.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<ul> <li>Unit Tests: Focus on testing individual functions and classes in isolation. Place these in the relevant component's <code>tests/</code> directory (e.g., <code>agentvault_library/tests/library/</code>).</li> <li>Integration Tests: Test the interaction between different parts of a component or between components (e.g., CLI using the Library against a mock server). Place these in appropriate subdirectories within <code>tests/</code>.</li> <li>Coverage: Aim for high test coverage for new code. (Coverage reporting setup TBD).</li> <li>Running Tests: Activate the virtual environment and run <code>pytest</code> from the component directory or the project root.</li> </ul>"},{"location":"CONTRIBUTING/#dependency-security","title":"Dependency Security","text":"<p>This project uses <code>pip-audit</code> via a GitHub Actions workflow (<code>.github/workflows/dependency_audit.yml</code>) to automatically check for known vulnerabilities in project dependencies based on the <code>poetry.lock</code> files.</p> <ul> <li>Workflow: Triggers on pushes/PRs to <code>main</code>. Audits each component separately.</li> <li>Reviewing Audits: Check the \"Actions\" tab on GitHub for the \"Security Dependency Audit\" results. Failures indicate known vulnerabilities.</li> <li>Updating Dependencies: Use <code>poetry update &lt;package_name&gt;</code> within a component directory to update specific dependencies, or <code>poetry update</code> to update all allowed by <code>pyproject.toml</code>. Always re-run <code>poetry lock</code> and commit the updated lock file. Re-run tests thoroughly after updates.</li> </ul>"},{"location":"CONTRIBUTING/#reporting-issues-security-vulnerabilities","title":"Reporting Issues &amp; Security Vulnerabilities","text":"<ul> <li>Bugs &amp; Feature Requests: Please check existing GitHub Issues first. If your issue isn't there, open a new one with detailed information.</li> <li>Security Vulnerabilities: DO NOT report security issues publicly. Please follow the instructions in our Security Policy (security_policy.md).</li> </ul>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>This project adheres to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code.</p> <p>Thank you for contributing to AgentVault!</p>"},{"location":"REGISTRY_POLICY/","title":"AgentVault Registry Policy","text":""},{"location":"REGISTRY_POLICY/#1-purpose-of-the-registry","title":"1. Purpose of the Registry","text":"<p>The AgentVault Registry serves as a public discovery hub for AI agents compatible with the AgentVault ecosystem and the Agent-to-Agent (A2A) protocol. Its primary purpose is to store and serve standardized Agent Card metadata submitted by agent developers.</p> <p>The Registry DOES NOT:</p> <ul> <li>Execute or host third-party agents.</li> <li>Handle, store, or process end-user API keys (like OpenAI, Anthropic keys).</li> <li>Proxy or monitor A2A communication between clients and agents.</li> <li>Guarantee the functionality, security, safety, or ethical behavior of the agents listed.</li> </ul>"},{"location":"REGISTRY_POLICY/#2-agent-card-submissions","title":"2. Agent Card Submissions","text":"<ul> <li>Eligibility: Only authenticated developers who have registered with the AgentVault Registry service (process TBD, currently via API key assigned by maintainers) can submit, update, or deactivate Agent Cards.</li> <li>Responsibility: Developers are solely responsible for the accuracy and completeness of the information provided in their submitted Agent Cards, including endpoint URLs, authentication details, descriptions, and links to their own policies.</li> </ul>"},{"location":"REGISTRY_POLICY/#3-vetting-process","title":"3. Vetting Process","text":"<ul> <li>Automated Validation: Submitted Agent Cards undergo automated validation against the official A2A Agent Card schema (<code>agentvault.models.AgentCard</code>) to ensure structural correctness. Basic checks may also be performed to verify the format of the specified A2A endpoint URL.</li> <li>No Behavioral Vetting: The AgentVault Registry does not perform manual reviews or vetting of the underlying agent's functionality, security practices, data handling procedures, or ethical alignment. Listing in the registry does not imply endorsement or certification by the AgentVault project.</li> </ul>"},{"location":"REGISTRY_POLICY/#4-content-guidelines-summary","title":"4. Content Guidelines (Summary)","text":"<p>Agent Card metadata submitted to the registry must not:</p> <ul> <li>Promote or facilitate illegal activities.</li> <li>Contain hateful, discriminatory, or harassing content.</li> <li>Be intentionally deceptive or misleading about the agent's capabilities or purpose.</li> <li>Infringe on the intellectual property rights of others.</li> <li>Link to malicious websites or resources.</li> </ul> <p>(A more detailed content policy may be developed later).</p>"},{"location":"REGISTRY_POLICY/#5-reporting-problematic-agents","title":"5. Reporting Problematic Agents","text":"<p>Users who encounter Agent Cards that appear to violate the Content Guidelines, are misleading, link to non-functional or malicious endpoints, or represent agents engaging in harmful activities are encouraged to report them.</p> <ul> <li> <p>How to Report: Please send a detailed report including the Agent Card ID (the UUID) and a description of the issue to:</p> <p><code>[AgentVault@proton.me]</code></p> </li> <li> <p>Review Process: Reports will be reviewed by the AgentVault maintainers based on this policy.</p> </li> </ul>"},{"location":"REGISTRY_POLICY/#6-enforcement","title":"6. Enforcement","text":"<p>AgentVault maintainers reserve the right, at their sole discretion, to:</p> <ul> <li>Deactivate (soft delete, making <code>is_active=False</code>) any Agent Card found to violate the Registry Policy or Content Guidelines.</li> <li>Temporarily or permanently suspend a developer's ability to submit or manage Agent Cards in response to repeated or severe violations.</li> <li>Remove Agent Cards linking to endpoints that are consistently unavailable or return errors indicative of non-compliance with the A2A protocol.</li> </ul>"},{"location":"REGISTRY_POLICY/#7-disclaimer","title":"7. Disclaimer","text":"<p>The AgentVault Registry is provided \"as is\". Users interact with third-party agents discovered through this registry at their own risk. The AgentVault project makes no warranties regarding the agents listed and is not liable for any damages or issues arising from interactions with those agents. Please review the agent provider's own Terms of Service and Privacy Policy before use.</p>"},{"location":"ROADMAP/","title":"AgentVault Project Roadmap","text":"<p>This document outlines the planned development phases and features for the AgentVault ecosystem. Our goal is to create a secure, interoperable, and easy-to-use platform for AI agent communication based on open standards like A2A and MCP concepts.</p> <p>Disclaimer: This roadmap represents our current plans and priorities. It is subject to change based on development progress, community feedback, and the evolution of underlying standards.</p>"},{"location":"ROADMAP/#current-status-may-2025-v100-production-release","title":"Current Status (May 2025 - v1.0.0 Production Release)","text":"<p>AgentVault v1.0.0 is LIVE and production-ready! \ud83c\udf89</p> <p>This release establishes a stable, secure, and feature-complete foundation for building and managing interoperable AI agent systems based on A2A and MCP principles.</p> <p>Key achievements included in v1.0.0:</p> <ul> <li>Core Components (Stable v1.0.0):<ul> <li><code>agentvault</code> Library: Mature client implementation (A2A JSON-RPC/SSE, Auth Schemes incl. OAuth2, KeyManager w/ Keyring, MCP embedding, Models).</li> <li><code>agentvault_registry</code> API &amp; UI: Fully functional API (Card CRUD, Discovery Filters, Validation) and Web UI (Public Discovery, Developer Portal) with robust developer authentication (Email/Password, JWT, Recovery Keys, Programmatic API Keys), Agent Builder, and PostgreSQL/Alembic backend.</li> <li><code>agentvault_cli</code>: Feature-complete CLI (<code>config</code>, <code>discover</code>, <code>run</code>) supporting KeyManager, SSE streaming, and artifact handling.</li> <li><code>agentvault_server_sdk</code>: Stable SDK (<code>BaseA2AAgent</code>, FastAPI integration, <code>@a2a_method</code>, <code>InMemoryTaskStore</code> w/ notifications), including the <code>agentvault-sdk package</code> tool for Dockerization.</li> <li><code>agentvault_testing_utils</code>: Comprehensive shared utilities for robust testing.</li> </ul> </li> <li>Validated POC Pipelines: Successfully implemented and validated diverse end-to-end examples showcasing core capabilities:<ul> <li>\u2705 MCP Tool Access: Secure, proxied filesystem &amp; code execution.</li> <li>\u2705 E-commerce Personalization: Multi-agent data aggregation for recommendations.</li> <li>\u2705 Secure ETL Workflows: Database-driven artifact passing.</li> <li>\u2705 Multi-Agent Research: Complex 7-agent orchestration (LangGraph).</li> <li>\u2705 Dynamics 365 Enrichment &amp; Actions: Enterprise data wrapping &amp; action triggering.</li> <li>\u2705 Support Ticket Triage: Routing &amp; enrichment patterns.</li> <li>(POC code and updated documentation released on GitHub)</li> </ul> </li> <li>Documentation: Overhauled documentation site providing core concepts, architecture, security details, comprehensive guides for each component, and initial POC overviews.</li> <li>CI/CD &amp; Security: Established workflows for dependency security scanning (<code>pip-audit</code>) and documentation deployment.</li> </ul>"},{"location":"ROADMAP/#immediate-next-steps-post-v100","title":"Immediate Next Steps (Post v1.0.0)","text":"<p>With the v1.0.0 foundation now stable, the immediate focus shifts towards adoption, community engagement, and incremental improvements:</p> <ol> <li>Community Building &amp; Support:<ul> <li>Actively engage with early adopters and users on GitHub (Issues, Discussions).</li> <li>Improve contribution guidelines and onboarding processes.</li> <li>Respond promptly to feedback and bug reports.</li> </ul> </li> <li>Documentation Enhancement:<ul> <li>Create detailed guides for each of the released POC pipelines, explaining setup, execution, and the specific AgentVault features demonstrated.</li> <li>Add more advanced usage examples and tutorials based on user feedback.</li> <li>Refine API reference documentation.</li> </ul> </li> <li>Usability &amp; DX Polish:<ul> <li>Address any minor usability issues or friction points identified in the core components based on initial v1.0.0 feedback.</li> <li>Potentially enhance the Agent Builder with more options or templates.</li> <li>Improve error messages and logging for better debugging.</li> </ul> </li> <li>Maintenance &amp; Bug Fixes:<ul> <li>Prioritize addressing any bugs or stability issues reported against the v1.0.0 release.</li> <li>Regularly update dependencies and address security audit findings.</li> </ul> </li> <li>Begin Phase 3 Exploration:<ul> <li>Start initial design and feasibility studies for key Phase 3 features (e.g., Federated Registry concepts, SPIFFE/SPIRE integration research for Agent Identity Fabric).</li> </ul> </li> </ol>"},{"location":"ROADMAP/#future-considerations-phase-3-beyond","title":"Future Considerations (Phase 3 &amp; Beyond)","text":"<p>Objective: Expand AgentVault into a comprehensive, enterprise-ready platform for secure, scalable, and truly intelligent multi-agent collaboration across diverse environments.</p> <p>Concept Diagram:</p> <p> (Diagram illustrating the interplay between federated registries and a zero-trust identity fabric based on SPIFFE/SPIRE, OAuth2, and OPA for secure cross-domain agent communication.)</p> <p>Key Areas:</p> <ol> <li>Federated Registry &amp; Discovery:<ul> <li>Design and implement protocols for secure, policy-based discovery between independent AgentVault Registry instances (private enterprise, partner, public).</li> <li>Develop mechanisms for establishing and managing trust relationships between registries.</li> <li>Enhance Agent Cards to support federation metadata and cross-domain policies.</li> </ul> </li> <li>AgentVault Identity Fabric (Zero Trust IAM for Agents):<ul> <li>Goal: Implement a robust, fine-grained Identity and Access Management system specifically for agents, complementing existing user IAM (like Entra ID).</li> <li>Agent Identity (SPIFFE/SPIRE): Integrate SPIFFE/SPIRE for issuing verifiable, short-lived cryptographic identities (SVIDs) to agent workloads, enabling strong mTLS authentication for A2A.</li> <li>Capability-Based Authorization (OAuth2 Scopes/Token Exchange): Define granular permission scopes based on agent capabilities (from Agent Cards). Implement OAuth 2.0 Token Exchange flows to issue delegated, capability-scoped tokens for agent interactions, enforcing the Principle of Least Privilege.</li> <li>Policy Engine Integration (OPA): Integrate Open Policy Agent (OPA) for decoupled, dynamic authorization decisions based on agent identity, user context, requested capabilities, and custom enterprise policies (Rego).</li> <li>Secure Context Propagation: Define standardized methods for securely passing necessary user and call-chain context between agents.</li> <li>Synergy: This Identity Fabric provides the necessary security primitives for secure and scalable Federated Registry interactions.</li> </ul> </li> <li>Enhanced A2A/MCP Capabilities:<ul> <li>Multimodality (WebRTC): Integrate <code>aiortc</code> or similar libraries for optional real-time audio/video streaming capabilities within the A2A framework.</li> <li>Deeper MCP Integration: Fully align with finalized Model Context Protocol specifications, providing robust SDK helpers for standardized tool use and context passing.</li> </ul> </li> <li>Advanced Security &amp; Trust:<ul> <li>TEE Attestation Verification: Implement client-side cryptographic verification of Trusted Execution Environment attestations declared in Agent Cards.</li> <li>Key Rotation &amp; Management: Enhanced features for managing registry API keys and potentially agent-level credentials.</li> <li>Formal Security Audits: Engage third-party experts for comprehensive security reviews of the core framework and protocols.</li> </ul> </li> <li>Ecosystem &amp; Usability:<ul> <li>Persistent Task Stores: Provide robust, production-ready <code>BaseTaskStore</code> implementations (e.g., Redis, SQL database).</li> <li>UI Enhancements: Improve Agent Builder capabilities, add registry analytics/monitoring dashboards.</li> <li>Other Language SDKs/Libraries: Explore SDKs for other popular languages like Node.js, Go, etc., based on community demand.</li> <li>Community Features: Implement features like agent reviews/ratings within the registry.</li> </ul> </li> </ol>"},{"location":"ROADMAP/#contributing","title":"Contributing","text":"<p>We welcome community contributions! Please see our CONTRIBUTING.md for guidelines.</p>"},{"location":"TERMS_OF_SERVICE/","title":"AgentVault Registry API - Terms of Service","text":"<p>Last Updated: [April 12, 2025]</p> <p>PLEASE READ THESE TERMS OF SERVICE CAREFULLY. By accessing or using the AgentVault Registry API (the \"Service\"), provided by the AgentVault Project Maintainers (\"we\", \"us\", \"our\"), you (\"Developer\", \"you\") agree to be bound by these Terms of Service (\"Terms\"). If you do not agree to these Terms, do not use the Service.</p> <p>1. The Service</p> <p>The AgentVault Registry API is a service designed to facilitate the discovery of AI agents compatible with the AgentVault ecosystem. It allows registered developers to submit, manage, and publish metadata (\"Agent Cards\") describing their agents. The Service provides public endpoints for listing and retrieving these Agent Cards.</p> <p>The Service DOES NOT: *   Host or execute third-party AI agents. *   Store, handle, or process end-user API keys (e.g., OpenAI keys) used by agents. *   Monitor or proxy communication between users and agents. *   Endorse, certify, or guarantee the functionality, security, or behavior of any agent listed in the registry.</p> <p>2. Developer Accounts &amp; API Keys</p> <ul> <li>Access to submit or manage Agent Cards requires authentication using an API key provided by us.</li> <li>You are responsible for maintaining the confidentiality and security of your assigned API key. Do not share your key.</li> <li>You are responsible for all activities that occur under your API key. Notify us immediately of any unauthorized use.</li> <li>We reserve the right to revoke or suspend API keys if we suspect misuse or violation of these Terms.</li> </ul> <p>3. Agent Card Submissions &amp; Content</p> <ul> <li>By submitting an Agent Card to the Service, you represent and warrant that:<ul> <li>You own or have the necessary rights to the content included in the Agent Card.</li> <li>The information provided in the Agent Card is accurate, complete, and not misleading.</li> <li>The Agent Card content and the agent it describes comply with the AgentVault Registry Policy and all applicable laws and regulations.</li> <li>The Agent Card content does not infringe upon the intellectual property rights, privacy rights, or other rights of any third party.</li> </ul> </li> <li>You grant the AgentVault Project Maintainers a worldwide, non-exclusive, royalty-free license to host, display, reproduce, and distribute the submitted Agent Card metadata solely for the purpose of operating and promoting the AgentVault Registry and ecosystem.</li> <li>You are solely responsible for the agent service described in your Agent Card, including its operation, security, data handling, and compliance with its own terms and privacy policy.</li> </ul> <p>4. Prohibited Use</p> <p>You agree not to use the Service to:</p> <ul> <li>Submit Agent Cards that violate the AgentVault Registry Policy.</li> <li>Engage in any activity that is illegal, fraudulent, or harmful.</li> <li>Attempt to gain unauthorized access to the Service, other accounts, or related systems.</li> <li>Disrupt, interfere with, or place an unreasonable load on the Service or its infrastructure (e.g., excessive scraping, denial-of-service attacks).</li> <li>Misrepresent your identity or affiliation.</li> </ul> <p>5. Disclaimers</p> <ul> <li>THE SERVICE IS PROVIDED \"AS IS\" AND \"AS AVAILABLE\" WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.</li> <li>WE DO NOT WARRANT THAT THE SERVICE WILL BE UNINTERRUPTED, ERROR-FREE, OR SECURE.</li> <li>WE EXPLICITLY DISCLAIM ANY AND ALL LIABILITY AND RESPONSIBILITY FOR ANY THIRD-PARTY AGENTS DISCOVERED THROUGH THE SERVICE. YOUR INTERACTION WITH ANY AGENT LISTED IN THE REGISTRY IS SOLELY AT YOUR OWN RISK. WE DO NOT VET, ENDORSE, OR GUARANTEE ANY AGENT'S PERFORMANCE, SECURITY, DATA PRACTICES, OR COMPLIANCE. YOU ARE RESPONSIBLE FOR REVIEWING THE TERMS AND PRIVACY POLICY OF ANY AGENT BEFORE INTERACTING WITH IT.</li> </ul> <p>6. Intellectual Property</p> <ul> <li>The AgentVault name, logos, and the Service software are the property of the AgentVault Project Maintainers or its licensors and are protected by intellectual property laws.</li> <li>You retain ownership of the content within your submitted Agent Cards, subject to the license granted in Section 3.</li> </ul> <p>7. Termination</p> <ul> <li>We reserve the right to suspend or terminate your access to the Service (including revoking API keys and deactivating Agent Cards) at any time, with or without cause or notice, for conduct that we believe violates these Terms or is otherwise harmful to the Service or community.</li> <li>You may stop using the Service at any time.</li> </ul> <p>8. Limitation of Liability</p> <p>TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL THE AGENTVAULT PROJECT MAINTAINERS, THEIR AFFILIATES, OR THEIR LICENSORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, OR ANY LOSS OF PROFITS OR REVENUES, WHETHER INCURRED DIRECTLY OR INDIRECTLY, OR ANY LOSS OF DATA, USE, GOODWILL, OR OTHER INTANGIBLE LOSSES, RESULTING FROM (a) YOUR ACCESS TO OR USE OF OR INABILITY TO ACCESS OR USE THE SERVICE; (b) ANY CONDUCT OR CONTENT OF ANY THIRD PARTY ON THE SERVICE, INCLUDING THIRD-PARTY AGENTS DISCOVERED VIA THE SERVICE; OR (c) UNAUTHORIZED ACCESS, USE, OR ALTERATION OF YOUR TRANSMISSIONS OR CONTENT.</p> <p>9. Governing Law</p> <p>These Terms shall be governed by and construed in accordance with the laws of [Bavaria, Germany], without regard to its conflict of law principles.</p> <p>10. Changes to Terms</p> <p>We reserve the right to modify these Terms at any time. If we make changes, we will provide notice, such as by updating the \"Last Updated\" date at the top of these Terms. Your continued use of the Service after any modification constitutes your acceptance of the revised Terms.</p> <p>11. Contact Information</p> <p>For questions about these Terms of Service, please contact:</p> <p><code>[AgentVault@proton.me]</code></p>"},{"location":"a2a_profile_v0.2/","title":"AgentVault A2A Profile v0.2","text":"<p>This document specifies the Agent-to-Agent (A2A) communication profile implemented by AgentVault components (as of v0.2.x of the libraries/SDK). It defines how clients interact with A2A-compliant agent servers, aligning with concepts from emerging A2A standards like Google's A2A protocol.</p>"},{"location":"a2a_profile_v0.2/#overview","title":"Overview","text":"<ul> <li>Protocol: JSON-RPC 2.0 Specification.</li> <li>Transport: HTTP/1.1 or HTTP/2. HTTPS is REQUIRED for all communication except potentially during local development targeting <code>localhost</code>.</li> <li>Request Method: <code>POST</code> for all JSON-RPC requests.</li> <li>Streaming: Server-Sent Events (SSE) via the <code>tasks/sendSubscribe</code> method for real-time updates.</li> <li>Data Format: JSON (UTF-8 encoding).</li> <li>Authentication: Defined via <code>authSchemes</code> in the Agent Card. Supported schemes include <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials Grant). See Authentication section below.</li> <li>Models: Data structures (AgentCard, Task, Message, etc.) are defined using Pydantic in the <code>agentvault.models</code> module of the core library.</li> </ul>"},{"location":"a2a_profile_v0.2/#transport-details","title":"Transport Details","text":"<p>All JSON-RPC requests MUST be sent using the HTTP <code>POST</code> method to the agent's designated A2A endpoint URL (found in the <code>url</code> field of its Agent Card).</p> <ul> <li>Request Headers:<ul> <li><code>Content-Type: application/json</code> is REQUIRED.</li> <li><code>Accept: application/json</code> is RECOMMENDED.</li> <li>Authentication headers (e.g., <code>X-Api-Key</code> or <code>Authorization: Bearer &lt;token&gt;</code>) MUST be included if required by the agent's <code>authSchemes</code>.</li> </ul> </li> <li>Request Body: Contains the standard JSON-RPC 2.0 request object.</li> <li>Response Body (Non-Streaming): Contains the standard JSON-RPC 2.0 response object (either <code>result</code> or <code>error</code>). The HTTP status code SHOULD be <code>200 OK</code> even for JSON-RPC errors, as per JSON-RPC spec recommendations.</li> <li>Response Body (Streaming via <code>tasks/sendSubscribe</code>): The server responds with HTTP <code>200 OK</code> and <code>Content-Type: text/event-stream</code>. The body then contains a stream of Server-Sent Events (see SSE section).</li> </ul>"},{"location":"a2a_profile_v0.2/#authentication","title":"Authentication","text":"<p>Agents declare their supported authentication methods in the <code>authSchemes</code> list within their Agent Card. The <code>agentvault</code> client library (<code>AgentVaultClient</code> using <code>KeyManager</code>) handles these schemes automatically:</p> <ul> <li><code>none</code>: No authentication headers are sent. Suitable only for public, non-sensitive agents.</li> <li><code>apiKey</code>:<ul> <li>Client retrieves the API key associated with the <code>service_identifier</code> (from the Agent Card or user override) using <code>KeyManager</code>.</li> <li>Client sends the key in the <code>X-Api-Key</code> HTTP header.</li> <li>Server MUST validate the received key against its secure storage.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant Flow):<ul> <li>Requires the <code>AgentAuthentication</code> object in the card to include <code>tokenUrl</code>. <code>scopes</code> are optional.</li> <li>Client retrieves its own Client ID and Secret associated with the <code>service_identifier</code> using <code>KeyManager</code>.</li> <li>Client POSTs <code>grant_type=client_credentials</code>, <code>client_id</code>, <code>client_secret</code> (and optionally <code>scope</code>) to the agent's <code>tokenUrl</code>.</li> <li>Agent's token endpoint validates credentials and returns a JSON response with <code>access_token</code> (required), <code>token_type</code> (must be \"Bearer\", case-insensitive check), and optionally <code>expires_in</code>.</li> <li>Client sends the received <code>access_token</code> in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent A2A requests to the agent's main <code>url</code>.</li> <li>The <code>AgentVaultClient</code> automatically handles token fetching and caching (respecting <code>expires_in</code> if provided).</li> <li>Server's main A2A endpoint MUST validate the Bearer token (signature, expiry, audience, scopes if applicable).</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Client assumes the user/application has already obtained a valid Bearer token through other means.</li> <li>Client sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>The <code>agentvault</code> library currently requires explicit configuration or extension to handle this scheme, as it doesn't manage the token lifecycle.</li> <li>Server MUST validate the received Bearer token.</li> </ul> </li> </ul> <p>Refer to the main Security Considerations document for more details.</p>"},{"location":"a2a_profile_v0.2/#json-rpc-20-structure","title":"JSON-RPC 2.0 Structure","text":"<p>All requests and responses adhere to the JSON-RPC 2.0 specification.</p> <p>Request Object:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"method_name\",\n  \"params\": &lt;parameters_object_or_array&gt;,\n  \"id\": &lt;request_id_string_or_number_or_null&gt;\n}\n</code></pre> <ul> <li><code>jsonrpc</code>: MUST be exactly \"2.0\".</li> <li><code>method</code>: A string containing the name of the method (e.g., \"tasks/send\").</li> <li><code>params</code>: An optional structured value (object or array). AgentVault methods use parameter objects (dictionaries).</li> <li><code>id</code>: An identifier established by the Client. If included, the response MUST include the same value. If omitted (notification), the server MUST NOT reply. AgentVault methods generally expect an ID.</li> </ul> <p>Response Object (Success):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": &lt;result_value&gt;,\n  \"id\": &lt;matching_request_id&gt;\n}\n</code></pre> <ul> <li><code>result</code>: The value returned by the method invocation. Its structure depends on the method called (see method definitions below).</li> <li><code>id</code>: Must match the <code>id</code> from the Request Object.</li> </ul> <p>Response Object (Error):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": &lt;integer&gt;,\n    \"message\": &lt;string&gt;,\n    \"data\": &lt;optional_any&gt;\n  },\n  \"id\": &lt;matching_request_id_or_null&gt;\n}\n</code></pre> <ul> <li><code>error</code>: An object describing the error.<ul> <li><code>code</code>: A Number indicating the error type. See Error Codes.</li> <li><code>message</code>: A String providing a short description of the error.</li> <li><code>data</code>: Optional. A Primitive or Structured value containing additional information.</li> </ul> </li> <li><code>id</code>: Must match the <code>id</code> from the Request Object. If the error occurred before the ID could be determined (e.g., Parse Error), it SHOULD be <code>null</code>.</li> </ul>"},{"location":"a2a_profile_v0.2/#standard-a2a-methods","title":"Standard A2A Methods","text":"<p>These methods form the core of the AgentVault A2A interaction model, implemented by the <code>agentvault</code> client library and expected by servers built with the <code>agentvault-server-sdk</code>.</p>"},{"location":"a2a_profile_v0.2/#taskssend","title":"<code>tasks/send</code>","text":"<p>Initiates a new task or sends a subsequent message to an existing task.</p> <ul> <li>Params: <code>TaskSendParams</code> object (<code>agentvault.models.TaskSendParams</code>)<ul> <li><code>id</code> (Optional[str]): Task ID if continuing an existing task. Omit or null if initiating a new task.</li> <li><code>message</code> (Message): The message object (<code>agentvault.models.Message</code>) to send.</li> <li>(Optional) <code>webhookUrl</code> (Optional[str]): URL for agent push notifications (if agent supports <code>supportsPushNotifications</code>). Client is responsible for handling POST requests to this URL from the agent. (Note: Push notification handling is not fully implemented in client/SDK v0.2).</li> </ul> </li> <li>Result: <code>TaskSendResult</code> object (<code>agentvault.models.TaskSendResult</code>)<ul> <li><code>id</code> (str): The ID of the task (newly created or existing).</li> </ul> </li> <li>Example Request (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}],\n      \"metadata\": {\n        \"mcp_context\": { \"user_pref\": \"celsius\" }\n      }\n    }\n    {# Example including optional webhook: #}\n    {# \"webhookUrl\": \"https://my-client.example.com/webhook/task-updates\" #}\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Response (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Request (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-abc-123\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What about tomorrow?\"}]\n    }\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> <li>Example Response (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#tasksget","title":"<code>tasks/get</code>","text":"<p>Retrieve the current status and details of a specific task.</p> <ul> <li>Params: <code>TaskGetParams</code> object (<code>agentvault.models.TaskGetParams</code>)<ul> <li><code>id</code> (str): The ID of the task to retrieve.</li> </ul> </li> <li>Result: <code>Task</code> object (<code>agentvault.models.Task</code>) representing the full task state.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/get\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\",\n    \"state\": \"WORKING\",\n    \"createdAt\": \"2024-04-15T10:00:00Z\",\n    \"updatedAt\": \"2024-04-15T10:05:30Z\",\n    \"messages\": [\n      {\"role\": \"user\", \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}], \"metadata\": null},\n      {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Fetching weather...\"}], \"metadata\": null}\n    ],\n    \"artifacts\": [\n      {\"id\": \"artifact-1\", \"type\": \"log\", \"content\": \"API call made\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}\n    ],\n    \"metadata\": null\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskscancel","title":"<code>tasks/cancel</code>","text":"<p>Request the cancellation of an ongoing task.</p> <ul> <li>Params: <code>TaskCancelParams</code> object (<code>agentvault.models.TaskCancelParams</code>)<ul> <li><code>id</code> (str): The ID of the task to cancel.</li> </ul> </li> <li>Result: <code>TaskCancelResult</code> object (<code>agentvault.models.TaskCancelResult</code>)<ul> <li><code>success</code> (bool): Indicates if the cancellation request was accepted by the agent (doesn't guarantee immediate cancellation).</li> <li><code>message</code> (Optional[str]): Optional message from the agent regarding the cancellation request.</li> </ul> </li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/cancel\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"success\": true,\n    \"message\": \"Cancellation request received.\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskssendsubscribe","title":"<code>tasks/sendSubscribe</code>","text":"<p>Initiates a subscription to real-time updates for a task via Server-Sent Events (SSE).</p> <ul> <li>Params: Object containing the task ID.<ul> <li><code>id</code> (str): The ID of the task to subscribe to.</li> </ul> </li> <li>Response: HTTP <code>200 OK</code> with <code>Content-Type: text/event-stream</code>. The HTTP response body contains the SSE stream. No JSON-RPC <code>result</code> field is sent in the initial HTTP response body.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-5\"\n}\n</code></pre></li> <li>Example Response (HTTP Headers &amp; Body Start): <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\n... (more events) ...\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#task-states-taskstate-enum","title":"Task States (<code>TaskState</code> Enum)","text":"<p>The defined states for an A2A task lifecycle (<code>agentvault.models.TaskState</code>):</p> <ul> <li><code>SUBMITTED</code>: Task received, awaiting execution.</li> <li><code>WORKING</code>: Task actively being processed.</li> <li><code>INPUT_REQUIRED</code>: Task paused, awaiting further client input (advanced use case).</li> <li><code>COMPLETED</code>: Task finished successfully. (Terminal)</li> <li><code>FAILED</code>: Task terminated due to an error. (Terminal)</li> <li><code>CANCELED</code>: Task canceled by request. (Terminal)</li> </ul>"},{"location":"a2a_profile_v0.2/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Used for the <code>tasks/sendSubscribe</code> stream.</p> <ul> <li>Format: Standard SSE. Each event consists of <code>event:</code> and <code>data:</code> lines, terminated by <code>\\n\\n</code>. The <code>data:</code> field contains a single line JSON string.     <pre><code>event: &lt;event_type&gt;\ndata: &lt;json_payload_string&gt;\n\nevent: &lt;another_event_type&gt;\ndata: &lt;another_json_payload_string&gt;\n</code></pre></li> <li>Event Types (<code>event:</code> field):<ul> <li><code>task_status</code>: Task state change. <code>data</code> is JSON of <code>TaskStatusUpdateEvent</code>.</li> <li><code>task_message</code>: New message added. <code>data</code> is JSON of <code>TaskMessageEvent</code>.</li> <li><code>task_artifact</code>: Artifact created/updated. <code>data</code> is JSON of <code>TaskArtifactUpdateEvent</code>.</li> <li><code>error</code>: Server-side error during streaming. <code>data</code> is a JSON object like <code>{\"error\": \"code\", \"message\": \"desc\"}</code>.</li> </ul> </li> <li>Data Payload (<code>data:</code> field): A JSON string representing the corresponding event model (<code>agentvault.models.TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>). The client library validates these payloads against the Pydantic models.</li> </ul> <p>Example SSE Stream:</p> <pre><code>event: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\nevent: task_artifact\ndata: {\"taskId\": \"task-abc-123\", \"artifact\": {\"id\": \"log-1\", \"type\": \"debug_log\", \"content\": \"Processing step 1\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:10Z\"}\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"COMPLETED\", \"timestamp\": \"2024-04-15T10:05:15Z\", \"message\": \"Task finished successfully.\"}\n</code></pre>"},{"location":"a2a_profile_v0.2/#json-rpc-error-codes","title":"JSON-RPC Error Codes","text":"<p>Standard JSON-RPC codes MUST be used where applicable. AgentVault defines application-specific codes in the <code>-32000</code> to <code>-32099</code> range for agent-level errors.</p> Code Message Meaning Standard/App -32700 Parse error Invalid JSON received by the server. Standard -32600 Invalid Request The JSON sent is not a valid Request object. Standard -32601 Method not found The method does not exist / is not available. Standard -32602 Invalid Params Invalid method parameter(s). Standard -32603 Internal error Internal JSON-RPC error on the server. Standard -32000 Agent Server Error Generic application error on the agent. Application -32001 Task Not Found Specified <code>task_id</code> does not exist. Application -32002 Authentication Error API Key / Token invalid or missing. Application -32003 Authorization Error Authenticated user cannot perform action. Application -32004 Invalid State Operation not allowed in current task state. Application others Implementation Defined Server may define other -320xx errors. Application <p>Servers SHOULD include meaningful information in the <code>message</code> and optionally the <code>data</code> part of the error object. The client library (<code>A2ARemoteAgentError</code>) makes this information accessible.</p>"},{"location":"architecture/","title":"AgentVault Architecture","text":"<p>This document provides a high-level overview of the AgentVault architecture, illustrating the relationships between key components and communication protocols, emphasizing the secure, enterprise-grade workflow.</p>"},{"location":"architecture/#core-components-interactions","title":"Core Components &amp; Interactions","text":"<p>The AgentVault ecosystem enables secure and orchestrated interactions between various components:</p> <ol> <li>Developer/User: The human initiating tasks and managing the system, typically via the CLI.</li> <li>AgentVault CLI: The command-line interface for interacting with AgentVault, including running tasks, managing configurations, and discovering agents.</li> <li>Local Key Manager: A client-side component (using OS keyring, environment variables, or files) responsible for securely storing and retrieving credentials (like Registry API keys or Agent-specific keys/OAuth tokens) needed for authentication.</li> <li>AgentVault Registry: A central discovery service where agents publish their Agent Cards. It allows clients to find agents based on their capabilities or unique IDs (HRIs). Developer authentication is required to manage cards.</li> <li>Agent (A2A Compliant): The service performing the core task. In enterprise scenarios, this agent might run within a Trusted Execution Environment (TEE) for enhanced security and integrity. It communicates via the A2A protocol.</li> <li>TEE Attestation Service (Optional): An external or integrated service responsible for verifying the integrity and identity of an agent running within a TEE before sensitive operations are performed.</li> <li>Secure Artifact Storage (Optional): A dedicated storage solution (like cloud storage or a secure local store) used for handling large or sensitive data artifacts generated or consumed by agents, referenced via URLs or secure handles rather than being embedded directly in A2A messages.</li> <li>AgentVault Library: Used internally by the CLI (and potentially orchestrators or custom clients) to handle A2A communication, interact with the Key Manager, parse Agent Cards, and manage task lifecycles.</li> <li>(Implied) OAuth Authorization Server: Involved when agents use OAuth2 authentication schemes for secure, delegated access.</li> <li>(Implied) Policy Engine (e.g., OPA): Can be integrated by agents or infrastructure for fine-grained authorization decisions (as depicted in the Federated Identity concept).</li> </ol>"},{"location":"architecture/#communication-protocols","title":"Communication Protocols","text":"<ul> <li>A2A Protocol: The primary protocol for task management and communication between the CLI/Orchestrator and A2A-compliant Agents. Uses JSON-RPC 2.0 over HTTPS, with SSE for event streaming.</li> <li>Registry API: A RESTful API (HTTPS) used by the CLI and developers to manage and discover Agent Cards.</li> <li>Attestation Protocol: Specific protocol dependent on the TEE technology used (e.g., SGX Remote Attestation, AWS Nitro Attestation) used between the Agent (in TEE), the Attestation Service, and potentially the Client/CLI.</li> <li>Storage Protocol: Standard protocols like HTTPS (S3 API, etc.) used for interacting with Secure Artifact Storage.</li> <li>MCP (Model Context Protocol): Used for agent-to-tool communication, typically via a proxy agent. (See MCP Profile and MCP Example).</li> </ul>"},{"location":"architecture/#high-level-architecture-diagram","title":"High-Level Architecture Diagram","text":"<p>The following diagram visualizes the key components and a typical secure workflow, including optional TEE attestation:</p> <p> (Diagram showing the Developer interacting via CLI, which uses the KeyManager and Registry. The CLI optionally checks attestation with an Attestation Service before initiating a task with a Target Agent (potentially in a TEE). The Agent may interact with Secure Artifact Storage and streams results back to the CLI via A2A/SSE.)</p>"},{"location":"architecture/#explanation-of-secure-workflow","title":"Explanation of Secure Workflow","text":"<ol> <li>Task Initiation: The Developer uses the AgentVault CLI to run a task on a target agent, specifying the agent reference (HRI or URL) and input data. The <code>--attest</code> flag can be used to request TEE attestation verification.</li> <li>Agent Discovery (if HRI used): The CLI contacts the AgentVault Registry (authenticating using a Developer API Key fetched from the Local Key Manager) to retrieve the Agent Card for the target agent.</li> <li>Agent Card Parsing: The CLI parses the Agent Card to get the agent's A2A endpoint URL, required authentication schemes, and TEE details (if present).</li> <li>TEE Attestation (Optional): If the <code>--attest</code> flag was used and the Agent Card indicates TEE support, the CLI interacts with the appropriate TEE Attestation Service to verify the integrity and identity of the target agent instance before sending the task. If verification fails, the process stops.</li> <li>Credential Retrieval: The CLI requests the necessary credentials (API Key, OAuth details) for the target agent from the Local Key Manager. The Key Manager securely retrieves these based on the agent's requirements specified in the card.</li> <li>A2A Task Initiation: The CLI (using the underlying AgentVault Library) establishes a secure HTTPS connection to the Target Agent's A2A endpoint. It sends the <code>tasks/send</code> request (JSON-RPC), including the task input and necessary authentication headers (API Key or Bearer Token obtained via Key Manager/OAuth flow).</li> <li>Agent Processing &amp; SSE Streaming:<ul> <li>The Target Agent authenticates the request.</li> <li>It begins processing the task asynchronously.</li> <li>The CLI establishes an SSE connection (<code>tasks/sendSubscribe</code>) to receive real-time updates.</li> <li>The Agent streams <code>task_status</code>, <code>task_message</code>, and <code>task_artifact</code> events back to the CLI via SSE over HTTPS.</li> <li>Artifact Handling: If the agent generates large or sensitive artifacts, it may upload them to Secure Artifact Storage and send back only a URL or reference in the <code>task_artifact</code> event. Small artifacts might be included directly in the event.</li> </ul> </li> <li>Event Processing (CLI):<ul> <li>The CLI receives and parses SSE events.</li> <li>It displays status updates and messages to the Developer.</li> <li>For artifact events, if a URL/reference is present (or the artifact is deemed large), the CLI may download the content from Secure Artifact Storage. Otherwise, it displays/saves inline content.</li> <li>The SSE loop continues until a terminal task status (COMPLETED, FAILED, CANCELED) is received.</li> </ul> </li> <li>Final Status: The CLI may optionally make a final <code>tasks/get</code> call to retrieve the complete final task state.</li> <li>Results: The CLI displays the final results, status, and any relevant artifact locations or content to the Developer.</li> </ol> <p>This workflow, leveraging components like the Key Manager, Registry, optional TEE Attestation, and distinct communication protocols (A2A, MCP via proxy), provides a secure and robust framework for orchestrating complex agent tasks.</p>"},{"location":"concepts/","title":"AgentVault Concepts","text":"<p>This document outlines the core concepts behind the AgentVault framework.</p>"},{"location":"concepts/#vision","title":"Vision","text":"<p>AgentVault aims to enable secure, auditable, and collaborative interactions between autonomous AI agents, specialized tools, and human operators. It focuses on:</p> <ol> <li>Security: Ensuring agents operate within defined boundaries and data is handled securely, potentially leveraging Trusted Execution Environments (TEEs).</li> <li>Interoperability: Defining standard protocols (A2A, MCP) for seamless communication between different agents and tools.</li> <li>Orchestration: Facilitating complex workflows involving multiple agents and tools.</li> <li>Auditability: Providing mechanisms for logging and reviewing agent interactions.</li> <li>Discovery: Allowing agents and users to find and understand the capabilities of available agents via a Registry.</li> </ol>"},{"location":"concepts/#key-components","title":"Key Components","text":"<ol> <li>Agent: An autonomous entity capable of performing tasks, communicating via defined protocols, and potentially utilizing specialized tools or models. Agents advertise their capabilities via an Agent Card.</li> <li>Agent Card: A standardized metadata document (JSON format) describing an agent's identity, capabilities, endpoints, authentication requirements, provider information, and skills. It's the primary mechanism for agent discovery.</li> <li>Agent-to-Agent (A2A) Protocol: The primary communication protocol between AgentVault agents and clients/orchestrators. It uses JSON-RPC 2.0 over HTTP(S) and supports Server-Sent Events (SSE) for real-time, asynchronous updates (e.g., task status, messages, artifacts). Defines standard methods like <code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>.</li> <li>Model Context Protocol (MCP): (Revised based on POC)<ul> <li>Definition: The Model Context Protocol (MCP) provides a standardized interface for AgentVault components (orchestrators, agents) to discover and execute external Tools. It facilitates interaction with capabilities that might reside outside the core A2A agent network, such as code execution environments, filesystem access, or specialized APIs.</li> <li>Mechanism: MCP utilizes JSON-RPC 2.0 over HTTP(S) as its communication layer. It defines conventions for:<ul> <li>Tool Naming (e.g., <code>namespace.toolName</code> like <code>filesystem.readFile</code>).</li> <li>Request <code>params</code> structure for tool arguments.</li> <li>Response <code>result</code> structure, including standardized <code>content</code> arrays and an optional <code>isError</code> flag for tool-level errors.</li> </ul> </li> <li>Integration Pattern: AgentVault currently recommends integrating MCP tools into an A2A workflow using a dedicated MCP Tool Proxy Agent. This A2A-compliant agent receives requests specifying the target tool and arguments, translates them into MCP JSON-RPC calls to the appropriate tool server, and relays the results back to the A2A caller.</li> <li>Status &amp; Example: The protocol is defined and functional. The MCP Test Pipeline Example provides a working demonstration of this proxy pattern, interacting with custom Python-based MCP servers for filesystem operations and code execution. While direct client-side MCP support in the <code>agentvault</code> library may be enhanced in the future, the protocol itself and the proxy architecture are ready for use.</li> <li>Goal: Enable standardized, reusable access to a wide range of external capabilities within the AgentVault ecosystem.</li> </ul> </li> <li>Tool Server: A separate service (potentially non-A2A compliant itself) that exposes specific capabilities (e.g., code execution, database query, filesystem access) via the MCP protocol.</li> <li>AgentVault Registry: A central service where agents can publish their Agent Cards, allowing users and other agents to discover them based on ID, capabilities, or tags.</li> <li>Orchestrator: A component (human script, LangGraph workflow, or another agent) responsible for coordinating tasks across multiple agents and tools to achieve a larger goal.</li> <li>Client Library (<code>agentvault</code>): Python library providing tools for interacting with agents (A2A), managing local keys (<code>KeyManager</code>), and potentially interacting with the Registry.</li> <li>Server SDK (<code>agentvault-server-sdk</code>): Python SDK to simplify the creation of A2A-compliant agent servers, often integrating with web frameworks like FastAPI.</li> <li>Trusted Execution Environment (TEE) Profile: (Conceptual) A specification for how agents can leverage TEEs (like Intel SGX, AMD SEV) for enhanced security and verifiable computation, including attestation mechanisms.</li> </ol>"},{"location":"concepts/#core-interactions","title":"Core Interactions","text":"<ul> <li>Discovery: Client/Orchestrator queries the Registry to find an agent suitable for a task based on its Agent Card.</li> <li>A2A Task Initiation: Client sends an initial message to the agent's A2A endpoint (<code>tasks/send</code>) to start a task.</li> <li>A2A Event Streaming: Client subscribes (<code>tasks/sendSubscribe</code>) to the agent's SSE stream to receive real-time updates (status changes, messages, artifacts).</li> <li>A2A Tool Usage (via MCP Proxy):<ol> <li>Orchestrator sends an A2A task to the MCP Tool Proxy Agent, specifying the target MCP server ID, tool name, and arguments.</li> <li>Proxy Agent sends a standard MCP JSON-RPC request to the target Tool Server.</li> <li>Tool Server executes the tool and returns an MCP JSON-RPC response.</li> <li>Proxy Agent translates the MCP response into an A2A result/artifact and sends it back to the orchestrator.</li> </ol> </li> <li>State Management: Agents manage the state of their tasks internally (e.g., using the Server SDK's <code>TaskStore</code>). Orchestrators manage the overall pipeline state.</li> </ul> <p>This framework provides a flexible and secure foundation for building complex, collaborative AI systems.</p>"},{"location":"examples/","title":"AgentVault Examples","text":"<p>This section provides practical examples demonstrating how to use the various components of the AgentVault ecosystem.</p> <p>These examples are designed to help you get started quickly, whether you are building an A2A-compliant agent, using the client library to interact with agents, or utilizing the command-line interface.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>The source code for these examples can be found in the <code>/examples/</code> directory of the AgentVault GitHub repository.</p> <ul> <li> <p>Basic A2A Server: (View Code)</p> <ul> <li>Focus: Demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</li> <li>Features: Implements a simple \"EchoAgent\", uses the SDK's router integration (<code>create_a2a_router</code>), includes a basic <code>agent-card.json</code>, and shows how to run the server with Uvicorn.</li> <li>Good for: Developers starting to build their first A2A agent.</li> </ul> </li> <li> <p>LangChain Integration: (View Code)</p> <ul> <li>Focus: Shows how to wrap an AgentVault A2A agent as a custom <code>Tool</code> within the LangChain framework.</li> <li>Features: Defines an <code>A2AAgentTool</code> class that uses the <code>agentvault</code> client library internally to communicate with a remote agent based on an agent reference (ID, URL, or file path). Includes example usage.</li> <li>Good for: Developers wanting to integrate existing or new A2A agents into LangChain applications and agentic workflows.</li> </ul> </li> <li> <p>OAuth Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates implementing the <code>oauth2</code> (Client Credentials) authentication scheme using the Server SDK and FastAPI.</li> <li>Features: Includes a custom <code>/token</code> endpoint, uses environment variables for mock credentials, and protects the <code>/a2a</code> endpoint using a FastAPI dependency.</li> <li>Good for: Developers needing to implement OAuth2 authentication for their agents.</li> </ul> </li> <li> <p>Stateful Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates managing task state (like chat history) across multiple client interactions within a single task ID using the Server SDK.</li> <li>Features: Uses a custom <code>TaskContext</code> subclass, <code>InMemoryTaskStore</code>, and <code>asyncio.Event</code> to handle multi-turn interactions and background processing.</li> <li>Good for: Developers building conversational agents or agents that require maintaining context over several requests.</li> </ul> </li> <li> <p>Direct Library Usage: (View Code)</p> <ul> <li>Focus: Shows how to use the <code>agentvault</code> client library directly in a Python script to interact with an agent.</li> <li>Features: Demonstrates loading agent cards, using <code>KeyManager</code>, calling <code>AgentVaultClient</code> methods (<code>initiate_task</code>, <code>receive_messages</code>), and handling events and errors.</li> <li>Good for: Developers integrating AgentVault client functionality into custom applications or scripts.</li> </ul> </li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Please refer to the <code>README.md</code> file within each specific example directory (linked via \"[View Code]\" above) for detailed setup and execution instructions. Generally, you will need to:</p> <ol> <li>Ensure you have the main development environment set up (see Installation Guide).</li> <li>Navigate to the specific example directory (e.g., <code>cd examples/basic_a2a_server</code>).</li> <li>Install any example-specific requirements (usually via <code>pip install -r requirements.txt</code>).</li> <li>Follow the instructions in the example's <code>README.md</code> to run the server or script.</li> </ol> <p>We encourage you to explore these examples and adapt them for your own use cases!</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide covers how to install the different components of the AgentVault framework.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: Version 3.10 or higher is recommended.</li> <li>pip: Python's package installer.</li> <li>Poetry (Recommended): For development and managing dependencies within individual component repositories (<code>poetry install</code>).</li> <li>Docker &amp; Docker Compose: Required for running the AgentVault Registry and containerized agents/POC pipelines.</li> <li>Git: For cloning the repository.</li> <li>(Optional) OS Keyring Backend: If using the <code>KeyManager</code> with the OS keyring (<code>use_keyring=True</code>), ensure a supported backend is installed (e.g., <code>keyrings.cryptfile</code>, <code>keyrings.osx</code>, <code>keyrings.windows</code>).</li> </ul>"},{"location":"installation/#core-library-agentvault","title":"Core Library (<code>agentvault</code>)","text":"<p>This library provides the client (<code>AgentVaultClient</code>), models, key management (<code>KeyManager</code>), and utilities needed to interact with AgentVault agents and potentially the registry.</p> <pre><code># Install from PyPI (once published)\n# pip install agentvault\n\n# Install locally from source (for development)\ncd agentvault_library\npoetry install\n# Or using pip editable mode from the monorepo root:\n# pip install -e agentvault_library\n</code></pre> <ul> <li>Optional Keyring: To enable storing credentials in the OS keyring:     <pre><code># When using pip:\npip install agentvault[os_keyring]\n# When using poetry:\npoetry install --extras os_keyring\n</code></pre></li> </ul>"},{"location":"installation/#server-sdk-agentvault-server-sdk","title":"Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>This SDK helps you build your own A2A-compliant agents.</p> <pre><code># Install from PyPI (once published)\n# pip install agentvault-server-sdk\n\n# Install locally from source (for development)\ncd agentvault_server_sdk\npoetry install\n# Or using pip editable mode from the monorepo root:\n# pip install -e agentvault_server_sdk\n</code></pre>"},{"location":"installation/#command-line-interface-agentvault-cli","title":"Command Line Interface (<code>agentvault-cli</code>)","text":"<p>The CLI provides commands for discovering agents, running tasks, and managing local configuration.</p> <pre><code># Install from PyPI (once published)\n# pip install agentvault-cli\n\n# Install locally from source (for development)\ncd agentvault_cli\npoetry install\n# Or using pip editable mode from the monorepo root:\n# pip install -e agentvault_cli\n\n# Verify installation\nagentvault --version\n</code></pre>"},{"location":"installation/#agentvault-registry-agentvault_registry","title":"AgentVault Registry (<code>agentvault_registry</code>)","text":"<p>The registry is a central service for agent discovery. It requires Docker and Docker Compose.</p> <p>Setup Instructions:</p> <p>Detailed instructions for building the Docker image, configuring the <code>.env</code> file (database connection, admin user, secrets), and running the registry service using <code>docker compose</code> can be found in the Registry Setup &amp; API Guide.</p>"},{"location":"installation/#testing-utilities-agentvault-testing-utils","title":"Testing Utilities (<code>agentvault-testing-utils</code>)","text":"<p>This package provides utilities for testing agents and components within the AgentVault ecosystem. It's typically installed as a development dependency.</p> <pre><code># Install locally from source (for development)\ncd agentvault_testing_utils\npoetry install\n# Or using pip editable mode from the monorepo root:\n# pip install -e agentvault_testing_utils\n</code></pre>"},{"location":"installation/#proof-of-concept-poc-agents-pipelines","title":"Proof-of-Concept (POC) Agents &amp; Pipelines","text":"<p>The various POC pipelines (Research, Support, ETL, etc.) have their own setup instructions within their respective directories under <code>poc_agents/</code>. Generally, they involve:</p> <ol> <li>Navigating to the specific POC directory (e.g., <code>cd poc_agents/research_pipeline</code>).</li> <li>Configuring <code>.env</code> files for the agents and orchestrator within that POC.</li> <li>Using <code>docker compose build</code> and <code>docker compose up -d</code> (or specific build/run scripts provided within the POC directory).</li> </ol> <p>Refer to the <code>README.md</code> or documentation within each POC directory for specific setup steps.</p>"},{"location":"mcp/","title":"Model Context Protocol (MCP) Profile (Concept)","text":"<p>Status: Defined &amp; Implemented via Proxy Pattern</p>"},{"location":"mcp/#1-introduction","title":"1. Introduction","text":"<p>The Model Context Protocol (MCP) provides a standardized interface for AgentVault components (like orchestrators or other agents) to discover and execute external Tools. MCP enables interaction with capabilities that might reside outside the core A2A agent network, such as secure code execution environments, dedicated filesystem access points, specialized database query engines, or specific hardware interactions.</p> <p>Goal: To enable standardized, reusable, and potentially secured access to a wide range of external capabilities within the AgentVault ecosystem, complementing the more general-purpose A2A protocol.</p>"},{"location":"mcp/#2-protocol-basics","title":"2. Protocol Basics","text":"<ul> <li>Transport: MCP uses HTTP/1.1 or HTTP/2, typically over TLS (HTTPS).</li> <li>Message Format: MCP utilizes JSON-RPC 2.0 (Specification) for all request/response interactions.<ul> <li>Standard JSON-RPC fields (<code>jsonrpc</code>, <code>id</code>, <code>method</code>, <code>params</code>, <code>result</code>, <code>error</code>) are used.</li> </ul> </li> <li>Tool Naming: Tools are identified using a namespace convention, typically <code>namespace.toolName</code> (e.g., <code>filesystem.readFile</code>, <code>code.runPython</code>).</li> <li>Standard Results: Successful tool executions return a JSON-RPC <code>result</code> object, conventionally containing a <code>content</code> array of standardized data structures (e.g., <code>{\"type\": \"text\", \"text\": \"...\"}</code>, <code>{\"type\": \"code_output\", \"stdout\": \"...\", \"stderr\": \"...\"}</code>).</li> <li>Tool Errors: Tool-specific execution errors (e.g., file not found, code execution timeout) are typically reported within the JSON-RPC <code>result</code> object by setting an <code>\"isError\": true</code> flag and providing error details within the <code>content</code> array, distinct from JSON-RPC protocol errors.</li> </ul> <pre><code>// Example MCP Success Result\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-123\",\n  \"result\": {\n    \"content\": [{\"type\": \"text\", \"text\": \"Content of the file.\"}]\n  }\n}\n\n// Example MCP Tool Error Result\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-456\",\n  \"result\": {\n    \"isError\": true,\n    \"content\": [{\"type\": \"text\", \"text\": \"Error: File not found at specified path.\"}]\n  }\n}\n</code></pre>"},{"location":"mcp/#3-integration-with-agentvault-a2a-proxy-pattern","title":"3. Integration with AgentVault (A2A Proxy Pattern)","text":"<p>While direct client-side support for MCP calls may be added to the <code>agentvault</code> library in the future, the current recommended and proven pattern for integrating MCP tools into AgentVault workflows is via a dedicated MCP Tool Proxy Agent.</p> <ul> <li>MCP Tool Proxy Agent: An A2A-compliant agent (built using the <code>agentvault-server-sdk</code>) acts as a bridge.</li> <li> <p>Workflow:</p> <ol> <li>An Orchestrator (or other A2A client) sends a standard A2A <code>tasks/send</code> request to the Proxy Agent. The request's <code>DataPart</code> specifies the target tool server (e.g., by a logical ID like <code>\"filesystem\"</code>), the tool name (<code>filesystem.readFile</code>), and the arguments (<code>{\"path\": \"/data/file.txt\"}</code>).</li> <li>The Proxy Agent looks up the actual network address of the target MCP Tool Server based on the provided ID (often configured via environment variables).</li> <li>The Proxy Agent constructs and sends a standard MCP JSON-RPC 2.0 request over HTTP to the target Tool Server's <code>/rpc</code> endpoint.</li> <li>The MCP Tool Server executes the tool and returns a JSON-RPC 2.0 response (containing either a <code>result</code> or an <code>error</code>).</li> <li>The Proxy Agent receives the MCP response and translates it back into a standard A2A task result (e.g., putting the MCP <code>result</code> or error details into a <code>DataPart</code> artifact or message).</li> <li>The Orchestrator receives the outcome of the tool execution via the A2A protocol from the Proxy Agent.</li> </ol> </li> <li> <p>Benefits: This pattern decouples the A2A and MCP domains, allowing orchestrators to leverage MCP tools without implementing MCP specifics. It centralizes the logic for communicating with different tool servers within the proxy.</p> </li> <li>Demonstration: The MCP Test Pipeline Example successfully implements this pattern, showcasing interaction with custom Python-based MCP servers for filesystem and code execution tasks.</li> </ul>"},{"location":"mcp/#4-mcp-tool-servers","title":"4. MCP Tool Servers","text":"<p>These are the actual services performing the work. They only need to expose an HTTP endpoint (e.g., <code>/rpc</code>) that accepts JSON-RPC 2.0 requests for their specific tools.</p> <ul> <li>Examples:<ul> <li><code>custom-filesystem-mcp</code>: Provides <code>filesystem.readFile</code>, <code>filesystem.writeFile</code>, <code>filesystem.listDirectory</code>.</li> <li><code>custom-code-runner-mcp</code>: Provides <code>code.runPython</code>.</li> </ul> </li> <li>Implementation: Can be built using any web framework capable of handling JSON-RPC over HTTP (like FastAPI, Express, etc.). The AgentVault project provides examples using Python/FastAPI.</li> </ul>"},{"location":"mcp/#5-future-directions","title":"5. Future Directions","text":"<ul> <li>Formalizing standard MCP tool namespaces and content types.</li> <li>Defining a standard MCP-based tool discovery mechanism.</li> <li>Potentially adding direct MCP client capabilities to the <code>agentvault</code> library.</li> </ul>"},{"location":"privacy_policy/","title":"AgentVault Registry API - Privacy Policy","text":"<p>Last Updated: [April 12, 2025]</p> <p>This Privacy Policy describes how the AgentVault Project Maintainers (\"we\", \"us\", \"our\") collect, use, and handle information in connection with your use of the AgentVault Registry API (the \"Service\").</p> <p>1. Data Controller</p> <p>The data controller for the information processed via the Service is The AgentVault Project Maintainers. You can contact us regarding privacy matters at:</p> <p><code>[AgentVault@proton.me]</code></p> <p>2. Information We Collect</p> <p>We collect the following types of information:</p> <ul> <li> <p>Information Provided by Developers:</p> <ul> <li>Developer Name: When a developer account is created or associated with an API key (process TBD).</li> <li>Hashed API Key: We store a cryptographically hashed version of the API key assigned to developers for authentication purposes. We never store the plain-text API key after initial generation and verification.</li> <li>Agent Card Metadata: The full JSON content of Agent Cards submitted by developers, which may include agent names, descriptions, endpoint URLs, provider details, etc., as defined by the A2A Agent Card schema.</li> <li>(Optional - If Implemented Later): Developer Email Address: If we implement features requiring direct communication (e.g., account recovery, important service notifications), we may collect developer email addresses. This will be clearly indicated at the time of collection.</li> </ul> </li> <li> <p>Information Collected Automatically:</p> <ul> <li>Log Data: Like most web services, our servers automatically record information (\"Log Data\") created by your use of the Service. Log Data may include information such as your IP address, browser type, operating system, the referring web page, pages visited, location (if enabled by your browser), device information, search terms (for the registry search endpoint), and cookie information (if applicable, though the API itself likely doesn't use persistent cookies). We use Log Data for security monitoring, service operation, debugging, and aggregated analytics.</li> </ul> </li> </ul> <p>3. How We Use Information</p> <p>We use the information we collect for the following purposes:</p> <ul> <li>To Provide and Maintain the Service: To operate the registry, allow agent discovery, authenticate developers, store and serve Agent Cards.</li> <li>To Improve the Service: To analyze usage patterns (using aggregated/anonymized data where possible) to understand how the Service is used and identify areas for improvement.</li> <li>To Ensure Security: To monitor for and prevent fraudulent activity, abuse, and security incidents. To verify developer identities via API keys.</li> <li>To Communicate (If Applicable): If we collect email addresses, we may use them to communicate important service updates, security notices, or respond to support requests or reports. We will provide opt-out mechanisms for non-essential communications.</li> <li>To Comply with Law: To comply with applicable legal obligations, regulations, or valid legal processes.</li> </ul> <p>4. Data Sharing and Disclosure</p> <ul> <li>Public Agent Card Data: The Agent Card metadata submitted by developers (excluding potentially sensitive internal details not part of the standard schema display) is intended to be publicly accessible via the API for discovery purposes.</li> <li>Service Providers: We may engage third-party companies or individuals as service providers (e.g., hosting providers, database providers) to process information on our behalf based on our instructions and in compliance with this Privacy Policy and appropriate confidentiality and security measures.</li> <li>Legal Requirements: We may disclose information if required to do so by law or in the good faith belief that such action is necessary to comply with a legal obligation, protect and defend our rights or property, prevent fraud, act in urgent circumstances to protect the personal safety of users of the Service or the public, or protect against legal liability.</li> <li>Aggregated/Anonymized Data: We may share aggregated or anonymized information (which does not identify individuals) for research, analytics, or reporting purposes.</li> <li>We do not sell developer personal information.</li> </ul> <p>5. Data Security</p> <p>We implement reasonable technical and organizational measures to protect the information we collect from loss, misuse, unauthorized access, disclosure, alteration, and destruction. This includes using HTTPS for API communication and hashing developer API keys. However, no internet transmission or electronic storage is 100% secure.</p> <p>6. Data Retention</p> <p>We retain information for as long as necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law.</p> <ul> <li>Developer Information: Retained as long as the developer account is active or as needed for operational purposes.</li> <li>Agent Card Data: Retained as long as the card is active or for a reasonable period after deactivation for archival purposes, unless requested otherwise by the developer under their rights.</li> <li>Log Data: Typically retained for a limited period (e.g., 30-90 days) for security and debugging purposes, unless required for ongoing investigations or legal obligations.</li> </ul> <p>7. Your Rights (GDPR and other applicable laws)</p> <p>Depending on your location, you may have certain rights regarding your personal information, including:</p> <ul> <li>The right to access the personal information we hold about you.</li> <li>The right to request correction of inaccurate personal information.</li> <li>The right to request erasure of your personal information (subject to legal/operational constraints).</li> <li>The right to object to or restrict processing of your personal information.</li> <li>The right to data portability.</li> </ul> <p>To exercise these rights, please contact us at:</p> <p><code>[AgentVault@proton.me]</code></p> <p>We will respond to your request consistent with applicable law.</p> <p>8. International Data Transfers</p> <p>The Service may be hosted and operated in jurisdictions outside of your own. By using the Service, you consent to the transfer of your information to these jurisdictions, which may have data protection rules that are different from those of your country.</p> <p>9. Children's Privacy</p> <p>The Service is not directed to individuals under the age of 16 (or the relevant age of digital consent in your jurisdiction). We do not knowingly collect personal information from children. If we become aware that a child has provided us with personal information, we will take steps to delete such information.</p> <p>10. Changes to This Privacy Policy</p> <p>We may update this Privacy Policy from time to time. If we make material changes, we will notify you by updating the \"Last Updated\" date at the top of this policy and potentially through other means (e.g., a notice on a project website or mailing list, if available). We encourage you to review this policy periodically.</p> <p>11. Contact Us</p> <p>If you have any questions about this Privacy Policy, please contact us at:</p> <p><code>[AgentVault@proton.me]</code></p>"},{"location":"security/","title":"AgentVault Security Considerations","text":"<p>Note: For the official security policy and vulnerability reporting process, please see the Security Policy document.</p> <p>This document details the security mechanisms, considerations, and best practices within the AgentVault ecosystem. Security is fundamental to enabling trustworthy interactions between agents and protecting user/developer credentials.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Authentication verifies the identity of the communicating parties. AgentVault employs different mechanisms for client-to-agent and developer-to-registry interactions.</p>"},{"location":"security/#1-client-to-agent-authentication-a2a","title":"1. Client-to-Agent Authentication (A2A)","text":"<p>Agents declare how clients should authenticate in their <code>AgentCard</code> (<code>authSchemes</code>). The <code>agentvault</code> library supports:</p> <ul> <li><code>none</code>: No authentication. Use only for public, non-sensitive agents.</li> <li><code>apiKey</code>: Client sends a pre-shared secret in <code>X-Api-Key</code>. Requires secure key management on both client (<code>KeyManager</code>) and server (agent implementation).</li> <li><code>oauth2</code> (Client Credentials Grant): Client uses its ID/Secret (managed by <code>KeyManager</code>) to get a Bearer token from the agent's <code>/token</code> endpoint. The client sends this token in the <code>Authorization: Bearer &lt;token&gt;</code> header for A2A requests. The <code>AgentVaultClient</code> handles token fetching/caching. The agent server must implement the <code>/token</code> endpoint and validate Bearer tokens at its <code>/a2a</code> endpoint.</li> <li><code>bearer</code>: Client sends a pre-obtained Bearer token. Token lifecycle management is external to AgentVault library. Agent server must validate the token.</li> </ul> <p>(Refer to the A2A Profile for more detail)</p>"},{"location":"security/#2-developer-to-registry-authentication","title":"2. Developer-to-Registry Authentication","text":"<p>The registry uses a multi-faceted approach for developers managing their agents:</p> <ul> <li>Account Creation: Developers register using email and password. Passwords are hashed using bcrypt (<code>passlib</code>) before storage. Email verification is required.</li> <li>Login (JWT): Successful login (<code>POST /auth/login</code>) returns a JSON Web Token (JWT) signed using a server-side secret (<code>API_KEY_SECRET</code> from config). This JWT acts as a session token.</li> <li>Authenticated Requests (JWT): Developers include the JWT in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent requests to protected endpoints (e.g., managing agent cards, API keys, using the agent builder). The registry API verifies the token's signature and expiry.</li> <li>Account Recovery (Recovery Keys): During registration, single-use recovery keys are generated. One representative key's hash (using bcrypt) is stored. If a developer loses their password, they can use their email and one of the plain text recovery keys (which they stored securely offline) via <code>POST /auth/recover-account</code>. The server verifies the key against the stored hash. If valid, it issues a very short-lived JWT specifically for setting a new password (<code>POST /auth/set-new-password</code>). The recovery key hash is then invalidated in the database.</li> <li>Programmatic API Keys:<ul> <li>Purpose: For non-interactive use (scripts, CI/CD) to manage agent cards.</li> <li>Generation: Developers generate these keys via the Developer Portal UI or <code>POST /developers/me/apikeys</code>. The full key (e.g., <code>avreg_...</code>) is shown only once.</li> <li>Storage: The hash of the full key (using <code>passlib</code> with bcrypt) and the non-secret prefix (<code>avreg_</code>) are stored in the <code>developer_api_keys</code> database table.</li> <li>Verification: For requests using the <code>X-Api-Key</code> header, the registry API finds potential keys based on the prefix, then uses <code>passlib.verify()</code> to check the provided plain key against the stored hashes for active keys belonging to the developer associated with the prefix match (lookup logic might need optimization for scale).</li> </ul> </li> </ul> <p>Security Implications:</p> <ul> <li>JWTs provide standard session management but require secure handling of the <code>API_KEY_SECRET</code> on the server.</li> <li>Recovery keys provide a fallback but must be stored securely by the developer; losing them means losing account access if password reset fails. Hashing the stored key prevents direct compromise from database leaks.</li> <li>Programmatic API keys offer convenience for automation but must be treated as sensitive secrets by the developer. Hashing provides database-level protection.</li> </ul>"},{"location":"security/#credential-management-keymanager-client-side","title":"Credential Management (<code>KeyManager</code> - Client Side)","text":"<p>(This section remains largely the same as before, emphasizing keyring usage)</p> <p>The <code>agentvault</code> library's <code>KeyManager</code> provides a unified way for clients (like the CLI) to manage credentials needed for agent authentication.</p> <ul> <li>Secure Storage: Strongly recommends using the OS Keyring (<code>--keyring</code> or <code>--oauth-configure</code> options in CLI <code>config set</code>) for storing sensitive API keys and OAuth secrets.</li> <li>Alternative Sources: Supports loading from environment variables and <code>.env</code>/<code>.json</code> files, but users must ensure appropriate security for these methods.</li> <li>Abstraction: Client code interacts with <code>KeyManager</code> without needing to know the storage location.</li> </ul>"},{"location":"security/#transport-security","title":"Transport Security","text":"<ul> <li>HTTPS is MANDATORY for all communication with the AgentVault Registry API and any A2A agent endpoint not run on <code>localhost</code>.</li> </ul>"},{"location":"security/#data-validation","title":"Data Validation","text":"<ul> <li>Pydantic: Used extensively for request/response validation in the registry API, server SDK, and core library models, preventing malformed data issues.</li> <li>Registry: Validates submitted <code>card_data</code> against the canonical <code>agentvault.models.AgentCard</code> schema.</li> </ul>"},{"location":"security/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Registry: Implements basic IP-based rate limiting (<code>slowapi</code>).</li> <li>Agents: Agent developers should implement their own rate limiting.</li> </ul>"},{"location":"security/#trusted-execution-environments-tee","title":"Trusted Execution Environments (TEE)","text":"<ul> <li>Current Status: Declarative only. Agent Cards can specify TEE usage, and the registry supports filtering based on this.</li> <li>Future Work: Automated attestation verification is planned.</li> </ul>"},{"location":"security/#dependency-security","title":"Dependency Security","text":"<ul> <li>Auditing: Automated checks via GitHub Actions (<code>pip-audit</code>).</li> <li>Updates: Regular updates are crucial.</li> </ul>"},{"location":"security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Please report suspected security vulnerabilities privately according to the Security Policy.</p>"},{"location":"security_policy/","title":"Security Policy for AgentVault","text":""},{"location":"security_policy/#introduction","title":"Introduction","text":"<p>The AgentVault project prioritizes security. We appreciate the efforts of security researchers and the community in helping us maintain a secure ecosystem. This document outlines our policy for reporting security vulnerabilities.</p>"},{"location":"security_policy/#scope","title":"Scope","text":"<p>This policy applies to the following components and repositories within the AgentVault project:</p> <ul> <li><code>agentvault</code> (Core Library): Located in the <code>agentvault_library/</code> directory.</li> <li><code>agentvault-registry</code> (Registry API): Located in the <code>agentvault_registry/</code> directory.</li> <li><code>agentvault-cli</code> (CLI Client): Located in the <code>agentvault_cli/</code> directory.</li> <li><code>agentvault-server-sdk</code> (Server SDK): Located in the <code>agentvault_server_sdk/</code> directory.</li> </ul> <p>Vulnerabilities discovered in third-party agents listed in the registry should be reported directly to the respective agent provider according to their own security policy. The AgentVault registry itself only stores metadata.</p>"},{"location":"security_policy/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We appreciate responsible disclosure. Please report any suspected security vulnerabilities privately to ensure the security of our users and the ecosystem.</p> <p>Preferred Method:</p> <ul> <li> <p>GitHub Private Vulnerability Reporting: If you are reporting via GitHub, please use the built-in \"Report a vulnerability\" feature within the main AgentVault repository. This allows for secure communication and tracking.</p> <p><code>[https://github.com/SecureAgentTools/AgentVault/]</code></p> </li> </ul> <p>Alternative Method:</p> <ul> <li> <p>Email: If you cannot use GitHub's reporting feature, you can email your report to:</p> <p><code>[AgentVault@proton.com</code></p> <p>Use a clear subject line like \"Security Vulnerability Report: AgentVault [Component Name]\".</p> </li> </ul> <p>What to Include:</p> <p>Please include the following details in your report:</p> <ul> <li>Component: Which part of AgentVault is affected (library, registry, CLI, SDK)?</li> <li>Version: The specific version number or commit hash, if known.</li> <li>Description: A clear and concise description of the vulnerability.</li> <li>Steps to Reproduce: Detailed steps required to reproduce the vulnerability. Include code snippets, configuration details, or specific API requests if applicable.</li> <li>Potential Impact: Your assessment of the potential impact of the vulnerability.</li> <li>Contact Information: Your name or alias and contact email address for follow-up.</li> </ul>"},{"location":"security_policy/#our-commitment","title":"Our Commitment","text":"<ul> <li>We will acknowledge receipt of your vulnerability report, typically within 48 business hours.</li> <li>We will investigate the report promptly and work to validate the vulnerability.</li> <li>We will keep you informed of our progress during the investigation and remediation process.</li> <li>We aim to address critical vulnerabilities as quickly as possible.</li> <li>We will coordinate public disclosure with you after a fix is available, potentially issuing security advisories and crediting you for your discovery (unless you prefer to remain anonymous).</li> </ul>"},{"location":"security_policy/#safe-harbor","title":"Safe Harbor","text":"<p>We consider security research and vulnerability reporting activities conducted under this policy to be authorized and beneficial. We will not pursue legal action against individuals who report vulnerabilities in good faith, adhere to this policy, and do not cause harm to AgentVault, its users, or its infrastructure.</p> <p>Thank you for helping keep AgentVault secure.</p>"},{"location":"tee_profile/","title":"AgentVault TEE Profile (v0.1 - Declarative)","text":"<p>This document outlines the initial support for Trusted Execution Environments (TEEs) within the AgentVault ecosystem, focusing on declaration and discovery.</p> <p>Version: 0.1 (Declarative Phase)</p>"},{"location":"tee_profile/#overview","title":"Overview","text":"<p>Trusted Execution Environments (TEEs) like Intel SGX, AMD SEV, AWS Nitro Enclaves, Azure Confidential Computing, Confidential Space, etc., provide hardware-level isolation to protect the confidentiality and integrity of code and data being processed. Leveraging TEEs can significantly enhance the security posture of AI agents, especially when handling sensitive information or performing critical tasks.</p> <p>AgentVault aims to facilitate the use of TEEs by allowing agents to declare their TEE usage within their Agent Card and enabling clients (like the CLI or library) to discover agents based on this capability via the Registry.</p>"},{"location":"tee_profile/#agent-card-declaration","title":"Agent Card Declaration","text":"<p>Agents running within a TEE can declare this capability in their <code>agent-card.json</code> file within the <code>capabilities</code> object, using the optional <code>teeDetails</code> field. This corresponds to the <code>agentvault.models.TeeDetails</code> Pydantic model.</p> <p>Schema Fields:</p> <ul> <li><code>capabilities.teeDetails</code> (Optional Object): Contains details about the TEE. If this object is present, it indicates the agent utilizes a TEE.<ul> <li><code>type</code> (String, Required if <code>teeDetails</code> is present): An identifier for the specific TEE technology used. Examples: <code>\"Intel SGX\"</code>, <code>\"AMD SEV-SNP\"</code>, <code>\"AWS Nitro Enclaves\"</code>, <code>\"Azure Confidential Computing\"</code>, <code>\"Confidential Space\"</code>. Standardized identifiers are preferred, but custom strings are allowed.</li> <li><code>attestationEndpoint</code> (String, Optional, Format: URL): A URL where clients can potentially obtain or verify an attestation document for the specific TEE instance hosting the agent. The format and verification process for the attestation document are specific to the TEE type and are outside the scope of this profile version.</li> <li><code>publicKey</code> (String, Optional): A public key associated with the TEE instance, potentially used for establishing secure channels or verifying attestations. The format (e.g., PEM, JWK) depends on the TEE type and attestation protocol. Currently informational only.</li> <li><code>description</code> (String, Optional): A human-readable description of the TEE setup, its purpose, or the guarantees it provides for this agent.</li> </ul> </li> </ul> <p>Example <code>agent-card.json</code> Snippet:</p> <pre><code>{\n  \"schemaVersion\": \"1.0\",\n  // ... other fields ...\n  \"capabilities\": {\n    \"a2aVersion\": \"1.0\",\n    // ... other capabilities ...\n    \"teeDetails\": {\n      \"type\": \"AWS Nitro Enclaves\",\n      \"attestationEndpoint\": \"https://attestation.example-agent.com/verify\",\n      \"description\": \"Agent runs within an AWS Nitro Enclave for enhanced data confidentiality during processing.\"\n    }\n  },\n  // ... other fields ...\n}\n</code></pre>"},{"location":"tee_profile/#discovery-via-registry","title":"Discovery via Registry","text":"<p>The AgentVault Registry API (<code>agentvault_registry</code>) supports filtering agents based on their TEE declaration:</p> <ul> <li><code>GET /api/v1/agent-cards/?has_tee=true</code>: Returns only agents whose Agent Card includes the <code>capabilities.teeDetails</code> object (regardless of its content).</li> <li><code>GET /api/v1/agent-cards/?has_tee=false</code>: Returns only agents whose Agent Card does not include the <code>capabilities.teeDetails</code> object.</li> <li><code>GET /api/v1/agent-cards/?tee_type=&lt;type_string&gt;</code>: Returns only agents where <code>capabilities.teeDetails.type</code> matches the provided <code>&lt;type_string&gt;</code> (case-insensitive comparison recommended for the registry implementation). Example: <code>?tee_type=AWS%20Nitro%20Enclaves</code>.</li> </ul> <p>The public Registry Web UI and the <code>agentvault_cli discover</code> command also provide options corresponding to these filters.</p>"},{"location":"tee_profile/#current-scope-limitations-v01","title":"Current Scope &amp; Limitations (v0.1)","text":"<ul> <li>Declarative Only: This version focuses solely on allowing agents to declare their TEE usage and enabling discovery based on that declaration.</li> <li>No Automated Verification: AgentVault clients (library, CLI) do not automatically perform TEE attestation verification based on the <code>attestationEndpoint</code> or <code>publicKey</code>. Implementing robust and generic attestation verification is complex due to the variety of TEE technologies and attestation protocols.</li> <li>Client Responsibility: Clients wishing to verify an agent's TEE status must currently implement the verification logic themselves, specific to the declared <code>teeDetails.type</code> and using the provided <code>attestationEndpoint</code> or other out-of-band mechanisms. The presence of <code>teeDetails</code> in the card is not a guarantee verified by AgentVault itself.</li> <li>No Secure Channel Guarantee: Declaring TEE usage does not automatically establish a TEE-secured communication channel beyond standard transport security (HTTPS). Establishing such channels might be a future enhancement, potentially leveraging the <code>publicKey</code>.</li> </ul>"},{"location":"tee_profile/#future-work","title":"Future Work","text":"<ul> <li>Researching and potentially integrating standardized TEE attestation verification libraries or protocols into the <code>agentvault</code> client library.</li> <li>Defining mechanisms for establishing secure communication channels directly with TEE enclaves, possibly leveraging the declared <code>publicKey</code>.</li> <li>Standardizing <code>teeDetails.type</code> identifiers further.</li> </ul>"},{"location":"use_cases/","title":"AgentVault Use Cases &amp; Scenarios","text":"<p>The core AgentVault Vision is to enable a future where diverse AI agents can collaborate securely and effectively. This page provides concrete examples of complex workflows made possible or significantly easier by the AgentVault ecosystem and its foundational components.</p> <p>These scenarios illustrate how features like standardized discovery (Registry), secure interoperable communication (A2A Profile), robust authentication (Auth Schemes &amp; KeyManager), and developer tooling (SDKs, Library) come together to create powerful, automated solutions.</p>"},{"location":"use_cases/#scenario-1-hyper-personalized-concierge-life-management","title":"Scenario 1: Hyper-Personalized Concierge &amp; Life Management","text":"<p>Goal: An AI personal assistant that proactively manages complex tasks like travel planning by securely coordinating multiple specialized agents based on deep user preferences stored securely.</p> <p>Workflow:</p> <ol> <li>User Request: User asks their primary Orchestrator Agent to plan a trip with specific constraints (destination, budget, preferences).</li> <li>Secure Context: Orchestrator authenticates (e.g., OAuth2) with the user's Profile Agent (running in a TEE) to retrieve relevant, scoped preferences.</li> <li>Discovery: Orchestrator queries the AgentVault Registry for agents capable of <code>flights</code>, <code>hotels</code>, <code>activity-booking</code>, <code>reviews</code>.</li> <li>Task Delegation: Orchestrator tasks discovered agents (<code>FlightSearchAgent</code>, <code>HotelSearchAgent</code>, etc.) via the A2A protocol. Authentication (e.g., API Key via KeyManager) is used for premium or booking agents.</li> <li>Results &amp; Synthesis: Agents return results (potentially streaming via SSE). Orchestrator synthesizes options.</li> <li>Action: Upon user confirmation, Orchestrator securely instructs booking agents via A2A to finalize reservations.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph UserInteraction[\"User Interaction\"]\n        User((\"\ud83d\udc64 User\"))\n        Orchestrator[/\"\ud83e\udde0 OrchestratorAgent\"/]\n    end\n\n    subgraph SecureProfile[\"Secure User Profile\"]\n        ProfileAgent[(\"\ud83d\udc64 Profile Agent(TEE)\")]\n    end\n\n    subgraph AgentDiscovery[\"Agent Discovery\"]\n        Registry[\"\ud83d\udcda Registry\"]\n        FlightAgent[\"\u2708\ufe0f Flight SearchAgent\"]\n        HotelAgent[\"\ud83c\udfe8 Hotel SearchAgent\"]\n        BookingAgent{\"\ud83d\udd10 Booking Agent(Auth Required)\"}\n    end\n\n    User --&gt; Orchestrator\n    Orchestrator --&gt; User\n\n    Orchestrator &lt;--&gt; ProfileAgent\n\n    Orchestrator &lt;--&gt; Registry\n    Orchestrator &lt;--&gt; FlightAgent\n    Orchestrator &lt;--&gt; HotelAgent\n    Orchestrator &lt;--&gt; BookingAgent\n\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style ProfileAgent fill:#ea80fc,stroke:#e040fb,color:black\n    style FlightAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style HotelAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style BookingAgent fill:#84ffff,stroke:#18ffff,color:black\n    style User fill:#fff59d,stroke:#ffee58,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Discovery: Dynamically finds specialized travel agents.</li> <li>Interoperability: Standard A2A ensures communication between diverse agents.</li> <li>Security: Manages authentication for profile access and booking actions via KeyManager &amp; Auth Schemes. TEE declaration enhances trust.</li> </ul>"},{"location":"use_cases/#scenario-2-automated-scientific-discovery-pipeline","title":"Scenario 2: Automated Scientific Discovery Pipeline","text":"<p>Goal: Accelerate research by automating the process of finding relevant studies, extracting key data, running complex simulations (potentially on secure hardware), analyzing results, and drafting reports.</p> <p>Workflow:</p> <ol> <li>Setup: Researcher configures a Pipeline Orchestrator Agent.</li> <li>Literature Search: Orchestrator discovers (<code>Registry</code>) and tasks (<code>A2A</code>) <code>PubMedSearchAgent</code> / <code>ArXivSearchAgent</code>.</li> <li>Information Extraction: Orchestrator tasks <code>PDFDataExtractionAgent</code> with URLs from search results. Agent returns structured data Artifacts.</li> <li>Simulation: Orchestrator discovers <code>ProteinFoldingSimAgent</code> (declaring TEE support) via Registry. Tasks agent via A2A with input data artifacts.</li> <li>Analysis: Orchestrator tasks <code>BioStatAnalysisAgent</code> with simulation result artifacts.</li> <li>Report Generation: Orchestrator sends components to <code>DraftWriterAgent</code>.</li> </ol> <p>Diagram:</p> <pre><code>flowchart LR\n    Researcher((\"\ud83d\udc69\u200d\ud83d\udd2c Researcher\"))\n    Orchestrator[/\"\ud83e\udde0 PipelineOrchestrator\"/]\n    Registry((\"\ud83d\udcda Registry\"))\n\n    subgraph Research[\"Research &amp; Analysis Pipeline\"]\n        direction TB\n        SearchAgent[\"\ud83d\udd0e LiteratureSearch Agent\"]\n        Extractor[\"\ud83d\udcc4 PDF ExtractAgent\"]\n        Simulator[\"\u2699\ufe0f SimulationAgent (TEE)\"]\n        Analyzer[\"\ud83d\udcca AnalysisAgent\"]\n        Writer[\"\ud83d\udcdd Draft WriterAgent\"]\n    end\n\n    Researcher &lt;--&gt; Orchestrator\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; SearchAgent\n    Orchestrator &lt;--&gt; Extractor\n    Orchestrator &lt;--&gt; Simulator\n    Orchestrator &lt;--&gt; Analyzer\n    Orchestrator &lt;--&gt; Writer\n\n    style Researcher fill:#fff59d,stroke:#ffee58,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style SearchAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Extractor fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Simulator fill:#ea80fc,stroke:#e040fb,color:black\n    style Analyzer fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Writer fill:#b9f6ca,stroke:#69f0ae,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Discovery: Finds specialized scientific agents, including filtering by TEE capability.</li> <li>Interoperability: Standard A2A allows complex pipeline construction.</li> <li>Artifacts: Enables exchange of large/complex data (simulation inputs/outputs).</li> <li>TEE Declaration: Allows secure compute agents to advertise their status.</li> </ul>"},{"location":"use_cases/#scenario-3-decentralized-smart-factory-monitoring-control","title":"Scenario 3: Decentralized Smart Factory Monitoring &amp; Control","text":"<p>Goal: Monitor and control factory floor equipment from various vendors in a resilient way, reducing reliance on a single central cloud and enabling faster local responses.</p> <p>Workflow:</p> <ol> <li>Local Deployment: Device Agents (wrapping sensors/actuators) register with a local AgentVault Registry.</li> <li>Monitoring: A local Monitoring Agent discovers Device Agents via Registry and subscribes to data streams (<code>tasks/sendSubscribe</code> via SSE).</li> <li>Alerting: Monitoring Agent detects an anomaly, finds an <code>AlertingAgent</code> via Registry, and sends an alert message via A2A.</li> <li>Response: Alerting Agent notifies humans and tasks a <code>ControlAgent</code> (or specific Device Agent) via A2A using required Auth Scheme (e.g., <code>apiKey</code>) managed by <code>KeyManager</code>.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph FactoryFloor[\"Factory Floor Edge\"]\n        SensorAgent[(\"\ud83c\udf21\ufe0f TemperatureSensor Agent\")]\n        ActuatorAgent{\"\ud83d\udd27 Valve Actuator(Auth Required)\"}\n        MachineAgent[(\"\u2699\ufe0f Machine StatusAgent\")]\n    end\n\n    subgraph ControlNetwork[\"Local Control Network\"]\n        LocalRegistry[(\"\ud83d\udcda Local Registry\")]\n        MonitorAgent[/\"\ud83d\udc41\ufe0f MonitoringAgent\"/]\n        AlertAgent[/\"\ud83d\udea8 AlertingAgent\"/]\n        ControlAgent[/\"\ud83c\udfae ControlAgent\"/]\n        Supervisor((\"\ud83d\udc68\u200d\ud83d\udcbc HumanSupervisor\"))\n    end\n\n    %% Registration connections\n    SensorAgent --&gt; LocalRegistry\n    ActuatorAgent --&gt; LocalRegistry\n    MachineAgent --&gt; LocalRegistry\n    AlertAgent --&gt; LocalRegistry\n    ControlAgent --&gt; LocalRegistry\n\n    %% Monitoring flow\n    MonitorAgent --&gt; LocalRegistry\n    SensorAgent --&gt; MonitorAgent\n    MachineAgent --&gt; MonitorAgent\n\n    %% Alert flow\n    MonitorAgent --&gt; AlertAgent\n    AlertAgent --&gt; Supervisor\n    AlertAgent --&gt; ControlAgent\n    ControlAgent --&gt; ActuatorAgent\n\n    style SensorAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ActuatorAgent fill:#84ffff,stroke:#18ffff,color:black\n    style MachineAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style LocalRegistry fill:#80d8ff,stroke:#40c4ff,color:black\n    style MonitorAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style AlertAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style ControlAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style Supervisor fill:#fff59d,stroke:#ffee58,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Decentralization: Enables local discovery and communication via a local Registry.</li> <li>Interoperability: Standard A2A connects heterogeneous devices/agents.</li> <li>Real-time Data: SSE facilitates efficient monitoring streams.</li> <li>Security: Secures control commands locally via Auth Schemes &amp; KeyManager.</li> </ul>"},{"location":"use_cases/#scenario-4-automated-crm-lead-enrichment","title":"Scenario 4: Automated CRM Lead Enrichment","text":"<p>Goal: Automatically enrich new CRM leads with verified external data (LinkedIn, company info, contact validation) to accelerate sales qualification and improve data quality.</p> <p>Workflow:</p> <ol> <li>Trigger: A new lead is created in the CRM.</li> <li>Orchestration: A CRM Orchestrator Agent is triggered.</li> <li>Discovery: Orchestrator queries the AgentVault Registry for agents tagged <code>enrichment</code>, <code>linkedin</code>, <code>firmographics</code>, <code>validation</code>.</li> <li>Task Delegation (A2A): Orchestrator tasks the discovered agents (<code>LinkedIn Enricher</code>, <code>Firmographics Agent</code>, <code>Contact Validator</code>) via A2A, using appropriate authentication (API Keys via <code>KeyManager</code>) for premium data sources.</li> <li>Data Aggregation: Orchestrator receives structured results (profile URLs, company size, email validity) potentially as Artifacts or direct results.</li> <li>CRM Update: Orchestrator updates the lead record in the CRM with the enriched data.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph CRMSystem[\"CRM System\"]\n        User((\"\ud83d\udc69\u200d\ud83d\udcbc Sales Rep\"))\n        CRM[(\"\ud83d\udcca CRM Platform\")]\n        Trigger[/\"\ud83d\udd14 Webhook/Trigger\"/]\n    end\n\n    subgraph AgentNetwork[\"Agent Network\"]\n        Orchestrator[/\"\ud83e\udde0 CRM OrchestratorAgent\"/]\n        Registry[\"\ud83d\udcda Registry\"]\n\n        subgraph EnrichmentServices[\"Enrichment Services\"]\n            direction LR\n            LinkedInAgent{\"\ud83d\udd17 LinkedIn Enricher(Auth Required)\"}\n            FirmographicsAgent{\"\ud83c\udfe2 Firmographics(Auth Required)\"}\n            ValidatorAgent[\"\u2713 ContactValidator\"]\n        end\n    end\n\n    User --&gt; CRM\n    CRM --&gt; Trigger\n    Trigger --&gt; Orchestrator\n\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; LinkedInAgent\n    Orchestrator &lt;--&gt; FirmographicsAgent\n    Orchestrator &lt;--&gt; ValidatorAgent\n\n    Orchestrator --&gt; CRM\n\n    style User fill:#fff59d,stroke:#ffee58,color:black\n    style CRM fill:#bbdefb,stroke:#64b5f6,color:black\n    style Trigger fill:#ffcc80,stroke:#ffa726,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style LinkedInAgent fill:#84ffff,stroke:#18ffff,color:black\n    style FirmographicsAgent fill:#84ffff,stroke:#18ffff,color:black\n    style ValidatorAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Modularity: Easily find and swap enrichment agents via the Registry.</li> <li>Standardization: A2A protocol simplifies interaction with diverse data providers.</li> <li>Security: KeyManager handles API keys for premium enrichment services securely.</li> <li>Automation: Reduces manual data entry and improves lead quality efficiently.</li> </ul>"},{"location":"use_cases/#scenario-5-automated-order-processing-fulfillment-erp-integration","title":"Scenario 5: Automated Order Processing &amp; Fulfillment (ERP Integration)","text":"<p>Goal: Streamline order fulfillment by automating inventory checks, shipping label generation, billing updates, and CRM notifications when a new order is placed.</p> <p>Workflow:</p> <ol> <li>Trigger: New order received in E-commerce Platform.</li> <li>Orchestration: Order Processing Agent is triggered.</li> <li>Inventory Check (A2A): Orchestrator tasks <code>Inventory Agent</code> (connected to ERP/WMS) via A2A.</li> <li>Shipping Label (A2A + Auth): If stock confirmed, Orchestrator discovers (<code>Registry</code>) and tasks <code>Shipping Label Agent</code> (e.g., ShipStation, EasyPost wrapper) using required API Key (<code>KeyManager</code>). Agent returns label data Artifact.</li> <li>Billing (A2A): Orchestrator tasks <code>Billing Agent</code> to generate invoice in ERP/Accounting system.</li> <li>CRM Update (A2A): Orchestrator tasks <code>CRM Update Agent</code> to log order status against customer record.</li> <li>Notification: Orchestrator notifies E-commerce platform/user of completion.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TB\n    Ecommerce[(\"\ud83d\udecd\ufe0f E-commercePlatform\")] --&gt; OrderAgent[/\"\ud83d\udce6 Order ProcessingAgent\"/]\n\n    subgraph Systems[\"Enterprise Systems\"]\n        ERP[(\"\ud83d\udcbb ERP / WMS\")]\n        ShippingAPI[(\"\ud83d\ude9a Shipping API\")]\n        CRM[(\"\ud83d\udc65 CRM System\")]\n    end\n\n    subgraph AgentNetwork[\"Agent Network\"]\n        Registry[(\"\ud83d\udcda Registry\")]\n        InventoryAgent[\"\ud83d\udd22 InventoryAgent\"]\n        ShippingAgent{\"\ud83c\udff7\ufe0f Shipping Label(Auth Required)\"}\n        BillingAgent[\"\ud83d\udcb0 BillingAgent\"]\n        CRMUpdateAgent[\"\ud83d\udcdd CRM UpdateAgent\"]\n    end\n\n    OrderAgent &lt;--&gt; Registry\n\n    OrderAgent &lt;--&gt; InventoryAgent\n    InventoryAgent &lt;--&gt; ERP\n\n    OrderAgent &lt;--&gt; ShippingAgent\n    ShippingAgent &lt;--&gt; ShippingAPI\n\n    OrderAgent &lt;--&gt; BillingAgent\n    BillingAgent &lt;--&gt; ERP\n\n    OrderAgent &lt;--&gt; CRMUpdateAgent\n    CRMUpdateAgent &lt;--&gt; CRM\n\n    OrderAgent --&gt; Ecommerce\n\n    style Ecommerce fill:#bbdefb,stroke:#64b5f6,color:black\n    style OrderAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style InventoryAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ShippingAgent fill:#84ffff,stroke:#18ffff,color:black\n    style BillingAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style CRMUpdateAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ERP fill:#bbdefb,stroke:#64b5f6,color:black\n    style ShippingAPI fill:#bbdefb,stroke:#64b5f6,color:black\n    style CRM fill:#bbdefb,stroke:#64b5f6,color:black</code></pre> <p>AgentVault Value:</p> <ul> <li>Process Automation: Connects disparate systems (E-commerce, ERP, Shipping, CRM) via standardized agents.</li> <li>Interoperability: A2A allows communication between custom internal agents (Inventory, Billing) and external service wrappers (Shipping).</li> <li>Security: Securely manages API keys for external services like shipping providers.</li> <li>Flexibility: Easily replace the Shipping Label Agent if switching providers, without changing the Orchestrator significantly.</li> </ul>"},{"location":"use_cases/#scenario-6-intelligent-customer-support-ticket-routing","title":"Scenario 6: Intelligent Customer Support Ticket Routing","text":"<p>Goal: Improve customer support efficiency by automatically analyzing incoming tickets, enriching them with context, and routing them to the best-suited queue or agent, potentially providing automated answers for common issues.</p> <p>Workflow:</p> <ol> <li>Trigger: New support ticket created in Helpdesk System.</li> <li>Orchestration: Support Orchestrator Agent is triggered.</li> <li>Initial Analysis (A2A): Orchestrator tasks <code>SentimentAnalysisAgent</code> and <code>TopicClassificationAgent</code> via A2A.</li> <li>Context Enrichment (Discovery &amp; A2A): Orchestrator discovers (<code>Registry</code>) and tasks <code>CRMLookupAgent</code> (using auth via <code>KeyManager</code>) to fetch customer history/details based on ticket submitter's email.</li> <li>Knowledge Base Check (A2A): Orchestrator tasks <code>KnowledgeBaseSearchAgent</code> with classified topic and ticket content.</li> <li>Decision &amp; Routing:<ul> <li>If KB Agent finds a high-confidence answer, Orchestrator sends automated reply via <code>HelpdeskUpdateAgent</code>.</li> <li>If no KB match, Orchestrator uses sentiment, topic, and customer context to task <code>RoutingAgent</code> to assign the ticket to the appropriate human support queue (e.g., Tier 1, Billing, Technical) via <code>HelpdeskUpdateAgent</code>.</li> </ul> </li> </ol> <p>Diagram:</p> <pre><code>flowchart LR\n    User((\"\ud83d\udc64 User\")) --&gt; Helpdesk[(\"\ud83c\udfab HelpdeskSystem\")]\n    Helpdesk --&gt; Orchestrator[/\"\ud83e\udde0 SupportOrchestrator\"/]\n\n    subgraph AgentNetwork[\"Agent Ecosystem\"]\n        Registry[\"\ud83d\udcda Registry\"]\n\n        subgraph Analysis[\"Analysis Agents\"]\n            direction TB\n            SentimentAgent[\"\ud83d\ude0a SentimentAnalysis\"]\n            TopicAgent[\"\ud83c\udff7\ufe0f TopicClassification\"]\n            CRMAgent{\"\ud83d\udc65 CRM Lookup(Auth Required)\"}\n        end\n\n        subgraph Resolution[\"Resolution Path\"]\n            direction TB\n            KBAgent[\"\ud83d\udcda Knowledge BaseAgent\"]\n            RoutingAgent[\"\ud83d\udd00 Routing LogicAgent\"]\n            HelpdeskUpdateAgent{\"\u270f\ufe0f Helpdesk Update(Auth Required)\"}\n        end\n    end\n\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; SentimentAgent\n    Orchestrator &lt;--&gt; TopicAgent\n    Orchestrator &lt;--&gt; CRMAgent\n\n    Orchestrator &lt;--&gt; KBAgent\n    Orchestrator &lt;--&gt; RoutingAgent\n    Orchestrator &lt;--&gt; HelpdeskUpdateAgent\n\n    HelpdeskUpdateAgent --&gt; Helpdesk\n\n    style User fill:#fff59d,stroke:#ffee58,color:black\n    style Helpdesk fill:#bbdefb,stroke:#64b5f6,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style SentimentAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style TopicAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style CRMAgent fill:#84ffff,stroke:#18ffff,color:black\n    style KBAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style RoutingAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style HelpdeskUpdateAgent fill:#84ffff,stroke:#18ffff,color:black</code></pre> <p>AgentVault Value:</p> <ul> <li>Workflow Orchestration: Enables complex, multi-step support workflows involving analysis, enrichment, and action.</li> <li>Specialization: Allows using best-of-breed agents for sentiment, classification, KB search, etc.</li> <li>Secure Data Access: Protects access to CRM and Helpdesk systems via authenticated agents.</li> <li>Efficiency: Automates common tasks and routes complex issues effectively, reducing manual triage and resolution time.</li> </ul>"},{"location":"vision/","title":"The AgentVault Vision: Enabling the Collaborative AI Future","text":""},{"location":"vision/#the-fragmented-present-islands-of-intelligence","title":"The Fragmented Present: Islands of Intelligence","text":"<p>The era of Artificial Intelligence is rapidly evolving. We see powerful, specialized AI agents emerging daily, capable of remarkable feats in language, analysis, planning, and execution. Yet, despite their individual brilliance, these agents largely exist as isolated islands of intelligence.</p> <p>Integrating them into complex workflows often requires bespoke, brittle connections. Communicating context and ensuring security between agents from different providers or built with different tools is a significant challenge. Key problems hinder the realization of truly collaborative AI:</p> <ul> <li>Discovery: How can agents dynamically find other agents with the specific capabilities they need?</li> <li>Interoperability: How can agents built by different teams, using different models or platforms, communicate reliably and understand each other?</li> <li>Security &amp; Trust: How can we ensure that interactions between agents are secure, that credentials aren't exposed, and that agents operate within expected boundaries, potentially within verifiable Trusted Execution Environments (TEEs)?</li> <li>Context Management: How can agents efficiently share the necessary context (user goals, history, data references) to perform collaborative tasks without exceeding limitations or losing vital information?</li> <li>Developer Experience: How can we make it easier for developers to build agents that can collaborate, without getting bogged down in complex protocol implementations and security hurdles?</li> </ul> <p>Without addressing these foundational issues, the true potential of multi-agent systems \u2013 where specialized AIs work together to solve problems beyond the scope of any single agent \u2013 remains largely untapped.</p>"},{"location":"vision/#the-agentvault-solution-a-foundation-for-collaboration","title":"The AgentVault Solution: A Foundation for Collaboration","text":"<p>AgentVault is an open-source ecosystem designed to be the bedrock for this collaborative future. We are building the essential infrastructure and standards to tear down the silos and connect the islands of intelligence.</p> <p>AgentVault provides a cohesive set of tools and specifications addressing the core challenges:</p> <ol> <li>Discovery (<code>agentvault_registry</code>): A central, queryable registry where developers can publish standardized \"Agent Cards\". This allows clients (users or other agents) to easily find agents based on name, description, capabilities, tags, TEE support, and other metadata.</li> <li>Standardized Communication (<code>A2A Profile</code>): A defined Agent-to-Agent (A2A) communication protocol based on JSON-RPC 2.0 and Server-Sent Events (SSE). This ensures that agents, regardless of their underlying implementation, can reliably exchange messages, manage task lifecycles (initiate, get status, cancel), and receive real-time updates using a common language.</li> <li>Secure Interaction (<code>KeyManager</code>, Auth Schemes): Robust mechanisms for authenticating agents using various schemes (API Keys, OAuth2 Client Credentials) coupled with secure local credential management (<code>KeyManager</code>) on the client-side and best practices (hashed keys, HTTPS enforcement) throughout the ecosystem.</li> <li>Developer Enablement (<code>SDK</code>, <code>Library</code>, <code>CLI</code>): Practical tools to simplify the process:<ul> <li><code>agentvault-server-sdk</code>: Makes building A2A-compliant agents easier, handling protocol boilerplate and integrating with frameworks like FastAPI.</li> <li><code>agentvault</code> (Library): Provides a Python client for programmatically interacting with agents and the registry.</li> <li><code>agentvault-cli</code>: Offers a user-friendly command-line interface for discovery, interaction, and credential management.</li> </ul> </li> </ol> <p>By focusing on open standards, security, and developer experience, AgentVault aims to provide the essential, non-proprietary plumbing for the multi-agent world.</p>"},{"location":"vision/#the-vision-an-interconnected-ai-ecosystem","title":"The Vision: An Interconnected AI Ecosystem","text":"<p>We envision a future powered by AgentVault where seamless, secure collaboration between diverse AI agents unlocks unprecedented capabilities. This foundation enables complex workflows previously difficult or impossible to achieve:</p> <ul> <li>Imagine hyper-personalized assistants securely coordinating specialized travel, scheduling, and profile agents to manage your life proactively.</li> <li>Picture automated scientific discovery pipelines where research agents seamlessly link literature review, data extraction, secure simulation (potentially in TEEs), and analysis agents.</li> <li>Envisage resilient smart factories where local device agents communicate directly for monitoring and control, reducing reliance on single cloud platforms.</li> </ul> <p>These are just glimpses of the potential. By providing the common rails for discovery, communication, and security, AgentVault fosters an environment where specialized agents can be combined like building blocks, leading to emergent solutions and accelerating innovation across domains.</p> <p>\u27a1\ufe0f See Detailed Use Cases &amp; Scenarios to explore these possibilities in more depth.</p>"},{"location":"vision/#core-principles","title":"Core Principles","text":"<p>Our vision is guided by these fundamental principles:</p> <ul> <li>Open Source: All core components and specifications are developed under the permissive Apache 2.0 license, ensuring transparency, community involvement, and freedom from vendor lock-in.</li> <li>Security-First: Security is not an afterthought. From secure credential management and mandatory HTTPS (for non-localhost) to TEE awareness and robust authentication handling, building a trustworthy ecosystem is paramount.</li> <li>Interoperability: Adherence to open standards (JSON-RPC, SSE, emerging A2A concepts) and well-defined schemas (<code>AgentCard</code>) ensures that agents built by different teams using different technologies can communicate effectively.</li> <li>Decentralization: While the registry provides discovery, agent execution remains decentralized. AgentVault does not dictate where or how agents are hosted, promoting flexibility and resilience.</li> <li>Developer Focus: Providing practical SDKs, libraries, clear documentation, and examples lowers the barrier for developers to build and integrate A2A-compliant agents.</li> </ul>"},{"location":"vision/#why-agentvault","title":"Why AgentVault?","text":"<p>AgentVault differentiates itself by providing a holistic, secure, and open foundation specifically designed for the challenges of A2A interaction. We combine:</p> <ul> <li>Standardized Discovery: A dedicated registry with a defined schema.</li> <li>Secure Communication: A clear A2A protocol profile with built-in support for standard authentication methods.</li> <li>Practical Tooling: SDKs, libraries, and CLI tools designed to work together seamlessly.</li> <li>Security Emphasis: Integrated secure key management and TEE awareness from the outset.</li> </ul>"},{"location":"vision/#join-the-vision","title":"Join the Vision","text":"<p>Building the future of collaborative AI requires a community effort. Whether you are developing agents, building applications that use agents, or are interested in the underlying protocols and security, we invite you to:</p> <ul> <li>Use AgentVault: Build your agents using the Server SDK, interact with agents using the Client Library and CLI.</li> <li>Register Your Agents: Make your agents discoverable by submitting them to the public registry (or run your own!).</li> <li>Contribute: Help improve the code, documentation, and examples. Report issues, suggest features, and submit pull requests. See our Contributing Guide.</li> <li>Engage: Join the discussions on our GitHub Repository.</li> </ul> <p>Let's build the interconnected AI ecosystem, together.</p>"},{"location":"architecture/a2a_protocol/","title":"AgentVault A2A Protocol Profile v0.2","text":"<p>This document specifies the Agent-to-Agent (A2A) communication profile implemented by AgentVault components (as of v1.0.0 of the libraries/SDK). It defines how clients interact with A2A-compliant agent servers, aligning with concepts from emerging A2A standards like Google's A2A protocol.</p> <p>This document corresponds to the implementation in <code>agentvault</code> v0.2.x library and <code>agentvault-server-sdk</code> v0.1.x.</p>"},{"location":"architecture/a2a_protocol/#overview","title":"Overview","text":"<ul> <li>Protocol: JSON-RPC 2.0 Specification.</li> <li>Transport: HTTP/1.1 or HTTP/2. HTTPS is REQUIRED for all communication except potentially during local development targeting <code>localhost</code>.</li> <li>Request Method: <code>POST</code> for all JSON-RPC requests.</li> <li>Streaming: Server-Sent Events (SSE) via the <code>tasks/sendSubscribe</code> method for real-time updates.</li> <li>Data Format: JSON (UTF-8 encoding).</li> <li>Authentication: Defined via <code>authSchemes</code> in the Agent Card. Supported schemes include <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials Grant). See Authentication section below.</li> <li>Models: Data structures (AgentCard, Task, Message, etc.) are defined using Pydantic in the <code>agentvault.models</code> module of the core library.</li> </ul>"},{"location":"architecture/a2a_protocol/#transport-details","title":"Transport Details","text":"<p>All JSON-RPC requests MUST be sent using the HTTP <code>POST</code> method to the agent's designated A2A endpoint URL (found in the <code>url</code> field of its Agent Card).</p> <ul> <li>Request Headers:<ul> <li><code>Content-Type: application/json</code> is REQUIRED.</li> <li><code>Accept: application/json</code> is RECOMMENDED for non-streaming requests.</li> <li><code>Accept: text/event-stream</code> is REQUIRED for <code>tasks/sendSubscribe</code> requests.</li> <li>Authentication headers (e.g., <code>X-Api-Key</code> or <code>Authorization: Bearer &lt;token&gt;</code>) MUST be included if required by the agent's <code>authSchemes</code>.</li> </ul> </li> <li>Request Body: Contains the standard JSON-RPC 2.0 request object.</li> <li>Response Body (Non-Streaming): Contains the standard JSON-RPC 2.0 response object (either <code>result</code> or <code>error</code>). The HTTP status code SHOULD be <code>200 OK</code> even for JSON-RPC errors, as per JSON-RPC spec recommendations.</li> <li>Response Body (Streaming via <code>tasks/sendSubscribe</code>): The server responds with HTTP <code>200 OK</code> and <code>Content-Type: text/event-stream</code>. The HTTP response body then contains the SSE stream.</li> </ul>"},{"location":"architecture/a2a_protocol/#authentication","title":"Authentication","text":"<p>Agents declare their supported authentication methods in the <code>authSchemes</code> list within their Agent Card. The <code>agentvault</code> client library (<code>AgentVaultClient</code> using <code>KeyManager</code>) handles these schemes automatically:</p> <ul> <li><code>none</code>: No authentication headers are sent. Suitable only for public, non-sensitive agents.</li> <li><code>apiKey</code>:<ul> <li>Client retrieves the API key associated with the <code>service_identifier</code> (from the Agent Card or user override) using <code>KeyManager</code>.</li> <li>Client sends the key in the <code>X-Api-Key</code> HTTP header.</li> <li>Server MUST validate the received key against its secure storage.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant Flow):<ul> <li>Requires the <code>AgentAuthentication</code> object in the card to include <code>tokenUrl</code>. <code>scopes</code> are optional.</li> <li>Client retrieves its own Client ID and Secret associated with the <code>service_identifier</code> using <code>KeyManager</code>.</li> <li>Client POSTs <code>grant_type=client_credentials</code>, <code>client_id</code>, <code>client_secret</code> (and optionally <code>scope</code>) to the agent's <code>tokenUrl</code>.</li> <li>Agent's token endpoint validates credentials and returns a JSON response with <code>access_token</code> (required), <code>token_type</code> (must be \"Bearer\", case-insensitive check), and optionally <code>expires_in</code>.</li> <li>Client sends the received <code>access_token</code> in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent A2A requests to the agent's main <code>url</code>.</li> <li>The <code>AgentVaultClient</code> automatically handles token fetching and caching (respecting <code>expires_in</code> if provided).</li> <li>Server's main A2A endpoint MUST validate the Bearer token (signature, expiry, audience, scopes if applicable).</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Client assumes the user/application has already obtained a valid Bearer token through other means (e.g., user login flow separate from AgentVault).</li> <li>Client sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>The <code>agentvault</code> library currently requires explicit configuration or extension to handle this scheme, as it doesn't manage the token lifecycle.</li> <li>Server MUST validate the received Bearer token.</li> </ul> </li> </ul> <p>Refer to the main Security Concepts document for more details.</p>"},{"location":"architecture/a2a_protocol/#json-rpc-20-structure","title":"JSON-RPC 2.0 Structure","text":"<p>All requests and responses adhere to the JSON-RPC 2.0 specification.</p> <p>Request Object:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"method_name\",\n  \"params\": &lt;parameters_object_or_array&gt;,\n  \"id\": &lt;request_id_string_or_number_or_null&gt;\n}\n</code></pre> <ul> <li><code>jsonrpc</code>: MUST be exactly \"2.0\".</li> <li><code>method</code>: A string containing the name of the method (e.g., \"tasks/send\").</li> <li><code>params</code>: An optional structured value (object or array). AgentVault methods use parameter objects (dictionaries).</li> <li><code>id</code>: An identifier established by the Client. If included, the response MUST include the same value. If omitted (notification), the server MUST NOT reply. AgentVault methods generally expect an ID.</li> </ul> <p>Response Object (Success):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": &lt;result_value&gt;,\n  \"id\": &lt;matching_request_id&gt;\n}\n</code></pre> <ul> <li><code>result</code>: The value returned by the method invocation. Its structure depends on the method called (see method definitions below).</li> <li><code>id</code>: Must match the <code>id</code> from the Request Object.</li> </ul> <p>Response Object (Error):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": &lt;integer&gt;,\n    \"message\": &lt;string&gt;,\n    \"data\": &lt;optional_any&gt;\n  },\n  \"id\": &lt;matching_request_id_or_null&gt;\n}\n</code></pre> <ul> <li><code>error</code>: An object describing the error.<ul> <li><code>code</code>: A Number indicating the error type. See Error Codes.</li> <li><code>message</code>: A String providing a short description of the error.</li> <li><code>data</code>: Optional. A Primitive or Structured value containing additional information.</li> </ul> </li> <li><code>id</code>: Must match the <code>id</code> from the Request Object. If the error occurred before the ID could be determined (e.g., Parse Error), it SHOULD be <code>null</code>.</li> </ul>"},{"location":"architecture/a2a_protocol/#standard-a2a-methods","title":"Standard A2A Methods","text":"<p>These methods form the core of the AgentVault A2A interaction model, implemented by the <code>agentvault</code> client library and expected by servers built with the <code>agentvault-server-sdk</code>.</p>"},{"location":"architecture/a2a_protocol/#taskssend","title":"<code>tasks/send</code>","text":"<p>Initiates a new task or sends a subsequent message to an existing task.</p> <ul> <li>Params: <code>TaskSendParams</code> object (<code>agentvault.models.TaskSendParams</code>)<ul> <li><code>id</code> (Optional[str]): Task ID if continuing an existing task. Omit or null if initiating a new task.</li> <li><code>message</code> (Message): The message object (<code>agentvault.models.Message</code>) to send.</li> <li>(Optional) <code>webhookUrl</code> (Optional[str]): URL for agent push notifications (if agent supports <code>supportsPushNotifications</code>). Client is responsible for handling POST requests to this URL from the agent. (Note: Push notification handling is not fully implemented in client/SDK v1.0.0).</li> </ul> </li> <li>Result: <code>TaskSendResult</code> object (<code>agentvault.models.TaskSendResult</code>)<ul> <li><code>id</code> (str): The ID of the task (newly created or existing).</li> </ul> </li> <li>Example Request (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}],\n      \"metadata\": {\n        \"mcp_context\": { \"user_pref\": \"celsius\" }\n      }\n    }\n    {# Example including optional webhook: #}\n    {# \"webhookUrl\": \"https://my-client.example.com/webhook/task-updates\" #}\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Response (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Request (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-abc-123\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What about tomorrow?\"}]\n    }\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> <li>Example Response (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> </ul>"},{"location":"architecture/a2a_protocol/#tasksget","title":"<code>tasks/get</code>","text":"<p>Retrieve the current status and details of a specific task.</p> <ul> <li>Params: <code>TaskGetParams</code> object (<code>agentvault.models.TaskGetParams</code>)<ul> <li><code>id</code> (str): The ID of the task to retrieve.</li> </ul> </li> <li>Result: <code>Task</code> object (<code>agentvault.models.Task</code>) representing the full task state.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/get\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-3\"\n}\n```*   **Example Response:**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\",\n    \"state\": \"WORKING\",\n    \"createdAt\": \"2024-04-15T10:00:00Z\",\n    \"updatedAt\": \"2024-04-15T10:05:30Z\",\n    \"messages\": [\n      {\"role\": \"user\", \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}], \"metadata\": null},\n      {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Fetching weather...\"}], \"metadata\": null}\n    ],\n    \"artifacts\": [\n      {\"id\": \"artifact-1\", \"type\": \"log\", \"content\": \"API call made\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}\n    ],\n    \"metadata\": null\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> </ul>"},{"location":"architecture/a2a_protocol/#taskscancel","title":"<code>tasks/cancel</code>","text":"<p>Request the cancellation of an ongoing task.</p> <ul> <li>Params: <code>TaskCancelParams</code> object (<code>agentvault.models.TaskCancelParams</code>)<ul> <li><code>id</code> (str): The ID of the task to cancel.</li> </ul> </li> <li>Result: <code>TaskCancelResult</code> object (<code>agentvault.models.TaskCancelResult</code>)<ul> <li><code>success</code> (bool): Indicates if the cancellation request was accepted by the agent (doesn't guarantee immediate cancellation).</li> <li><code>message</code> (Optional[str]): Optional message from the agent regarding the cancellation request.</li> </ul> </li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/cancel\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"success\": true,\n    \"message\": \"Cancellation request received.\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> </ul>"},{"location":"architecture/a2a_protocol/#taskssendsubscribe","title":"<code>tasks/sendSubscribe</code>","text":"<p>Initiates a subscription to real-time updates for a task via Server-Sent Events (SSE).</p> <ul> <li>Params: Object containing the task ID.<ul> <li><code>id</code> (str): The ID of the task to subscribe to.</li> </ul> </li> <li>Response: HTTP <code>200 OK</code> with <code>Content-Type: text/event-stream</code>. The HTTP response body contains the SSE stream. No JSON-RPC <code>result</code> field is sent in the initial HTTP response body.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-5\"\n}\n</code></pre></li> <li>Example Response (HTTP Headers &amp; Body Start): <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\n... (more events) ...\n</code></pre></li> </ul>"},{"location":"architecture/a2a_protocol/#task-states-taskstate-enum","title":"Task States (<code>TaskState</code> Enum)","text":"<p>The defined states for an A2A task lifecycle (<code>agentvault.models.TaskState</code>):</p> <ul> <li><code>SUBMITTED</code>: Task received, awaiting execution.</li> <li><code>WORKING</code>: Task actively being processed.</li> <li><code>INPUT_REQUIRED</code>: Task paused, awaiting further client input (advanced use case).</li> <li><code>COMPLETED</code>: Task finished successfully. (Terminal)</li> <li><code>FAILED</code>: Task terminated due to an error. (Terminal)</li> <li><code>CANCELED</code>: Task canceled by request. (Terminal)</li> </ul>"},{"location":"architecture/a2a_protocol/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Used for the <code>tasks/sendSubscribe</code> stream.</p> <ul> <li>Format: Standard SSE. Each event consists of <code>event:</code> and <code>data:</code> lines, terminated by <code>\\n\\n</code>. The <code>data:</code> field contains a single line JSON string representing the corresponding event payload.     <pre><code>event: &lt;event_type&gt;\ndata: &lt;json_payload_string&gt;\n\nevent: &lt;another_event_type&gt;\ndata: &lt;another_json_payload_string&gt;\n</code></pre></li> <li>Event Types (<code>event:</code> field):<ul> <li><code>task_status</code>: Task state change. <code>data</code> is JSON of <code>TaskStatusUpdateEvent</code>.</li> <li><code>task_message</code>: New message added. <code>data</code> is JSON of <code>TaskMessageEvent</code>.</li> <li><code>task_artifact</code>: Artifact created/updated. <code>data</code> is JSON of <code>TaskArtifactUpdateEvent</code>.</li> <li><code>error</code>: Server-side error during streaming. <code>data</code> is a JSON object like <code>{\"error\": \"code\", \"message\": \"desc\"}</code>.</li> </ul> </li> <li>Data Payload (<code>data:</code> field): A JSON string representing the corresponding event model (<code>agentvault.models.TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>). The client library validates these payloads against the Pydantic models.</li> </ul> <p>Example SSE Stream:</p> <pre><code>event: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\nevent: task_artifact\ndata: {\"taskId\": \"task-abc-123\", \"artifact\": {\"id\": \"log-1\", \"type\": \"debug_log\", \"content\": \"Processing step 1\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:10Z\"}\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"COMPLETED\", \"timestamp\": \"2024-04-15T10:05:15Z\", \"message\": \"Task finished successfully.\"}\n</code></pre>"},{"location":"architecture/a2a_protocol/#json-rpc-error-codes","title":"JSON-RPC Error Codes","text":"<p>Standard JSON-RPC codes MUST be used where applicable. AgentVault defines application-specific codes in the <code>-32000</code> to <code>-32099</code> range for agent-level errors.</p> Code Message Meaning Standard/App -32700 Parse error Invalid JSON received by the server. Standard -32600 Invalid Request The JSON sent is not a valid Request object. Standard -32601 Method not found The method does not exist / is not available. Standard -32602 Invalid Params Invalid method parameter(s). Standard -32603 Internal error Internal JSON-RPC error on the server. Standard -32000 Agent Server Error Generic application error on the agent. Application -32001 Task Not Found Specified <code>task_id</code> does not exist. Application -32002 Authentication Error API Key / Token invalid or missing. Application -32003 Authorization Error Authenticated user cannot perform action. Application -32004 Invalid State Operation not allowed in current task state. Application others Implementation Defined Server may define other -320xx errors. Application <p>Servers SHOULD include meaningful information in the <code>message</code> and optionally the <code>data</code> part of the error object. The client library (<code>A2ARemoteAgentError</code>) makes this information accessible.</p>"},{"location":"architecture/mcp_support/","title":"AgentVault MCP Support (Proxy Pattern - v1.0.0)","text":"<p>Status: Defined &amp; Implemented via Proxy Pattern</p>"},{"location":"architecture/mcp_support/#1-introduction","title":"1. Introduction","text":"<p>The AgentVault Agent-to-Agent (A2A) protocol defines the core mechanisms for secure communication, task management, and event streaming between agents. However, many complex agent interactions require agents to execute external Tools (e.g., filesystem access, code execution, database queries, specialized APIs).</p> <p>The Model Context Protocol (MCP) is a conceptual protocol designed for agent-tool interaction, typically using JSON-RPC 2.0 over HTTP(S). While direct client-library support for invoking MCP tools may evolve, AgentVault v1.0.0 provides a robust and validated solution for integrating MCP tools via the A2A Proxy Pattern.</p> <p>Goal: To enable standardized, reusable, secure, and controlled access to external capabilities within AgentVault workflows without requiring the orchestrator or core agents to directly implement the MCP protocol.</p>"},{"location":"architecture/mcp_support/#2-the-a2a-proxy-pattern","title":"2. The A2A Proxy Pattern","text":"<p>The recommended and validated pattern in AgentVault v1.0.0 for integrating MCP tools involves a dedicated MCP Tool Proxy Agent:</p> <ul> <li>MCP Tool Proxy Agent: An A2A-compliant agent (built using the <code>agentvault-server-sdk</code>) acts as a secure bridge between the A2A domain and the MCP domain.</li> <li>MCP Tool Server: A separate service (potentially non-A2A compliant itself) that exposes specific tools (e.g., <code>filesystem.readFile</code>, <code>code.runPython</code>) via an MCP-compatible JSON-RPC 2.0 HTTP endpoint (typically <code>/rpc</code>).</li> <li>Orchestrator/Client: An A2A client (like the <code>agentvault-cli</code>, a LangGraph orchestrator, or a custom application using the <code>agentvault</code> library) that needs to invoke an MCP tool.</li> </ul> <p>Workflow:</p> <ol> <li>A2A Request to Proxy: The Orchestrator sends a standard A2A <code>tasks/send</code> request to the Proxy Agent's <code>/a2a</code> endpoint. The crucial information about the desired MCP call is embedded within a <code>DataPart</code> of the A2A <code>Message</code>.</li> <li>Proxy Authentication &amp; Routing: The Proxy Agent authenticates the Orchestrator using standard A2A mechanisms (API Key, OAuth2 via <code>KeyManager</code>). It then parses the <code>DataPart</code> to identify the target MCP server and tool.</li> <li>MCP Request from Proxy: The Proxy Agent looks up the target MCP Tool Server's URL (e.g., from its configuration) and sends a standard MCP JSON-RPC 2.0 request (e.g., <code>{\"method\": \"filesystem.readFile\", \"params\": {...}}</code>) via HTTP POST to the Tool Server's <code>/rpc</code> endpoint.</li> <li>MCP Tool Execution: The MCP Tool Server executes the requested tool.</li> <li>MCP Response to Proxy: The Tool Server sends a JSON-RPC 2.0 response back to the Proxy Agent (containing either a <code>result</code> or an <code>error</code>, potentially using the <code>isError: true</code> convention within the <code>result</code> for tool-level errors).</li> <li>A2A Response from Proxy: The Proxy Agent translates the MCP response into a standard A2A format (e.g., placing the MCP <code>result</code> or error details within a <code>DataPart</code> of an assistant <code>Message</code> or <code>Artifact</code>) and sends it back to the Orchestrator via the A2A task's SSE stream or final result.</li> </ol> <p>Diagram:</p> <p> (Diagram showing Orchestrator communicating via A2A (HTTPS+Auth) to the MCP Tool Proxy Agent. The Proxy Agent then communicates via MCP (HTTPS/JSON-RPC) to an MCP Tool Server, receiving a response, and relaying the outcome back to the Orchestrator via A2A.)</p>"},{"location":"architecture/mcp_support/#3-a2a-message-structure-client-proxy","title":"3. A2A Message Structure (Client -&gt; Proxy)","text":"<p>Instead of using <code>message.metadata[\"mcp_context\"]</code>, the client sends instructions to the proxy embedded within a <code>DataPart</code> inside the standard A2A <code>Message.parts</code> list.</p> <p>Required <code>DataPart.content</code> structure:</p> <pre><code>{\n  \"target_mcp_server_id\": \"filesystem\", // Logical ID mapped to URL in Proxy config\n  \"tool_name\": \"filesystem.readFile\",   // The MCP method to call\n  \"arguments\": {                        // Parameters for the MCP method\n    \"path\": \"/data/input.txt\"\n  }\n}\n</code></pre> <p>Example A2A Message sent by Orchestrator to Proxy Agent:</p> <pre><code>// This is the JSON-RPC 'params.message' field in the tasks/send request\n{\n  \"role\": \"user\", // Or 'system' / 'assistant' depending on orchestrator\n  \"parts\": [\n    {\n      \"type\": \"data\",\n      \"mediaType\": \"application/json\", // Recommended\n      \"content\": {\n        \"target_mcp_server_id\": \"code\",\n        \"tool_name\": \"code.runPython\",\n        \"arguments\": {\n          \"code\": \"print('Hello from proxied MCP call!')\"\n        }\n      }\n    }\n    // Optionally include a TextPart for human context if needed\n    // { \"type\": \"text\", \"content\": \"Execute the code specified in the data part.\"}\n  ],\n  \"metadata\": null // metadata[\"mcp_context\"] is NOT used for this pattern\n}\n</code></pre>"},{"location":"architecture/mcp_support/#4-client-side-usage-agentvault-library","title":"4. Client-Side Usage (<code>agentvault</code> Library)","text":"<p>To invoke an MCP tool via the proxy pattern using the client library:</p> <ol> <li>Load the Proxy Agent's <code>AgentCard</code>.</li> <li>Instantiate <code>KeyManager</code> for the Proxy Agent's authentication.</li> <li>Construct the A2A <code>Message</code> with the correct <code>DataPart</code> payload (as shown above).</li> <li>Use <code>AgentVaultClient.initiate_task</code> (or <code>send_message</code>) targeting the Proxy Agent.</li> <li>Process the A2A events/response received from the Proxy Agent, which will contain the translated result or error from the underlying MCP call.</li> </ol> <pre><code>import asyncio\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, DataPart,\n    agent_card_utils, models as av_models, exceptions as av_exceptions\n)\n\nasync def call_mcp_via_proxy(\n    proxy_agent_ref: str, # ID, URL, or file path for the *Proxy* Agent\n    target_mcp_server_id: str,\n    tool_name: str,\n    arguments: dict\n):\n    key_manager = KeyManager(use_keyring=True) # Assuming proxy might need auth\n    proxy_card = None\n    task_id = None\n\n    try:\n        # Load the PROXY agent's card\n        proxy_card = await agent_card_utils.fetch_agent_card_from_url(proxy_agent_ref) # Example load\n        if not proxy_card: raise ValueError(\"Proxy agent card not found\")\n\n        # Prepare the DataPart payload for the proxy\n        proxy_instruction_payload = {\n            \"target_mcp_server_id\": target_mcp_server_id,\n            \"tool_name\": tool_name,\n            \"arguments\": arguments\n        }\n        initial_message = Message(\n            role=\"user\", # Or appropriate role\n            parts=[DataPart(content=proxy_instruction_payload)]\n        )\n\n        async with AgentVaultClient() as client:\n            print(f\"Sending tool request to Proxy Agent: {proxy_card.human_readable_id}\")\n            task_id = await client.initiate_task(\n                agent_card=proxy_card,\n                initial_message=initial_message,\n                key_manager=key_manager\n            )\n            print(f\"Proxy Task initiated: {task_id}\")\n\n            # Stream events FROM THE PROXY\n            async for event in client.receive_messages(proxy_card, task_id, key_manager):\n                 if isinstance(event, av_models.TaskStatusUpdateEvent):\n                     print(f\"  Proxy Task Status: {event.state}\")\n                     if event.state.is_terminal(): break # Proxy task finished\n                 elif isinstance(event, av_models.TaskMessageEvent):\n                     # The proxy wraps the MCP result/error in a message part\n                     print(f\"  Proxy Response Message:\")\n                     for part in event.message.parts:\n                         if isinstance(part, DataPart):\n                             print(f\"    Data Result/Error from MCP: {part.content}\")\n                             # TODO: Parse part.content (which should match McpToolExecOutput)\n                             # to check success/error and extract MCP result\n                         else:\n                             print(f\"    Other Part: {part}\")\n                 # Handle other events...\n\n    except av_exceptions.AgentVaultError as e:\n        print(f\"AgentVault Error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected Error: {e}\")\n\n# Example Call\n# asyncio.run(call_mcp_via_proxy(\n#     proxy_agent_ref=\"http://localhost:8059/agent-card.json\",\n#     target_mcp_server_id=\"filesystem\",\n#     tool_name=\"filesystem.readFile\",\n#     arguments={\"path\": \"/data/test_script.py\"}\n# ))\n</code></pre>"},{"location":"architecture/mcp_support/#5-server-side-usage-implementing-the-proxy-agent","title":"5. Server-Side Usage (Implementing the Proxy Agent)","text":"<p>The MCP Tool Proxy Agent itself (built with <code>agentvault-server-sdk</code>):</p> <ol> <li>Receives the A2A <code>Message</code> in its <code>handle_task_send</code> method.</li> <li>Extracts the <code>target_mcp_server_id</code>, <code>tool_name</code>, and <code>arguments</code> from the incoming <code>Message.parts</code> (specifically looking for the <code>DataPart</code>).</li> <li>Looks up the target MCP server's base URL using the <code>target_mcp_server_id</code> (e.g., from an environment variable map <code>MCP_SERVER_MAP</code>).</li> <li>Uses an HTTP client (like <code>httpx</code>) to make the JSON-RPC 2.0 POST request to the target MCP server's <code>/rpc</code> endpoint.</li> <li>Parses the JSON-RPC response from the MCP server.</li> <li>Uses its <code>TaskStore</code> (<code>notify_message_event</code> or <code>notify_artifact_event</code>) to send the outcome back to the original A2A caller, wrapping the MCP result/error within a <code>DataPart</code>.</li> </ol> <p>(See the <code>mcp-tool-proxy-agent/src/mcp_tool_proxy_agent/agent.py</code> file in the POC for a concrete implementation.)</p>"},{"location":"architecture/mcp_support/#6-underlying-mcp-protocol-details-proxy-tool-server","title":"6. Underlying MCP Protocol Details (Proxy &lt;-&gt; Tool Server)","text":"<p>The communication between the Proxy Agent and the MCP Tool Server uses JSON-RPC 2.0 over HTTPS POST, typically to an <code>/rpc</code> endpoint on the tool server.</p> <ul> <li>Request: Standard JSON-RPC request where <code>method</code> is the tool name (e.g., <code>filesystem.readFile</code>) and <code>params</code> contains the arguments object.</li> <li>Response (Success): JSON-RPC response where the <code>result</code> field contains the tool's output, often structured with a <code>content</code> array (e.g., <code>{\"content\": [{\"type\": \"text\", \"text\": \"file data\"}]}</code>).</li> <li>Response (Tool Error): JSON-RPC response where the <code>result</code> field contains <code>{\"isError\": true, \"content\": [{\"type\": \"text\", \"text\": \"Error message\"}]}</code>.</li> <li>Response (Protocol Error): Standard JSON-RPC <code>error</code> object (e.g., for method not found, invalid params).</li> </ul>"},{"location":"architecture/mcp_support/#7-future-considerations","title":"7. Future Considerations","text":"<p>While the A2A Proxy Pattern is robust and recommended for v1.0.0, future work could include:</p> <ul> <li>Adding direct MCP client support to the <code>agentvault</code> library for simpler scenarios where a proxy isn't desired (though this requires careful security consideration).</li> <li>Further standardization of MCP tool schemas and discovery mechanisms.</li> <li>Refining the <code>mcp_utils</code> in the core library to align with official MCP specifications as they mature.</li> </ul>"},{"location":"architecture/overview/","title":"AgentVault Architecture Overview","text":"<p>AgentVault is designed as a modular ecosystem to provide the foundational infrastructure for secure and interoperable Agent-to-Agent (A2A) communication. It focuses on discovery, standardized communication protocols, and secure credential management, acting as the \"plumbing\" layer upon which complex multi-agent systems can be built.</p>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":"<p>The ecosystem consists of several distinct but interconnected Python packages and services:</p> <ol> <li> <p><code>agentvault_library</code> (Core Client Library):</p> <ul> <li>Purpose: The foundation for any client-side interaction (CLI, custom apps, other agents).</li> <li>Contains: <code>AgentVaultClient</code> (A2A/SSE/Auth logic), <code>KeyManager</code> (secure local credential storage), Pydantic models (<code>AgentCard</code>, <code>Message</code>, <code>Task</code>, etc.), <code>agent_card_utils</code>, <code>mcp_utils</code>.</li> <li>Key Feature: Abstracts the complexities of A2A communication and authentication.</li> </ul> </li> <li> <p><code>agentvault_cli</code> (Command Line Interface):</p> <ul> <li>Purpose: Primary user/developer tool for terminal interaction.</li> <li>Contains: Commands wrapping library functions (<code>config</code>, <code>discover</code>, <code>run</code>).</li> <li>Key Feature: Provides easy access to discovery, task execution, and secure credential configuration via <code>KeyManager</code>.</li> </ul> </li> <li> <p><code>agentvault_registry</code> (Registry API &amp; UI):</p> <ul> <li>Purpose: The central discovery hub. Stores and serves standardized <code>AgentCard</code> metadata. It does not execute agents.</li> <li>Contains: FastAPI backend, PostgreSQL database (via SQLAlchemy/asyncpg), Alembic migrations, Public REST API (<code>/api/v1</code>), Developer Portal UI (<code>/ui/developer</code>), Public Discovery UI (<code>/ui</code>).</li> <li>Key Features: Agent Card validation, developer authentication (JWT for UI/API, Programmatic API Keys), search/filtering capabilities (including tags, TEE), email verification, rate limiting.</li> </ul> </li> <li> <p><code>agentvault_server_sdk</code> (Server SDK):</p> <ul> <li>Purpose: Toolkit for developers building A2A-compliant agents.</li> <li>Contains: <code>BaseA2AAgent</code> abstract class, FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code>), task state management abstractions (<code>BaseTaskStore</code>, <code>InMemoryTaskStore</code>), packaging utility (<code>agentvault-sdk package</code>).</li> <li>Key Feature: Simplifies adherence to the A2A protocol and integration with FastAPI.</li> </ul> </li> <li> <p><code>agentvault_testing_utils</code> (Internal Testing Utilities):</p> <ul> <li>Purpose: Shared mocks (<code>MockAgentVaultClient</code>), pytest fixtures (<code>mock_a2a_server</code>), factories, and helpers for internal testing across the monorepo.</li> <li>Contains: Tools to simulate A2A interactions and agent behavior during tests.</li> <li>Key Feature: Ensures consistent and efficient testing of interconnected components.</li> </ul> </li> </ol>"},{"location":"architecture/overview/#high-level-interaction-flow","title":"High-Level Interaction Flow","text":"<pre><code>graph LR\n    subgraph UserClient [User / Client Application]\n        User[User] --&gt;|Uses| CLI(agentvault_cli);\n        CLI --&gt;|Uses| Lib(agentvault_library);\n        User --&gt;|Can Use Directly| Lib;\n        Lib --&gt;|Manages Keys| KeyStore[(Local Credential Store\\nEnv/File/Keyring)];\n    end\n\n    subgraph DeveloperSide [Agent Developer]\n        Dev[Developer] --&gt;|Uses| SDK(agentvault_server_sdk);\n        SDK -.-&gt;|Builds| AgentServer(A2A Agent Server);\n        Dev --&gt;|Registers &amp; Manages via UI/API| RegistryAPI(Registry API /api/v1);\n        RegistryAPI --&gt;|Requires Dev Auth (JWT / API Key)| DevLogin(Developer Login);\n    end\n\n    subgraph CentralRegistry [Central Registry Service]\n        RegistryAPI --&gt;|Stores/Retrieves| DB[(Registry DB\\nCards &amp; Dev Hashes)];\n        RegistryAPI --&gt;|Serves UI| RegistryUI(Registry Web UI /ui /ui/developer);\n        User --&gt;|Browses Discovery| RegistryUI;\n        Dev --&gt;|Uses Developer Portal| RegistryUI;\n    end\n\n    subgraph CommunicationFlow [Communication Paths]\n        Lib --&gt;|1. Discover Agent\\n(Public API)| RegistryAPI;\n        Lib --&gt;|2. Get AgentCard\\n(Public API)| RegistryAPI;\n        Lib --&gt;|3. Run Task\\n(A2A Protocol via HTTPS)| AgentServer;\n        AgentServer --&gt;|Optional: Uses SDK/External Services| ExternalService[External APIs];\n    end\n\n    style KeyStore stroke-dasharray: 5 5;\n    style DevLogin stroke-dasharray: 5 5;</code></pre> <p>Flow Explanation:</p> <ol> <li>Discovery: A Client (using the Library or CLI) queries the Registry API's public endpoints or browses the public Web UI to find suitable agents based on search criteria, tags, or capabilities like TEE support.</li> <li>Card Retrieval: The Client retrieves the Agent Card for the desired agent from the Registry API (public endpoint).</li> <li>Interaction:<ul> <li>The Client uses the <code>url</code> and <code>authSchemes</code> from the Agent Card.</li> <li>The Library's <code>KeyManager</code> loads the necessary local credentials based on the <code>service_identifier</code> (or other logic).</li> <li>The Library's <code>AgentVaultClient</code> sends A2A requests (HTTPS POST with JSON-RPC) directly to the Agent Server, automatically handling authentication (e.g., adding <code>X-Api-Key</code> or fetching/adding <code>Authorization: Bearer</code> token).</li> <li>If subscribing (<code>tasks/sendSubscribe</code>), the <code>AgentVaultClient</code> handles the SSE connection.</li> </ul> </li> <li>Agent Server Processing: The Agent Server (likely built with the SDK) receives the request, validates authentication (if required), processes the task (potentially interacting with external services), manages state, and sends responses/SSE events back to the client.</li> <li>Developer Management: The Developer uses the Developer Portal UI or Registry API (authenticating via JWT or programmatic API Key) to submit, update, or deactivate their Agent Cards and manage their API keys. The Registry validates cards and stores them in the Registry DB along with hashed developer credentials/keys.</li> </ol>"},{"location":"architecture/overview/#architectural-positioning","title":"Architectural Positioning","text":"<p>AgentVault provides the foundational infrastructure layer for secure A2A communication and discovery. It is designed to:</p> <ul> <li>Complement Orchestration Frameworks: Tools like LangGraph, CrewAI, Autogen can leverage AgentVault's client library to securely interact with diverse, discoverable external agents using a standard protocol, rather than implementing custom integrations for each agent.</li> <li>Prioritize Security &amp; Interoperability: Focuses on secure credential handling (<code>KeyManager</code>, hashed storage, standard auth schemes) and standardized communication (A2A Profile, Agent Cards) as first-class concerns.</li> <li>Be Open and Flexible: The Apache 2.0 license and modular design prevent vendor lock-in and allow integration into various architectures.</li> <li>Serve the Python Ecosystem: Provides native Python tools for both client-side interaction and server-side agent development.</li> </ul> <p>It is not intended to be an all-in-one agent platform but rather the reliable, secure plumbing that enables such platforms and more complex multi-agent systems to flourish.</p>"},{"location":"architecture/security_concepts/","title":"AgentVault Security Concepts","text":"<p>Note: For the official security policy and vulnerability reporting process, please see the Security Policy document.</p> <p>Security is a core design principle of AgentVault. This document details the security mechanisms, considerations, and best practices implemented across the ecosystem to facilitate trustworthy interactions between agents and protect user/developer credentials.</p>"},{"location":"architecture/security_concepts/#1-client-to-agent-authentication-a2a","title":"1. Client-to-Agent Authentication (A2A)","text":"<p>The communication between an AgentVault client (like the CLI or library) and an A2A agent server must be properly authenticated if the agent requires it. Agents declare their supported authentication methods in the <code>authSchemes</code> array within their <code>AgentCard</code>.</p> <p>Supported Schemes (by <code>agentvault</code> library v0.2.x):</p> <ul> <li> <p><code>none</code>:</p> <ul> <li>Mechanism: No authentication headers are sent.</li> <li>Use Case: Suitable only for public agents handling non-sensitive data or actions where identity is irrelevant.</li> <li>Security: Offers no protection against unauthorized access.</li> </ul> </li> <li> <p><code>apiKey</code>:</p> <ul> <li>Mechanism: The client sends a pre-shared secret API key in the <code>X-Api-Key</code> HTTP header.</li> <li>Client-Side: The <code>agentvault</code> library uses <code>KeyManager</code> to retrieve the appropriate API key based on the <code>service_identifier</code> specified in the agent's card (or a user override). Secure storage via OS Keyring is recommended (<code>agentvault config set &lt;service_id&gt; --keyring</code>).</li> <li>Server-Side: The agent server (built potentially with <code>agentvault-server-sdk</code>) must implement logic (e.g., a FastAPI dependency) to receive the <code>X-Api-Key</code> header, validate the key against its securely stored keys/hashes, and authorize the request.</li> <li>Security: Relies on the secrecy of the API key. Keys should be treated as sensitive credentials.</li> </ul> </li> <li> <p><code>oauth2</code> (Client Credentials Grant Flow):</p> <ul> <li>Mechanism: Standard OAuth 2.0 flow where the client authenticates itself (not an end-user) to the agent's token endpoint to obtain a short-lived Bearer token.</li> <li>Agent Card Requirements: Must include <code>scheme: \"oauth2\"</code> and a valid <code>tokenUrl</code>. Can optionally include <code>scopes</code>.</li> <li>Client-Side:<ol> <li><code>AgentVaultClient</code> identifies the <code>oauth2</code> scheme and <code>tokenUrl</code>.</li> <li>It uses <code>KeyManager</code> to retrieve the client's Client ID and Client Secret associated with the agent's <code>service_identifier</code>. Secure storage via OS Keyring is recommended (<code>agentvault config set &lt;service_id&gt; --oauth-configure</code>).</li> <li>The client POSTs <code>grant_type=client_credentials</code>, <code>client_id</code>, and <code>client_secret</code> (and optional <code>scope</code>) to the agent's <code>tokenUrl</code>.</li> <li>It receives an <code>access_token</code> and caches it (respecting <code>expires_in</code> if provided).</li> <li>For subsequent A2A requests to the agent's main <code>url</code>, the client includes the <code>Authorization: Bearer &lt;access_token&gt;</code> header.</li> </ol> </li> <li>Server-Side:<ol> <li>The agent server must host the <code>/token</code> endpoint specified in its card. This endpoint validates the received <code>client_id</code> and <code>client_secret</code> and issues signed, short-lived JWT Bearer tokens.</li> <li>The agent's main <code>/a2a</code> endpoint must include a dependency (like FastAPI's <code>HTTPBearer</code> or a custom one) to validate the incoming <code>Authorization: Bearer &lt;token&gt;</code> (checking signature, expiry, audience, scopes).</li> </ol> </li> <li>Security: Considered more secure than static API keys for server-to-server communication as it uses short-lived tokens and standard flows. Relies on secure storage of Client ID/Secret on the client and secure token validation on the server.</li> </ul> </li> <li> <p><code>bearer</code>:</p> <ul> <li>Mechanism: The client sends a pre-existing Bearer token (obtained through means external to the AgentVault client library, e.g., a user login flow) in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>Client-Side: The <code>AgentVaultClient</code> does not manage the lifecycle of these tokens. The calling application is responsible for obtaining and providing the token.</li> <li>Server-Side: The agent server must validate the Bearer token.</li> <li>Security: Security depends entirely on the external mechanism used to obtain and manage the token.</li> </ul> </li> </ul> <p>(Refer to the A2A Profile v0.2 for detailed protocol structure.)</p>"},{"location":"architecture/security_concepts/#2-developer-to-registry-authentication","title":"2. Developer-to-Registry Authentication","text":"<p>Developers need to authenticate with the AgentVault Registry API (<code>agentvault_registry</code>) to manage their registered agents and API keys.</p> <ul> <li> <p>Account Creation &amp; Login (Email/Password + JWT):</p> <ul> <li>Developers register with an email and password. Passwords are hashed using bcrypt via <code>passlib</code>.</li> <li>Email verification is required to activate the account.</li> <li>Successful login (<code>POST /auth/login</code>) issues a short-lived JWT access token.</li> <li>This JWT must be sent in the <code>Authorization: Bearer &lt;token&gt;</code> header for protected API calls (e.g., <code>POST /api/v1/agent-cards/</code>) and interactions with the Developer Portal UI (<code>/ui/developer</code>).</li> <li>The registry validates the JWT signature (using <code>API_KEY_SECRET</code> from its config) and expiry on each request.</li> </ul> </li> <li> <p>Programmatic API Keys (<code>X-Api-Key</code>):</p> <ul> <li>Developers can generate separate, long-lived API keys (prefixed <code>avreg_</code>) via the Developer Portal UI or API (<code>POST /developers/me/apikeys</code>).</li> <li>The registry stores the hash (bcrypt via <code>passlib</code>) of the full key and the non-secret prefix (<code>avreg_</code>). The plain key is shown only once upon generation.</li> <li>For programmatic access to manage agent cards, developers can use the <code>X-Api-Key</code> header containing the plain key.</li> <li>The registry API verifies the key by looking up potential matches based on the prefix and then comparing the hash of the provided key with stored hashes using <code>passlib.verify()</code>. It also checks if the key is active.</li> </ul> </li> <li> <p>Account Recovery (Recovery Keys):</p> <ul> <li>Generated during registration, displayed once, must be stored securely offline by the developer.</li> <li>The registry stores a hash (bcrypt) of one representative recovery key.</li> <li>If a password is lost, the developer can use their email + one plain recovery key via <code>POST /auth/recover-account</code>.</li> <li>The server verifies the plain key against the stored hash. If valid, it issues a very short-lived JWT (with <code>purpose: password-set</code>) allowing the developer to call <code>POST /auth/set-new-password</code>.</li> <li>Using a recovery key invalidates its stored hash, preventing reuse.</li> </ul> </li> </ul>"},{"location":"architecture/security_concepts/#3-credential-management-keymanager-client-side","title":"3. Credential Management (<code>KeyManager</code> - Client Side)","text":"<p>The <code>agentvault.key_manager.KeyManager</code> class provides a crucial security abstraction on the client-side (e.g., within the CLI or custom applications using the library).</p> <ul> <li>Purpose: Securely store and retrieve the secrets (API keys, OAuth Client IDs/Secrets) needed to authenticate with various remote A2A agents.</li> <li>Secure Storage: Strongly recommends using the OS Keyring (<code>keyring</code> library integration) as the backend. This leverages native secure storage mechanisms (e.g., macOS Keychain, Windows Credential Manager, Linux Secret Service). Use <code>agentvault_cli config set &lt;service_id&gt; --keyring</code> or <code>--oauth-configure</code>.</li> <li>Alternative Sources: Supports loading from environment variables (e.g., <code>AGENTVAULT_KEY_OPENAI</code>) or local files (<code>.env</code>, <code>.json</code>). Users are responsible for securing these sources (e.g., file permissions, secure environment variable management).</li> <li>Abstraction: Client code interacts with <code>KeyManager.get_key()</code> or <code>get_oauth_client_id()</code>, etc., using a logical <code>service_id</code> (e.g., \"openai\", \"my-custom-agent\"). The KeyManager handles finding the credential from the highest-priority source (File &gt; Env &gt; Keyring).</li> </ul>"},{"location":"architecture/security_concepts/#4-transport-security-https","title":"4. Transport Security (HTTPS)","text":"<ul> <li>Requirement: HTTPS is MANDATORY for all A2A communication and all communication with the AgentVault Registry API, unless explicitly connecting to <code>localhost</code> during development.</li> <li>Rationale: Prevents eavesdropping and man-in-the-middle attacks, ensuring the confidentiality and integrity of requests and responses (including authentication credentials like API keys or Bearer tokens).</li> <li>Enforcement: Clients should verify TLS certificates. Agent implementations and registry deployments MUST be configured for HTTPS.</li> </ul>"},{"location":"architecture/security_concepts/#5-data-validation","title":"5. Data Validation","text":"<ul> <li>Pydantic: Used across all components (library models, registry API, server SDK) to rigorously validate data structures (Agent Cards, A2A messages, API request/response bodies) against defined schemas.</li> <li>Benefit: Prevents injection attacks, malformed data processing errors, and ensures protocol adherence.</li> </ul>"},{"location":"architecture/security_concepts/#6-rate-limiting-registry","title":"6. Rate Limiting (Registry)","text":"<ul> <li>Mechanism: The public AgentVault Registry API implements IP-based rate limiting using <code>slowapi</code> to mitigate denial-of-service (DoS) attacks and prevent abuse of public endpoints.</li> <li>Agent Responsibility: Developers building A2A agents should implement their own rate limiting suitable for their agent's expected load and cost model.</li> </ul>"},{"location":"architecture/security_concepts/#7-trusted-execution-environments-tee","title":"7. Trusted Execution Environments (TEE)","text":"<ul> <li>Support: AgentVault v1.0.0 includes declarative support for TEEs. Agents can advertise their use of TEEs (like Intel SGX, AWS Nitro Enclaves) in their Agent Card via the <code>capabilities.teeDetails</code> field.</li> <li>Discovery: The registry allows filtering agents based on whether they declare TEE support (<code>?has_tee=true/false</code>) or a specific TEE type (<code>?tee_type=...</code>).</li> <li>Verification: Client-side verification of TEE attestations is NOT yet implemented in the core library. Clients needing high assurance must implement attestation verification specific to the agent's declared TEE type using the optional <code>attestationEndpoint</code> from the Agent Card.</li> <li>(See TEE Profile for details).</li> </ul>"},{"location":"architecture/security_concepts/#8-dependency-security","title":"8. Dependency Security","text":"<ul> <li>Auditing: The project includes automated dependency vulnerability scanning using <code>pip-audit</code> via GitHub Actions.</li> <li>Maintenance: Regularly updating dependencies is crucial to patch known vulnerabilities.</li> </ul>"},{"location":"architecture/security_concepts/#best-practices-summary","title":"Best Practices Summary","text":"<ul> <li>Users/Clients: Use the OS Keyring via <code>agentvault_cli config set --keyring</code> or <code>--oauth-configure</code> for storing agent credentials. Avoid placing secrets directly in scripts or unsecured files/environment variables. Always verify agent identity and trustworthiness before interacting, especially for sensitive tasks.</li> <li>Agent Developers:<ul> <li>Use HTTPS for your A2A endpoint.</li> <li>Choose appropriate <code>authSchemes</code> for your agent's sensitivity. Implement robust server-side validation for the chosen schemes.</li> <li>Securely store any credentials your agent needs (e.g., for backend services) using environment variables or dedicated secrets management solutions, not in code.</li> <li>Implement input validation and rate limiting.</li> <li>If handling sensitive data, consider deploying within a TEE and declare it in your Agent Card.</li> <li>Keep SDK and other dependencies updated.</li> </ul> </li> <li>Registry Deployers:<ul> <li>Securely manage the <code>DATABASE_URL</code> and <code>API_KEY_SECRET</code>.</li> <li>Configure appropriate CORS policies (<code>ALLOWED_ORIGINS</code>).</li> <li>Set up robust monitoring, logging, and database backups.</li> <li>Deploy behind a reverse proxy handling HTTPS termination.</li> </ul> </li> </ul>"},{"location":"developer_guide/library/","title":"Developer Guide: Client Library (<code>agentvault</code>)","text":"<p>The <code>agentvault</code> library is the core Python package for interacting with the AgentVault ecosystem from the client-side. It enables applications, scripts, or even other agents to discover A2A agents, manage credentials securely, and communicate using the A2A protocol.</p>"},{"location":"developer_guide/library/#installation","title":"Installation","text":"<p>Install the library from PyPI:</p> <pre><code>pip install agentvault\n</code></pre> <p>For optional OS Keyring support (recommended for secure credential storage):</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"developer_guide/library/#key-components","title":"Key Components","text":""},{"location":"developer_guide/library/#keymanager-key_managerpy","title":"<code>KeyManager</code> (<code>key_manager.py</code>)","text":"<p>Handles secure loading, storage, and retrieval of credentials (API keys, OAuth 2.0 Client ID/Secret) needed for agent authentication.</p> <ul> <li>Purpose: Abstracts credential sources so your client code doesn't need to handle each case explicitly. Provides a consistent interface (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) regardless of where the credential is stored.</li> <li>Initialization: <pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Recommended: Load from environment variables AND OS keyring (if available)\n# Keyring is checked only if the key isn't found in env vars first.\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Load ONLY from a specific .env file (disable env vars and keyring)\n# key_file_path = pathlib.Path(\"path/to/your/keys.env\")\n# km_file_only = KeyManager(key_file_path=key_file_path, use_env_vars=False, use_keyring=False)\n\n# Load from file AND environment (file takes priority over env)\n# key_file_path = pathlib.Path(\"path/to/your/keys.json\")\n# km_file_env = KeyManager(key_file_path=key_file_path, use_env_vars=True, use_keyring=False)\n</code></pre></li> <li>Priority Order: When retrieving credentials, <code>KeyManager</code> checks sources in this order:<ol> <li>File Cache: If <code>key_file_path</code> was provided during init and the file contained the credential.</li> <li>Environment Variable Cache: If <code>use_env_vars=True</code> (default) and the corresponding environment variable was set during init.</li> <li>OS Keyring: If <code>use_keyring=True</code> and the credential was not found in the file or environment caches. This check happens on demand when a <code>get_...</code> method is called.</li> </ol> </li> <li>Service Identifier (<code>service_id</code>): This is the crucial string used to look up credentials. It's a local name you choose (e.g., \"openai\", \"my-agent-key\", \"google-oauth-agent\") that maps to the credentials needed for a specific agent or service.<ul> <li>It often corresponds to the <code>authSchemes[].service_identifier</code> field in an Agent Card.</li> <li>If the Agent Card omits <code>service_identifier</code>, the client might default to using the agent's <code>humanReadableId</code> or require the user/developer to specify which local <code>service_id</code> to use (e.g., via <code>agentvault_cli run --key-service &lt;your_local_id&gt;</code>).</li> </ul> </li> <li>Storage Conventions:<ul> <li>Environment Variables:<ul> <li>API Key: <code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code></li> </ul> </li> <li><code>.env</code> File:<ul> <li>API Key: <code>&lt;service_id_lower&gt;=your_api_key</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_ID=your_client_id</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_SECRET=your_client_secret</code></li> </ul> </li> <li><code>.json</code> File: <pre><code>{\n  \"service_id_lower\": \"your_api_key\",\n  \"another_service\": {\n    \"apiKey\": \"another_api_key\",\n    \"oauth\": {\n      \"clientId\": \"oauth_client_id\",\n      \"clientSecret\": \"oauth_client_secret\"\n    }\n  }\n}\n</code></pre></li> <li>OS Keyring: Uses specific service/username conventions (see <code>key_manager.py</code> source for details, e.g., service=<code>agentvault:oauth:&lt;norm_id&gt;</code>, username=<code>clientId</code>). Use <code>agentvault_cli config set &lt;service_id&gt; --keyring</code> or <code>--oauth-configure</code> to store securely.</li> </ul> </li> <li>Retrieving Credentials: <pre><code>km = KeyManager(use_keyring=True) # Example instance\n\n# Get API Key (returns None if not found)\napi_key = km.get_key(\"openai\")\nif api_key:\n    source = km.get_key_source(\"openai\") # 'env', 'file', 'keyring', or None\n    print(f\"Found OpenAI API Key (Source: {source})\")\n\n# Get OAuth Credentials (return None if not found or incomplete)\nclient_id = km.get_oauth_client_id(\"google-oauth-agent\")\nclient_secret = km.get_oauth_client_secret(\"google-oauth-agent\")\nif client_id and client_secret:\n    status = km.get_oauth_config_status(\"google-oauth-agent\")\n    print(f\"Found Google OAuth Credentials ({status})\")\n    print(f\"  Client ID: {client_id}\")\n    # Note: AgentVaultClient uses these to automatically fetch the Bearer token.\n</code></pre></li> <li>Storing Credentials (Primarily for CLI/Setup): <pre><code>from agentvault import KeyManagementError\n\nkm = KeyManager(use_keyring=True)\ntry:\n    # Store API Key securely in OS keyring\n    km.set_key_in_keyring(\"my-new-service\", \"sk-abc...\")\n    print(\"API Key stored successfully.\")\n\n    # Store OAuth creds securely in OS keyring\n    km.set_oauth_creds_in_keyring(\"my-oauth-service\", \"client_id_123\", \"client_secret_xyz\")\n    print(\"OAuth credentials stored successfully.\")\n\nexcept KeyManagementError as e:\n    # Handle cases where keyring is unavailable or write fails\n    print(f\"Failed to store credentials in keyring: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid input for storing credentials: {e}\")\n</code></pre></li> </ul>"},{"location":"developer_guide/library/#agentvaultclient-clientpy","title":"<code>AgentVaultClient</code> (<code>client.py</code>)","text":"<p>The primary class for making asynchronous A2A calls to remote agents.</p> <ul> <li>Purpose: Handles HTTP requests (using <code>httpx</code>), authentication logic (including OAuth2 Client Credentials token fetching/caching), JSON-RPC formatting, SSE streaming, and response parsing according to the A2A Profile v0.2.</li> <li> <p>Usage: Best used as an async context manager (<code>async with</code>) to ensure the underlying HTTP client is properly closed. Requires an <code>AgentCard</code> instance (loaded via <code>agent_card_utils</code>) and a <code>KeyManager</code> instance for authentication.</p> <pre><code>import asyncio\nimport logging\nimport pathlib\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, TextPart,\n    agent_card_utils, exceptions as av_exceptions, models as av_models\n)\n\n# Configure logging for visibility\nlogging.basicConfig(level=logging.INFO)\n\nasync def run_agent_task(agent_ref: str, input_text: str):\n    # Initialize KeyManager - typically done once per application\n    key_manager = KeyManager(use_keyring=True)\n    agent_card = None\n    task_id = None\n\n    try:\n        # --- 1. Load Agent Card ---\n        print(f\"Loading agent card: {agent_ref}\")\n        # (Simplified loading logic - see previous version for URL/File/ID handling)\n        agent_card = await agent_card_utils.fetch_agent_card_from_url(agent_ref) # Example URL load\n\n        if not agent_card:\n             print(f\"Error: Could not load agent card for {agent_ref}\")\n             return\n        print(f\"Loaded Agent: {agent_card.name}\")\n\n        # --- 2. Prepare Initial Message ---\n        initial_message = Message(role=\"user\", parts=[TextPart(content=input_text)])\n        mcp_data = {\"user_preference\": \"verbose\"} # Optional MCP context\n\n        # --- 3. Interact using AgentVaultClient ---\n        async with AgentVaultClient() as client:\n            # Initiate the task\n            # AgentVaultClient automatically handles authentication (apiKey or oauth2)\n            # based on agent_card.authSchemes and credentials from key_manager.\n            print(f\"Initiating task...\")\n            task_id = await client.initiate_task(\n                agent_card=agent_card,\n                initial_message=initial_message,\n                key_manager=key_manager,\n                mcp_context=mcp_data,\n            )\n            print(f\"Task initiated: {task_id}\")\n\n            # Stream and process events\n            print(\"Streaming events...\")\n            final_response_text = \"\"\n            async for event in client.receive_messages(\n                agent_card=agent_card, task_id=task_id, key_manager=key_manager\n            ):\n                if isinstance(event, av_models.TaskStatusUpdateEvent):\n                    print(f\"  Status Update: {event.state} \"\n                          f\"(Msg: {event.message or 'N/A'})\")\n                    if event.state in [av_models.TaskState.COMPLETED,\n                                       av_models.TaskState.FAILED,\n                                       av_models.TaskState.CANCELED]:\n                        print(\"  Terminal state reached.\")\n                        break\n                elif isinstance(event, av_models.TaskMessageEvent):\n                    print(f\"  Message Received (Role: {event.message.role}):\")\n                    for part in event.message.parts:\n                        if isinstance(part, TextPart):\n                            print(f\"    Text: {part.content}\")\n                            if event.message.role == \"assistant\":\n                                final_response_text += part.content + \"\\n\"\n                        # --- ADDED: Example handling other part types ---\n                        elif isinstance(part, av_models.FilePart):\n                            print(f\"    File Ref: {part.url} (Type: {part.media_type}, Name: {part.filename})\")\n                        elif isinstance(part, av_models.DataPart):\n                            print(f\"    Data (Type: {part.media_type}): {part.content}\")\n                        # --- END ADDED ---\n                        else:\n                            print(f\"    Part (Type: {getattr(part, 'type', 'Unknown')}): {part}\")\n                elif isinstance(event, av_models.TaskArtifactUpdateEvent):\n                     artifact = event.artifact\n                     print(f\"  Artifact Update (ID: {artifact.id}, Type: {artifact.type}):\")\n                     if artifact.url: print(f\"    URL: {artifact.url}\")\n                     if artifact.media_type: print(f\"    Media Type: {artifact.media_type}\")\n                     # Handle content display/saving based on size/type\n                     if artifact.content:\n                         content_repr = repr(artifact.content)\n                         print(f\"    Content: {content_repr[:100]}{'...' if len(content_repr) &gt; 100 else ''}\")\n                     else:\n                         print(\"    Content: [Not provided directly]\")\n                # --- ADDED: Handling potential error events within stream ---\n                # Note: A2ARemoteAgentError might also be raised by receive_messages\n                # if the stream itself returns an error status initially.\n                elif isinstance(event, dict) and event.get(\"error\"): # Check for error structure\n                     print(f\"  ERROR received via SSE stream: {event}\")\n                     # Decide how to handle stream errors (e.g., break, log, append to response)\n                     final_response_text += f\"\\n[Stream Error: {event.get('message', 'Unknown')}]\"\n                     break # Example: Stop processing on stream error\n                # --- END ADDED ---\n                else:\n                    print(f\"  Received unknown event type: {type(event)}\")\n\n            print(\"\\n--- Final Aggregated Agent Response ---\")\n            print(final_response_text.strip())\n            print(\"---------------------------------------\")\n\n    # --- 5. Handle Potential Errors ---\n    except av_exceptions.AgentCardError as e:\n        print(f\"Error loading or validating agent card: {e}\")\n    except av_exceptions.A2AAuthenticationError as e:\n        print(f\"Authentication error: {e}\")\n        print(\"Hint: Ensure credentials for the required service_id are configured.\")\n    except av_exceptions.A2AConnectionError as e:\n        print(f\"Connection error communicating with agent or token endpoint: {e}\")\n    except av_exceptions.A2ARemoteAgentError as e:\n        # Agent returned an error (e.g., JSON-RPC error or non-2xx HTTP status)\n        print(f\"Agent returned an error:\")\n        print(f\"  Status Code (if HTTP/RPC error): {e.status_code}\") # Can be HTTP status or RPC code\n        print(f\"  Message: {e}\")\n        print(f\"  Response Body/Data: {e.response_body}\") # Contains JSON RPC error data or HTTP body\n    except av_exceptions.A2AMessageError as e:\n         print(f\"A2A protocol message error (e.g., invalid format): {e}\")\n    except av_exceptions.A2ATimeoutError as e:\n         print(f\"A2A request timed out: {e}\")\n    except av_exceptions.KeyManagementError as e:\n         print(f\"Error managing local keys/credentials: {e}\")\n    except NotImplementedError as e:\n         print(f\"Functionality not implemented: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {type(e).__name__}: {e}\")\n        logging.exception(\"Unexpected error details:\")\n\n# Example usage:\n# asyncio.run(run_agent_task(\"https://some-agent.com/agent-card.json\", \"Summarize this document.\"))\n</code></pre> </li> </ul>"},{"location":"developer_guide/library/#models-agentvaultmodels","title":"Models (<code>agentvault.models</code>)","text":"<p>Pydantic models defining the data structures for Agent Cards and the A2A protocol. Refer to the source code docstrings or the A2A Profile v0.2 for details on specific models like <code>AgentCard</code>, <code>Message</code>, <code>Task</code>, <code>TaskState</code>, <code>A2AEvent</code>, etc.</p>"},{"location":"developer_guide/library/#exceptions-agentvaultexceptions","title":"Exceptions (<code>agentvault.exceptions</code>)","text":"<p>Custom exceptions provide granular error handling. Catching these allows for more robust client applications.</p> <ul> <li><code>AgentCardError</code>: Issues loading/validating the Agent Card.</li> <li><code>A2AAuthenticationError</code>: Missing/invalid credentials, OAuth flow failures. Check KeyManager setup.</li> <li><code>A2AConnectionError</code>: Network issues connecting to the agent or token endpoint (DNS, connection refused).</li> <li><code>A2ATimeoutError</code>: Request timed out.</li> <li><code>A2ARemoteAgentError</code>: The agent returned an error. Check <code>e.status_code</code> (can be HTTP status or JSON-RPC error code) and <code>e.response_body</code> (can be HTTP response text or JSON-RPC error data) for details from the agent.</li> <li><code>A2AMessageError</code>: Invalid JSON-RPC format or unexpected response structure from the agent.</li> <li><code>KeyManagementError</code>: Issues saving/loading keys with <code>KeyManager</code>.</li> </ul> <p>See the example above for a basic <code>try...except</code> block structure.</p>"},{"location":"developer_guide/library/#utilities-agentvaultagent_card_utils-agentvaultmcp_utils","title":"Utilities (<code>agentvault.agent_card_utils</code>, <code>agentvault.mcp_utils</code>)","text":"<ul> <li><code>agent_card_utils</code>: Functions like <code>load_agent_card_from_file</code> and <code>fetch_agent_card_from_url</code> simplify obtaining and validating <code>AgentCard</code> objects.</li> <li><code>mcp_utils</code>: Contains helpers for handling Model Context Protocol data.<ul> <li><code>format_mcp_context</code>: (Primarily for advanced clients or server-side) Validates and formats a dictionary intended as MCP context.</li> <li><code>get_mcp_context</code>: (Client-side) Safely extracts the <code>mcp_context</code> dictionary from a received <code>Message</code>'s metadata.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/","title":"Developer Guide: Registry API (<code>agentvault_registry</code>)","text":"<p>The AgentVault Registry provides a central RESTful API service and Web UI for discovering and managing Agent Cards. Developers interact with it programmatically or via the UI to publish their agents, while clients (like the <code>agentvault_cli</code> or other applications) use it to find agents.</p> <ul> <li>Public Registry &amp; UI: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Public Discovery UI: <code>/ui</code></li> <li>Developer Portal UI: <code>/ui/developer</code></li> <li>API Base Path: <code>/api/v1</code></li> </ul> <p>(Note: The public instance runs on a free tier and may experience cold starts taking up to 60 seconds for the first request after inactivity.)</p>"},{"location":"developer_guide/registry/#authentication-developer-registration","title":"Authentication &amp; Developer Registration","text":"<p>Interacting with the registry requires different levels of authentication:</p> <ol> <li>Public Access: Discovering agents (<code>GET /api/v1/agent-cards/</code>, <code>GET /api/v1/agent-cards/{card_id}</code>, <code>GET /api/v1/agent-cards/id/{human_readable_id}</code>) and validating card data (<code>POST /api/v1/utils/validate-card</code>) are generally public and do not require authentication.</li> <li>Developer Account Authentication (JWT): Managing your own agent cards (create, update, deactivate), managing programmatic API keys, and using the agent builder requires you to be logged in as a registered developer. This uses email/password authentication via the <code>/auth/login</code> endpoint, which returns a JSON Web Token (JWT). Subsequent requests to protected developer endpoints must include this JWT in the <code>Authorization: Bearer &lt;token&gt;</code> HTTP header.</li> <li>Programmatic API Key Authentication: For automated scripts or CI/CD pipelines interacting with the registry API (e.g., to update an agent card automatically), developers can generate programmatic API keys. These keys are sent in the <code>X-Api-Key</code> HTTP header for specific authenticated endpoints (primarily intended for agent card management, though JWT is preferred for user-driven actions).</li> </ol> <p>Registration Workflow:</p> <ul> <li>Self-Registration: Developers can register via the <code>/ui/register</code> page or the <code>POST /auth/register</code> API endpoint.</li> <li>Required Information: Name, Email, Password.</li> <li>Verification: Upon registration, a verification email is sent to the provided address. The developer must click the link in the email to activate their account (<code>GET /auth/verify-email</code>). Unverified accounts cannot log in.</li> <li>Recovery Keys: During registration, a set of single-use recovery keys are generated and displayed only once. These keys are essential for regaining account access if the password is lost and email reset is unavailable. Store these keys securely offline.</li> <li>Password Reset: A password reset can be requested via email (if email sending is configured on the registry instance) using the <code>/ui/forgot-password</code> page or <code>POST /auth/request-password-reset</code> endpoint. Alternatively, account access can be regained using a recovery key via the <code>/ui/recover-with-key</code> page or <code>POST /auth/recover-account</code> endpoint, which provides a temporary token to set a new password via <code>/ui/set-new-password</code> or <code>POST /auth/set-new-password</code>. Using a recovery key invalidates it.</li> </ul>"},{"location":"developer_guide/registry/#api-endpoints","title":"API Endpoints","text":"<p>(Refer to the OpenAPI documentation at <code>/docs</code> or <code>/redoc</code> on the running registry instance for full details, request/response schemas, and interactive testing.)</p>"},{"location":"developer_guide/registry/#authentication-auth","title":"Authentication (<code>/auth</code>)","text":"<p>Handles developer registration, login, email verification, and password/account recovery.</p> <ul> <li><code>POST /register</code>: Creates a new developer account. Requires name, email, password. Returns a success message and one-time recovery keys. Triggers verification email.</li> <li><code>POST /login</code>: Authenticates using email/password (sent as form data). Returns a JWT <code>access_token</code> (<code>schemas.Token</code>). Requires verified email.</li> <li><code>GET /verify-email</code>: Endpoint visited via the link in the verification email. Activates the developer account. Redirects user to success/failure UI pages.</li> <li><code>POST /request-password-reset</code>: (Placeholder/Future) Sends a password reset link to the developer's email.</li> <li><code>POST /reset-password</code>: (Placeholder/Future) Sets a new password using a token from the reset email.</li> <li><code>POST /recover-account</code>: Verifies email and a recovery key. Returns a short-lived JWT (<code>schemas.Token</code>) specifically for setting a new password.</li> <li><code>POST /set-new-password</code>: Sets a new password using the temporary token from <code>/recover-account</code>. Requires <code>Authorization: Bearer &lt;temp_token&gt;</code> header and <code>{\"new_password\": \"...\"}</code> body. Invalidates the used recovery key hash.</li> </ul>"},{"location":"developer_guide/registry/#developers-developers","title":"Developers (<code>/developers</code>)","text":"<p>Endpoints for managing the authenticated developer's own account and resources. Requires JWT authentication (<code>Authorization: Bearer &lt;token&gt;</code>).</p> <ul> <li><code>GET /me</code>: Returns the profile information (<code>schemas.DeveloperRead</code>) for the currently authenticated developer.</li> <li><code>POST /me/apikeys</code>: Generates a new programmatic API key (prefixed <code>avreg_</code>) associated with the developer. Optionally takes a <code>description</code> in the request body. Returns the plain text key once along with key metadata (<code>schemas.NewApiKeyResponse</code>).</li> <li><code>GET /me/apikeys</code>: Lists metadata (<code>schemas.ApiKeyRead</code>) for all active programmatic API keys belonging to the developer.</li> <li><code>DELETE /me/apikeys/{key_id}</code>: Deactivates (soft deletes) a specific programmatic API key by its integer <code>key_id</code>. Returns <code>204 No Content</code> on success.</li> </ul>"},{"location":"developer_guide/registry/#agent-cards-apiv1agent-cards","title":"Agent Cards (<code>/api/v1/agent-cards</code>)","text":"<p>Endpoints for managing and discovering Agent Cards.</p> <ul> <li><code>POST /</code>:<ul> <li>Summary: Submit a new Agent Card.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentCardCreate</code> (contains the <code>card_data</code> dictionary).</li> <li>Response: <code>schemas.AgentCardRead</code> (includes generated UUID, timestamps, <code>developer_is_verified</code> status).</li> <li>Notes: Validates <code>card_data</code>. Extracts <code>name</code>/<code>description</code> for indexing.</li> </ul> </li> <li><code>GET /</code>:<ul> <li>Summary: List Agent Cards (Summaries).</li> <li>Auth: Public, unless <code>owned_only=true</code> is used (requires JWT).</li> <li>Query Params: <code>skip</code>, <code>limit</code>, <code>active_only</code>, <code>search</code>, <code>tags</code>, <code>has_tee</code>, <code>tee_type</code>, <code>owned_only</code>.</li> <li>Response: <code>schemas.AgentCardListResponse</code> (contains <code>items: List[AgentCardSummary]</code> and <code>pagination: PaginationInfo</code>).</li> </ul> </li> <li><code>GET /{card_id}</code>:<ul> <li>Summary: Get Agent Card by UUID.</li> <li>Auth: Public.</li> <li>Response: <code>schemas.AgentCardRead</code> (full card details, including <code>developer_is_verified</code>).</li> </ul> </li> <li><code>GET /id/{human_readable_id:path}</code>:<ul> <li>Summary: Get Agent Card by Human-Readable ID.</li> <li>Auth: Public.</li> <li>Path Param: <code>human_readable_id</code> (e.g., <code>my-org/my-agent</code>). The <code>:path</code> allows slashes.</li> <li>Response: <code>schemas.AgentCardRead</code>.</li> </ul> </li> <li><code>PUT /{card_id}</code>:<ul> <li>Summary: Update an Agent Card.</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Request Body: <code>schemas.AgentCardUpdate</code> (can contain <code>card_data</code> and/or <code>is_active</code>). If <code>card_data</code> is present, it replaces the existing card data after validation.</li> <li>Response: <code>schemas.AgentCardRead</code> (updated card details).</li> </ul> </li> <li><code>DELETE /{card_id}</code>:<ul> <li>Summary: Deactivate an Agent Card (Soft Delete).</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Response: <code>204 No Content</code>.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#agent-builder-agent-builder","title":"Agent Builder (<code>/agent-builder</code>)","text":"<p>Endpoint for generating agent boilerplate code.</p> <ul> <li><code>POST /generate</code>:<ul> <li>Summary: Generate Agent Package.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentBuildConfig</code> (specifies agent name, description, type, backend details, etc.).</li> <li>Response: <code>200 OK</code> with <code>Content-Type: application/zip</code>. The response body is a downloadable ZIP archive containing the generated agent project structure (source code, Dockerfile, config files).</li> <li>Errors: 422 (invalid build config), 500 (generation error).</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#utilities-apiv1utils","title":"Utilities (<code>/api/v1/utils</code>)","text":"<p>Helper endpoints.</p> <ul> <li><code>POST /validate-card</code>:<ul> <li>Summary: Validate Agent Card Data.</li> <li>Auth: Public.</li> <li>Request Body: <code>schemas.AgentCardValidationRequest</code>.</li> <li>Response: <code>schemas.AgentCardValidationResponse</code> (indicates validity and provides details on errors).</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#common-error-responses","title":"Common Error Responses","text":"<p>(See previous version or main documentation - standard HTTP codes like 401, 403, 404, 422, 500)</p>"},{"location":"developer_guide/server_sdk/","title":"Developer Guide: Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>The <code>agentvault-server-sdk</code> provides tools and abstractions to simplify the development of A2A-compliant agent servers in Python, particularly when using the FastAPI web framework. It helps you focus on your agent's core logic while the SDK handles much of the A2A protocol boilerplate.</p>"},{"location":"developer_guide/server_sdk/#installation","title":"Installation","text":"<p>Install the SDK from PyPI:</p> <p><pre><code>pip install agentvault-server-sdk\n</code></pre> (Note: This automatically installs the <code>agentvault</code> client library as a dependency).</p> <p>See the main Installation Guide for more details, including setting up a development environment to run from source.</p>"},{"location":"developer_guide/server_sdk/#core-concepts","title":"Core Concepts","text":"<p>The SDK revolves around implementing an agent logic class (inheriting from <code>BaseA2AAgent</code>) and integrating it with a web framework (currently FastAPI).</p>"},{"location":"developer_guide/server_sdk/#1-basea2aagent-agentpy","title":"1. <code>BaseA2AAgent</code> (<code>agent.py</code>)","text":"<p>This is the abstract base class your agent logic should inherit from.</p> <ul> <li>Purpose: Defines the standard interface the A2A protocol expects an agent server to fulfill.</li> <li>Required Methods: If you are not using the <code>@a2a_method</code> decorator for all standard methods, you must implement these <code>async</code> methods in your subclass:<ul> <li><code>handle_task_send(task_id: Optional[str], message: Message) -&gt; str</code>: Processes incoming messages (<code>tasks/send</code> JSON-RPC method). Should handle task creation or updates and return the task ID.</li> <li><code>handle_task_get(task_id: str) -&gt; Task</code>: Retrieves the full state (<code>Task</code> model) of a specific task (<code>tasks/get</code> JSON-RPC method).</li> <li><code>handle_task_cancel(task_id: str) -&gt; bool</code>: Attempts to cancel a task (<code>tasks/cancel</code> JSON-RPC method), returning <code>True</code> if the request is accepted.</li> <li><code>handle_subscribe_request(task_id: str) -&gt; AsyncGenerator[A2AEvent, None]</code>: Returns an async generator yielding <code>A2AEvent</code> objects for SSE streaming (<code>tasks/sendSubscribe</code> JSON-RPC method). The SDK router consumes this generator.</li> </ul> </li> <li>Alternative (<code>@a2a_method</code>): For agents handling only specific or custom methods, or if you prefer a decorator-based approach, you can use the <code>@a2a_method</code> decorator on individual methods instead of implementing all <code>handle_...</code> methods (see below).</li> </ul>"},{"location":"developer_guide/server_sdk/#2-task-state-management-statepy","title":"2. Task State Management (<code>state.py</code>)","text":"<p>Handling asynchronous tasks requires managing their state (Submitted, Working, Completed, etc.) and potentially associated data (messages, artifacts). The SDK provides tools for this.</p> <ul> <li><code>TaskContext</code>: A basic dataclass holding <code>task_id</code>, <code>current_state</code>, <code>created_at</code>, <code>updated_at</code>. You can subclass this to store agent-specific task data.     <pre><code># Example of extending TaskContext\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom agentvault.models import Message, Artifact\nfrom agentvault_server_sdk.state import TaskContext\n\n@dataclass\nclass MyAgentTaskContext(TaskContext):\n    conversation_history: List[Message] = field(default_factory=list)\n    generated_artifacts: List[Artifact] = field(default_factory=list)\n    # Add other fields your agent needs to track per task\n</code></pre></li> <li><code>BaseTaskStore</code>: An abstract base class defining the interface for storing, retrieving, updating, and deleting <code>TaskContext</code> objects (e.g., <code>create_task</code>, <code>get_task</code>, <code>update_task_state</code>, <code>delete_task</code>). It also defines the interface for managing SSE event listeners (<code>add_listener</code>, <code>remove_listener</code>) and notifying them (<code>notify_status_update</code>, <code>notify_message_event</code>, <code>notify_artifact_event</code>).</li> <li><code>InMemoryTaskStore</code>: A simple, non-persistent dictionary-based implementation of <code>BaseTaskStore</code>. Suitable only for development or single-instance agents where task state loss on restart is acceptable. Production agents typically require implementing a custom <code>BaseTaskStore</code> backed by a persistent database (SQL, NoSQL) or a distributed cache (Redis).</li> <li>Notification Helpers: When using a <code>BaseTaskStore</code> implementation (like <code>InMemoryTaskStore</code> or your own), your agent logic (e.g., background processing tasks) should call methods like <code>task_store.notify_status_update(...)</code>, <code>task_store.notify_message_event(...)</code>, <code>task_store.notify_artifact_event(...)</code> whenever a relevant event occurs (e.g., state change, message generation, artifact creation). The <code>create_a2a_router</code> integration uses these notifications to automatically format and send the correct SSE events to subscribed clients via the <code>handle_subscribe_request</code> stream.</li> </ul>"},{"location":"developer_guide/server_sdk/#3-fastapi-integration-fastapi_integrationpy","title":"3. FastAPI Integration (<code>fastapi_integration.py</code>)","text":"<p>The <code>create_a2a_router</code> function bridges your agent logic (either a <code>BaseA2AAgent</code> subclass or a class using <code>@a2a_method</code>) with the FastAPI web framework.</p> <ul> <li>Purpose: Creates a FastAPI <code>APIRouter</code> that automatically exposes the standard A2A JSON-RPC methods (<code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>) and routes them to your agent implementation's corresponding <code>handle_...</code> methods or decorated methods. It also handles JSON-RPC request parsing, basic validation, and SSE stream setup.</li> <li>Authentication: Note that authentication (e.g., checking <code>X-Api-Key</code> or <code>Authorization</code> headers) is typically handled before the request reaches the A2A router, usually via FastAPI Dependencies applied to the router or the main app. The SDK router itself does not perform authentication checks.</li> <li> <p>Usage: The following steps outline how to integrate the router into your FastAPI application:</p> <ol> <li> <p>Instantiate Agent and Task Store: <pre><code>from fastapi import FastAPI\nfrom agentvault_server_sdk import BaseA2AAgent\nfrom agentvault_server_sdk.state import InMemoryTaskStore # Or your custom store\n# Import your agent class\nfrom my_agent_logic import MyAgent\n\ntask_store = InMemoryTaskStore()\nmy_agent_instance = MyAgent(task_store_ref=task_store) # Pass store if needed\n</code></pre></p> </li> <li> <p>Create the A2A Router: Pass the agent instance and the task store to the factory function.     <pre><code>from agentvault_server_sdk import create_a2a_router\n\na2a_router = create_a2a_router(\n    agent=my_agent_instance,\n    task_store=task_store # Required for SSE notifications\n)\n</code></pre></p> </li> <li> <p>Create FastAPI App and Include Router: Mount the router at your desired prefix (typically <code>/a2a</code>).     <pre><code>app = FastAPI(title=\"My A2A Agent\")\napp.include_router(a2a_router, prefix=\"/a2a\") # Mount at standard /a2a path\n</code></pre></p> </li> <li> <p>Add Exception Handlers (CRITICAL): You must add the SDK's exception handlers to your main FastAPI <code>app</code> instance. These handlers translate internal Python exceptions raised by your agent or the SDK (like <code>TaskNotFoundError</code>, <code>ValueError</code>, <code>AgentServerError</code>) into correctly formatted JSON-RPC error responses that clients expect. Without these, clients will receive generic HTTP 500 errors instead of specific, actionable JSON-RPC errors.     <pre><code>from fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError as PydanticValidationError\n# from pydantic_core import ValidationError as PydanticValidationError # If using Pydantic v2\nfrom agentvault_server_sdk.exceptions import AgentServerError, TaskNotFoundError\nfrom agentvault_server_sdk.fastapi_integration import (\n    task_not_found_handler, validation_exception_handler,\n    agent_server_error_handler, generic_exception_handler\n)\n\n# Assuming 'app' is your FastAPI instance from step 3\napp.add_exception_handler(TaskNotFoundError, task_not_found_handler)\napp.add_exception_handler(ValueError, validation_exception_handler)\napp.add_exception_handler(TypeError, validation_exception_handler)\napp.add_exception_handler(PydanticValidationError, validation_exception_handler)\napp.add_exception_handler(AgentServerError, agent_server_error_handler)\napp.add_exception_handler(Exception, generic_exception_handler) # Catch-all\n</code></pre></p> </li> </ol> </li> </ul>"},{"location":"developer_guide/server_sdk/#4-a2a-method-decorator-a2a_method","title":"4. A2A Method Decorator (<code>@a2a_method</code>)","text":"<p>An alternative or supplement to implementing the full <code>BaseA2AAgent</code> interface.</p> <ul> <li>Purpose: Expose individual <code>async def</code> methods within your agent class as specific JSON-RPC methods. Useful for simpler agents, custom methods beyond the standard A2A set, or overriding specific standard methods with custom logic.</li> <li>Usage: <pre><code>from agentvault_server_sdk import BaseA2AAgent, a2a_method\nfrom agentvault.models import Task # Example import\n\nclass DecoratedAgent(BaseA2AAgent): # Still inherit for structure\n\n    @a2a_method(\"custom/ping\")\n    async def ping_handler(self) -&gt; str:\n        # No parameters needed\n        return \"pong\"\n\n    @a2a_method(\"tasks/get\") # Override standard method\n    async def custom_get_task(self, task_id: str) -&gt; Task: # Params validated from type hints\n        # ... custom logic to fetch task ...\n        task_data = await get_my_task_data(task_id)\n        # Return value validated against type hint\n        return Task(**task_data)\n\n    # If using only decorators for standard methods, you don't *need*\n    # to implement the corresponding handle_ methods. The router will\n    # prioritize decorated methods and return \"Method not found\" for others.\n</code></pre></li> <li>Validation: The <code>create_a2a_router</code> automatically validates incoming JSON-RPC <code>params</code> against the decorated function's type hints (using Pydantic internally). If validation fails (e.g., client sends wrong type for <code>task_id</code>), a <code>ValueError</code> or <code>PydanticValidationError</code> will likely be raised, which should be caught by the <code>validation_exception_handler</code> registered on the FastAPI app, returning a JSON-RPC <code>Invalid Params</code> error. The return value is also validated against the function's return type hint.</li> </ul>"},{"location":"developer_guide/server_sdk/#5-packaging-tool-agentvault-sdk-package-packagerclipy","title":"5. Packaging Tool (<code>agentvault-sdk package</code>) (<code>packager/cli.py</code>)","text":"<p>A CLI tool to help prepare your agent project for deployment, typically via Docker.</p> <ul> <li>Command: <code>agentvault-sdk package [OPTIONS]</code></li> <li>Functionality: Generates a standard multi-stage <code>Dockerfile</code>, a <code>.dockerignore</code> file, and copies <code>requirements.txt</code> and optionally <code>agent-card.json</code> to a specified output directory, ready for <code>docker build</code>.</li> <li>Key Options:<ul> <li><code>--output-dir DIRECTORY</code> / <code>-o DIRECTORY</code>: (Required) Directory to write Dockerfile and other artifacts.</li> <li><code>--entrypoint TEXT</code>: (Required) Python import path to the FastAPI app instance (e.g., <code>my_agent.main:app</code>).</li> <li><code>--python TEXT</code>: Python version for the base image tag (e.g., 3.10, 3.11). [default: 3.11]</li> <li><code>--suffix TEXT</code>: Suffix for the python base image (e.g., slim-bookworm, alpine). [default: slim-bookworm]</li> <li><code>--port INTEGER</code>: Port the application will listen on inside the container. [default: 8000]</li> <li><code>--requirements PATH</code> / <code>-r PATH</code>: Path to the requirements.txt file. If not provided, it looks for <code>./requirements.txt</code> in the current directory and copies it if found. Issues a warning if the SDK dependency seems missing.</li> <li><code>--agent-card PATH</code> / <code>-c PATH</code>: Path to the agent-card.json file. If provided, it will be copied into the output directory.</li> <li><code>--app-dir TEXT</code>: Directory inside the container where the application code will reside. [default: /app]</li> </ul> </li> <li>Example: <pre><code># Assuming FastAPI app is in src/my_agent/main.py as 'app'\n# and requirements.txt / agent-card.json are in the current directory\nagentvault-sdk package \\\n    --output-dir ./build \\\n    --entrypoint my_agent.main:app \\\n    --requirements ./requirements.txt \\\n    --agent-card ./agent-card.json \\\n    --python 3.11\n\n# Then build the image from the project root:\n# docker build -t my-agent-image:latest -f ./build/Dockerfile .\n</code></pre></li> </ul>"},{"location":"developer_guide/server_sdk/#building-a-basic-agent-conceptual-steps","title":"Building a Basic Agent (Conceptual Steps)","text":"<ol> <li>Define Agent Logic: Create a class inheriting from <code>BaseA2AAgent</code> (or use decorators).</li> <li>Implement Handlers/Methods: Implement the required <code>async handle_...</code> methods (or decorate specific methods) to handle A2A requests.</li> <li>Manage State: Choose or implement a <code>BaseTaskStore</code> (start with <code>InMemoryTaskStore</code> for development). Pass it to your agent instance. Crucially, call <code>task_store.notify_...</code> methods from your agent's background processing logic (e.g., the code handling the actual work initiated by <code>handle_task_send</code>) to send SSE updates to subscribed clients.</li> <li>Create FastAPI App: Set up a standard FastAPI application (<code>main.py</code>).</li> <li>Instantiate Agent &amp; Store: Create instances of your agent class and task store.</li> <li>Create &amp; Include Router: Use <code>create_a2a_router(agent=..., task_store=...)</code> and include the returned router in your FastAPI app (e.g., at prefix <code>/a2a</code>).</li> <li>Add Exception Handlers: Add the required SDK exception handlers (<code>task_not_found_handler</code>, etc.) to your main FastAPI app instance using <code>app.add_exception_handler(...)</code>.</li> <li>Create Agent Card: Write an <code>agent-card.json</code> describing your agent, ensuring the <code>url</code> points to your FastAPI A2A endpoint (e.g., <code>http://your-host/a2a</code>). Include appropriate <code>authSchemes</code>.</li> <li>Run: Use <code>uvicorn main:app --host ... --port ...</code>.</li> <li>(Optional) Package: Use <code>agentvault-sdk package</code> to generate Docker artifacts for deployment.</li> </ol> <p>Refer to the Basic A2A Server Example for a complete, runnable implementation.</p>"},{"location":"developer_guide/testing/","title":"Developer Guide: Testing Utilities (<code>agentvault-testing-utils</code>)","text":"<p>The <code>agentvault-testing-utils</code> package is an internal development tool providing shared mocks, pytest fixtures, data factories, and helper functions. Its purpose is to streamline and standardize testing across the different AgentVault components (<code>agentvault_library</code>, <code>agentvault_cli</code>, <code>agentvault_registry</code>, <code>agentvault_server_sdk</code>).</p> <p>Note: This package is not intended for end-users or for distribution on PyPI. It's used within the AgentVault monorepo's development workflow.</p>"},{"location":"developer_guide/testing/#installation","title":"Installation","text":"<p>This package is installed as a development dependency when setting up the main project environment using Poetry:</p> <pre><code># From the monorepo root (AgentVault/)\npoetry install --with dev\n</code></pre>"},{"location":"developer_guide/testing/#provided-utilities","title":"Provided Utilities","text":""},{"location":"developer_guide/testing/#1-mocks-mockspy","title":"1. Mocks (<code>mocks.py</code>)","text":"<ul> <li><code>MockAgentVaultClient</code>:<ul> <li>Purpose: A mock implementation of <code>agentvault.client.AgentVaultClient</code>. Use this in tests for components that use the client library (like the CLI or potentially other agents) to simulate A2A interactions without making real network calls.</li> <li>Features:<ul> <li>Configurable return values for async methods (e.g., <code>mock_client.initiate_task_return_value = \"task-abc\"</code>).</li> <li>Configurable side effects (exceptions) for async methods (e.g., <code>mock_client.get_task_status_side_effect = A2AConnectionError(\"Mock connection failed\")</code>).</li> <li>Call recording via the <code>mock_client.call_recorder</code> attribute (an <code>unittest.mock.AsyncMock</code> instance). Use standard <code>assert_awaited_once_with</code>, <code>assert_has_calls</code>, etc. on this recorder.</li> <li>Supports async context management (<code>async with mock_client:</code>).</li> </ul> </li> <li>Example: <pre><code>import pytest\nfrom unittest.mock import call, ANY # Import ANY for flexible matching\nfrom agentvault_testing_utils.mocks import MockAgentVaultClient\nfrom agentvault.models import Task, TaskState # Assuming Task model exists\nfrom agentvault.exceptions import A2AConnectionError\n\n@pytest.mark.asyncio\nasync def test_cli_run_logic(mocker): # Assuming pytest-mock 'mocker' fixture\n    # --- Setup ---\n    mock_client = MockAgentVaultClient()\n    # Patch the location where AgentVaultClient is instantiated in the code under test\n    mocker.patch('agentvault_cli.commands.run.AgentVaultClient', return_value=mock_client)\n\n    # Configure mock behavior\n    mock_client.initiate_task_return_value = \"task-from-mock\"\n    # Create a mock Task object or use a real one if needed\n    mock_task_result = MagicMock(spec=Task)\n    mock_task_result.state = TaskState.COMPLETED\n    mock_client.get_task_status_return_value = mock_task_result\n\n    # --- Action ---\n    # Execute the function or command that uses the AgentVaultClient\n    # e.g., await run_cli_command_logic(...)\n\n    # --- Assertions ---\n    # Check initiate_task was called correctly\n    mock_client.call_recorder.initiate_task.assert_awaited_once_with(\n        agent_card=ANY, initial_message=ANY, key_manager=ANY,\n        mcp_context=None, webhook_url=None # Check default args if needed\n    )\n    # Check get_task_status was called with the ID returned by initiate_task\n    mock_client.call_recorder.get_task_status.assert_awaited_with(\n         agent_card=ANY, task_id=\"task-from-mock\", key_manager=ANY\n    )\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#2-mock-server-fixtures-mock_serverpy-fixturespy","title":"2. Mock Server &amp; Fixtures (<code>mock_server.py</code>, <code>fixtures.py</code>)","text":"<ul> <li> <p><code>mock_a2a_server</code> (Pytest Fixture):</p> <ul> <li>Purpose: Provides a more realistic testing environment by mocking the HTTP endpoints of an A2A agent server (<code>/a2a</code>) and its associated OAuth token endpoint (<code>/token</code>) using <code>respx</code>. Useful for testing the <code>AgentVaultClient</code> itself or components that make real HTTP requests to agents.</li> <li>Features:<ul> <li>Sets up <code>respx</code> routes for <code>POST /a2a</code> and <code>POST /token</code> at a test URL.</li> <li>Handles basic JSON-RPC routing for standard A2A methods (<code>tasks/send</code>, <code>get</code>, <code>cancel</code>, <code>sendSubscribe</code>).</li> <li>Simulates basic task state via an in-memory <code>task_store</code> dictionary accessible from the fixture. You can pre-populate this store in your test.</li> <li>Simulates SSE streaming for <code>tasks/sendSubscribe</code> based on an <code>sse_event_store</code> list accessible from the fixture. You pre-populate this list with the <code>A2AEvent</code> objects you want the mock server to stream back.</li> <li>Provides the <code>base_url</code> of the mock server.</li> </ul> </li> <li>Return Type: <code>MockServerInfo</code> (NamedTuple) with fields:<ul> <li><code>base_url</code> (str): The base URL of the mock server (e.g., <code>https://mock-a2a-agent.test</code>).</li> <li><code>task_store</code> (Dict[str, Dict]): Dictionary mapping task IDs to their simple state dict (e.g., <code>{'state': TaskState.WORKING}</code>).</li> <li><code>sse_event_store</code> (Dict[str, List[A2AEvent]]): Dictionary mapping task IDs to a list of <code>A2AEvent</code> objects to be yielded by the mock SSE stream.</li> </ul> </li> <li>Example: <pre><code>import pytest\nimport httpx\nfrom agentvault_testing_utils.fixtures import mock_a2a_server, MockServerInfo\n# Import necessary models\nfrom agentvault.models import TaskState, TaskStatusUpdateEvent, Message, TextPart\nfrom agentvault.client import AgentVaultClient # Import the real client\nimport datetime\n\n@pytest.mark.asyncio\nasync def test_client_get_status_against_mock_server(mock_a2a_server: MockServerInfo, mocker):\n    # --- Setup Mock Server State ---\n    task_id = \"live-test-task-get\"\n    # Pre-populate the task store the mock server will use\n    mock_a2a_server.task_store[task_id] = {\"state\": TaskState.WORKING}\n\n    # --- Action ---\n    # Use the real AgentVaultClient against the mock server's URL\n    mock_card = mocker.MagicMock() # Mock the card\n    mock_card.url = f\"{mock_a2a_server.base_url}/a2a\"\n    mock_card.auth_schemes = [] # Assume no auth for simplicity\n\n    async with AgentVaultClient() as client:\n         # This call will hit the respx route set up by the fixture\n         task_details = await client.get_task_status(\n             agent_card=mock_card,\n             task_id=task_id,\n             key_manager=mocker.MagicMock() # Mock key manager\n         )\n\n    # --- Assertions ---\n    assert task_details.id == task_id\n    assert task_details.state == TaskState.WORKING # Check state returned by mock\n</code></pre></li> </ul> </li> <li> <p><code>setup_mock_a2a_routes</code>: The underlying function used by the <code>mock_a2a_server</code> fixture to configure <code>respx</code> routes. Can be used directly for more complex or custom mock server setups outside the fixture.</p> </li> <li>JSON-RPC Helpers: <code>create_jsonrpc_success_response</code>, <code>create_jsonrpc_error_response</code> for constructing standard JSON-RPC response dictionaries in custom mock handlers.</li> </ul>"},{"location":"developer_guide/testing/#3-factories-factoriespy","title":"3. Factories (<code>factories.py</code>)","text":"<ul> <li><code>create_test_agent_card(**overrides)</code>:<ul> <li>Purpose: Generates <code>agentvault.models.AgentCard</code> Pydantic model instances with sensible default values. Simplifies creating valid test data for agent cards.</li> <li>Features: Accepts keyword arguments to override any top-level or nested field in the default card structure (uses deep merging for nested dicts). Performs validation using the actual <code>AgentCard</code> model.</li> <li>Example: <pre><code>from agentvault_testing_utils.factories import create_test_agent_card\n\n# Create a card with default values\ndefault_card = create_test_agent_card()\n\n# Create a card overriding name and adding an OAuth scheme\ncustom_card = create_test_agent_card(\n    name=\"My Custom OAuth Agent\",\n    authSchemes=[ # Overwrites the default 'none' scheme\n        {\"scheme\": \"oauth2\", \"tokenUrl\": \"https://my-agent.test/token\"}\n    ],\n    tags=[\"custom\", \"oauth\"] # Overwrites default tags\n)\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#4-test-agents-agentspy","title":"4. Test Agents (<code>agents.py</code>)","text":"<ul> <li><code>EchoAgent</code>:<ul> <li>Purpose: A minimal, functional implementation of <code>agentvault_server_sdk.BaseA2AAgent</code>. It uses an <code>InMemoryTaskStore</code> to manage state, echoes the first message content back via SSE notification, and transitions through basic states (Submitted -&gt; Working -&gt; Completed).</li> <li>Use Case: Ideal for testing the Server SDK's <code>create_a2a_router</code>, basic A2A client interactions, and SSE streaming logic without needing a complex real agent implementation. Useful for end-to-end tests of the client library or CLI against a basic functional agent.</li> <li>Example (Testing SDK Router): See the Server SDK Developer Guide or the Basic A2A Server Example.</li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#5-assertion-helpers-assertionspy","title":"5. Assertion Helpers (<code>assertions.py</code>)","text":"<ul> <li>Purpose: Provide convenient functions for asserting that specific A2A JSON-RPC calls were made, simplifying tests that interact with <code>MockAgentVaultClient</code> or <code>respx</code>.</li> <li>Key Functions:<ul> <li><code>assert_a2a_call(mock_calls, method, params_contain=None, req_id=None)</code>: Checks if any call in the provided list (<code>httpx.Request</code> list from <code>respx.calls</code> or <code>MagicMock.call_args_list</code> from <code>MockAgentVaultClient.call_recorder</code>) matches the specified JSON-RPC <code>method</code>, optional <code>req_id</code>, and optionally contains the key-value pairs in <code>params_contain</code> within its <code>params</code> object (performs a subset check).</li> <li><code>assert_a2a_sequence(mock_calls, expected_sequence)</code>: Checks if the sequence of parseable A2A calls matches the <code>expected_sequence</code> (a list of <code>(method, params_contain)</code> tuples). Ignores non-JSON-RPC calls in the list.</li> <li>Example: <pre><code>from agentvault_testing_utils.assertions import assert_a2a_call, assert_a2a_sequence\nfrom unittest.mock import call # For sequence assertion with MagicMock\n\n# --- Using MockAgentVaultClient ---\n# await mock_client.initiate_task(...)\n# await mock_client.get_task_status(task_id=\"task-123\", ...)\n\n# Assert a specific call was made (anywhere in the list)\nassert_a2a_call(\n    mock_client.call_recorder.call_args_list, # Pass the call list\n    method=\"tasks/get\",\n    params_contain={\"id\": \"task-123\"}\n)\n\n# Assert the exact sequence of calls\nexpected_seq = [\n    (\"initiate_task\", None), # Use the Python method name for MagicMock recorder\n    (\"get_task_status\", {\"task_id\": \"task-123\"}) # Use Python param names\n]\n# Note: assert_a2a_sequence expects JSON-RPC method names in the sequence definition\n# Adjust if using MagicMock recorder directly vs parsing httpx requests.\n# Example below assumes parsing logic handles method name mapping if needed.\nexpected_rpc_seq = [\n     (\"tasks/send\", None), # Assuming initiate_task maps to tasks/send\n     (\"tasks/get\", {\"id\": \"task-123\"})\n]\n# assert_a2a_sequence(mock_client.call_recorder.call_args_list, expected_rpc_seq)\n\n\n# --- Using respx ---\n# with respx.mock:\n#     # setup routes...\n#     # await http_client.post(url, json=payload1)\n#     # await http_client.post(url, json=payload2)\n\n# Assert a specific call was made\nassert_a2a_call(\n    respx.calls, # Pass the list of httpx.Request objects\n    method=\"tasks/send\",\n    params_contain={\"message\": {\"role\": \"user\"}}\n)\n\n# Assert the sequence\nexpected_respx_seq = [\n    (\"tasks/send\", {\"id\": None}),\n    (\"tasks/get\", {\"id\": \"task-abc\"})\n]\nassert_a2a_sequence(respx.calls, expected_respx_seq)\n</code></pre></li> </ul> </li> </ul>"},{"location":"examples/","title":"AgentVault Examples","text":"<p>This section provides practical examples demonstrating how to use AgentVault and its components to build various multi-agent systems and integrations.</p>"},{"location":"examples/#core-concepts-examples","title":"Core Concepts Examples","text":"<p>These examples illustrate specific features of the AgentVault client library (<code>agentvault</code>) and the server SDK (<code>agentvault-server-sdk</code>).</p> <ul> <li>Basic A2A Server: Shows the minimal setup for creating an A2A-compliant agent using FastAPI and the Server SDK. Demonstrates handling <code>tasks/send</code>, <code>get</code>, <code>cancel</code>, and <code>subscribe</code>.</li> <li>Direct Library Usage: Illustrates how to use the <code>AgentVaultClient</code> directly in Python to interact with an A2A agent, including task initiation and SSE event streaming.</li> <li>OAuth2 Authenticated Agent: Demonstrates building an agent server that requires OAuth2 Client Credentials flow for authentication, including a mock token endpoint and protecting the A2A endpoint.</li> <li>Stateful Agent: Shows how to build an agent that maintains state across multiple interactions within a single task lifecycle using the SDK's task store concepts.</li> <li>Simple Communication Agents: Covers agents like the Task Logger, Registry Query (LLM Test Mode), and Simple Summary Agent, showcasing basic database interaction, LLM integration, and simple agent-to-agent calls.</li> </ul>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":"<ul> <li>LangChain Tool Integration: Provides a template for wrapping an AgentVault A2A agent as a custom tool within the LangChain framework.</li> </ul>"},{"location":"examples/#end-to-end-pipeline-pocs","title":"End-to-End Pipeline POCs","text":"<p>These Proof-of-Concept (POC) pipelines demonstrate how multiple specialized agents can collaborate to solve more complex problems using AgentVault orchestration principles.</p> <ul> <li>Research Pipeline: A sophisticated pipeline orchestrating 7 agents (topic research, crawling, extraction, verification, synthesis, editing, visualization) to generate comprehensive research reports on a given topic. Demonstrates complex workflow, artifact passing, and local artifact storage. (Uses LangGraph for orchestration).</li> <li>Support Ticket Pipeline: Orchestrates 4 agents (ticket analysis, KB search, customer history, response suggestion) to process customer support tickets and suggest responses. Showcases integrating different data sources. (Uses LangGraph for orchestration).</li> <li>Dynamics 365 Pipeline: A pipeline simulating integration with Dynamics 365 data. It involves fetching data, enrichment, health analysis, action recommendation, briefing generation, and task creation/notification execution. Demonstrates rule-based analysis, LLM usage, and executing actions based on insights. (Uses LangGraph for orchestration).</li> <li>E-commerce Pipeline: Orchestrates agents for user profiling, product catalog lookup, trend analysis, and recommendation generation to provide personalized e-commerce suggestions. (Uses LangGraph for orchestration).</li> <li>ETL Pipeline: Demonstrates an Extract, Transform, Load workflow using multiple agents and a database for artifact storage between steps. (Uses LangGraph for orchestration).</li> <li>MCP Test Pipeline: Showcases the Model Context Protocol (MCP) by using a proxy agent to interact with MCP-compliant tool servers (filesystem, code runner) for executing specific operations. (Uses LangGraph for orchestration).</li> </ul>"},{"location":"examples/basic_a2a_server/","title":"AgentVault Server SDK - Basic A2A Server Example","text":"<p>This example demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/basic_a2a_server/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>main.py</code>:<ul> <li>Defines a simple <code>MySimpleAgent</code> class inheriting from <code>BaseA2AAgent</code>.</li> <li>Implements basic logic for the required A2A methods (<code>handle_task_send</code>, <code>handle_task_get</code>, <code>handle_task_cancel</code>, <code>handle_subscribe_request</code>).</li> <li>Uses the SDK's <code>create_a2a_router</code> to automatically generate the <code>/a2a</code> JSON-RPC endpoint.</li> <li>Includes necessary FastAPI exception handlers required by the router.</li> <li>Sets up a FastAPI application.</li> <li>Serves the agent's <code>agent-card.json</code> at <code>/agent-card.json</code>.</li> <li>Includes a <code>uvicorn</code> runner block.</li> </ul> </li> <li><code>agent-card.json</code>: A minimal, valid Agent Card describing this example agent.</li> </ul>"},{"location":"examples/basic_a2a_server/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/basic_a2a_server</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements. This will install the local SDK package.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This assumes the <code>agentvault-server-sdk</code> and <code>agentvault_library</code> directories are located correctly relative to this example as specified in <code>requirements.txt</code>. Adjust the <code>-e ../../...</code> paths if your structure differs.</li> </ol>"},{"location":"examples/basic_a2a_server/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <pre><code>uvicorn main:app --reload --port 8000\n</code></pre> <ul> <li><code>--reload</code>: Enables auto-reloading when code changes (useful for development).</li> <li><code>--port 8000</code>: Specifies the port to run on (matches the default <code>url</code> in <code>agent-card.json</code>).</li> </ul> <p>You should see Uvicorn startup messages indicating the server is running on <code>http://127.0.0.1:8000</code>.</p>"},{"location":"examples/basic_a2a_server/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Once the server is running, you can interact with it using the <code>agentvault-cli</code>:</p> <ol> <li> <p>Check Agent Card: Open <code>http://localhost:8000/agent-card.json</code> in your browser or use <code>curl</code> to verify the card is served correctly.</p> </li> <li> <p>Run a Task: Use the <code>agentvault run</code> command, pointing the <code>--agent</code> flag to the card URL.     <pre><code>agentvault run --agent http://localhost:8000/agent-card.json --input \"Hello SDK Agent!\"\n</code></pre></p> </li> </ol> <p>You should see output similar to this:</p> <pre><code>SUCCESS: Successfully loaded agent: SDK Basic Echo Agent (examples/simple-agent)\nINFO: Agent A2A Endpoint: http://localhost:8000/a2a\nINFO: Initiating task with agent...\nSUCCESS: Task initiated successfully. Task ID: simple-xxxxxxxx\nINFO: Waiting for events... (Press Ctrl+C to request cancellation)\nINFO: Task Status: WORKING\n\u250c Message from Assistant \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Echo: Hello SDK Agent!                                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nINFO: Task Status: COMPLETED\nINFO: Task reached terminal state.\nINFO: --------------------\nINFO: Final Task State: COMPLETED\nSUCCESS: Task completed.\n</code></pre> <p>This confirms the CLI can load the card, initiate a task via the SDK-generated router, stream the status updates and the echo message, and recognize task completion.</p>"},{"location":"examples/basic_agents/","title":"Basic Agent Examples","text":"<p>This page covers several simpler agents designed to demonstrate fundamental concepts and specific features of the AgentVault libraries and SDK.</p>"},{"location":"examples/basic_agents/#overview","title":"Overview","text":"<p>These examples focus on:</p> <ul> <li>Basic agent server setup.</li> <li>Direct client library usage.</li> <li>Authentication mechanisms.</li> <li>State management within an agent.</li> <li>Simple agent-to-agent communication.</li> <li>Basic database interaction.</li> <li>Local LLM integration.</li> </ul>"},{"location":"examples/basic_agents/#examples","title":"Examples","text":""},{"location":"examples/basic_agents/#1-basic-a2a-server","title":"1. Basic A2A Server","text":"<ul> <li>Location: <code>docs/examples/basic_a2a_server.md</code> (links to code in <code>examples/basic_a2a_server</code>)</li> <li>Purpose: Demonstrates the absolute minimal setup required to create an A2A-compliant agent server using FastAPI and the <code>agentvault-server-sdk</code>.</li> <li>Features:<ul> <li>Inherits from <code>BaseA2AAgent</code>.</li> <li>Implements basic handlers for <code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, and <code>tasks/sendSubscribe</code>.</li> <li>Uses <code>create_a2a_router</code> for automatic endpoint generation.</li> <li>Includes necessary FastAPI exception handlers.</li> <li>Serves a minimal <code>agent-card.json</code>.</li> </ul> </li> <li>Key Takeaway: Foundation for building any custom A2A agent.</li> </ul>"},{"location":"examples/basic_agents/#2-direct-library-usage","title":"2. Direct Library Usage","text":"<ul> <li>Location: <code>docs/examples/library_usage_example.md</code> (links to code in <code>examples/library_usage_example</code>)</li> <li>Purpose: Shows how to use the <code>agentvault</code> client library (<code>AgentVaultClient</code>, <code>KeyManager</code>) directly in a Python script to interact with an A2A agent without the CLI.</li> <li>Features:<ul> <li>Loading an <code>AgentCard</code>.</li> <li>Instantiating <code>KeyManager</code> (for potential auth).</li> <li>Using <code>AgentVaultClient</code> within an <code>async with</code> block.</li> <li>Calling <code>initiate_task</code>.</li> <li>Streaming and processing events using <code>receive_messages</code>.</li> <li>Basic exception handling.</li> </ul> </li> <li>Key Takeaway: How to programmatically control agent interactions from Python code.</li> </ul>"},{"location":"examples/basic_agents/#3-oauth2-authenticated-agent","title":"3. OAuth2 Authenticated Agent","text":"<ul> <li>Location: <code>docs/examples/oauth_agent_example.md</code> (links to code in <code>examples/oauth_agent_example</code>)</li> <li>Purpose: Demonstrates building an agent server that requires OAuth2 Client Credentials authentication.</li> <li>Features:<ul> <li><code>agent-card.json</code> specifying the <code>oauth2</code> scheme and <code>/token</code> endpoint.</li> <li>Custom <code>/token</code> endpoint implementation in FastAPI to validate mock credentials (loaded from <code>.env</code>).</li> <li>FastAPI dependency (<code>HTTPBearer</code>) to protect the A2A endpoint, ensuring requests have a valid Bearer token.</li> <li>Interaction flow showing how the <code>agentvault</code> client library automatically handles the OAuth2 token exchange when configured correctly using <code>agentvault config set ... --oauth-configure</code>.</li> </ul> </li> <li>Key Takeaway: Implementing and interacting with OAuth2-protected agents.</li> </ul>"},{"location":"examples/basic_agents/#4-stateful-agent","title":"4. Stateful Agent","text":"<ul> <li>Location: <code>docs/examples/stateful_agent_example.md</code> (links to code in <code>examples/stateful_agent_example</code>)</li> <li>Purpose: Shows how to build an agent that maintains state (like conversation history) across multiple interactions within the same task ID.</li> <li>Features:<ul> <li>Uses the SDK's <code>InMemoryTaskStore</code> (or a custom one) to store task-specific context (e.g., <code>ChatTaskContext</code>).</li> <li><code>handle_task_send</code> logic differentiates between initiating a task (creating context) and continuing a task (updating existing context).</li> <li>Uses background processing (e.g., <code>asyncio.Event</code>, <code>asyncio.create_task</code>) to handle ongoing work for a task.</li> <li>Demonstrates interaction using the CLI with the <code>--task-id</code> flag to send subsequent messages.</li> </ul> </li> <li>Key Takeaway: Managing persistent state within a single agent task lifecycle.</li> </ul>"},{"location":"examples/basic_agents/#5-task-logger-agent","title":"5. Task Logger Agent","text":"<ul> <li>Location: <code>poc_agents/task_logger_agent/</code></li> <li>Purpose: A simple agent demonstrating database interaction. It receives text messages via A2A and logs them to a PostgreSQL database table (<code>agent_logs</code>).</li> <li>Features:<ul> <li>Uses <code>asyncpg</code> library for asynchronous PostgreSQL communication.</li> <li>Creates the necessary database table if it doesn't exist.</li> <li>Takes database connection details from environment variables (<code>.env</code> file).</li> <li><code>process_task</code> method handles the database insertion logic.</li> </ul> </li> <li>Key Takeaway: Basic agent interaction with an external database.</li> </ul>"},{"location":"examples/basic_agents/#6-registry-query-agent-llm-test-mode","title":"6. Registry Query Agent (LLM Test Mode)","text":"<ul> <li>Location: <code>poc_agents/registry_query_agent/</code></li> <li>Purpose: Originally intended to query the AgentVault Registry, this agent was temporarily modified to demonstrate interaction with a local LLM (like LM Studio) using an OpenAI-compatible API endpoint. It takes text input and gets a response from the LLM.</li> <li>Features:<ul> <li>Uses <code>httpx</code> to make asynchronous calls to the configured LLM API endpoint (<code>LOCAL_API_BASE_URL</code>).</li> <li>Handles basic OpenAI-compatible request/response structure (<code>/chat/completions</code>).</li> <li>Takes LLM configuration (URL, model name, API key) from environment variables.</li> </ul> </li> <li>Key Takeaway: Integrating agents with local or external LLM APIs.</li> </ul>"},{"location":"examples/basic_agents/#7-simple-summary-agent","title":"7. Simple Summary Agent","text":"<ul> <li>Location: <code>poc_agents/simple_summary_agent/</code></li> <li>Purpose: Similar to the modified Registry Query Agent, this agent focuses specifically on text summarization using a local LLM (configured via environment variables).</li> <li>Features:<ul> <li>Uses <code>httpx</code> for LLM calls.</li> <li>Includes a specific system prompt geared towards summarization.</li> <li>Demonstrates basic LLM interaction for a specific task.</li> </ul> </li> <li>Key Takeaway: Using LLMs within agents for specific NLP tasks.</li> </ul>"},{"location":"examples/basic_agents/#8-query-and-log-agent-orchestrator","title":"8. Query and Log Agent (Orchestrator)","text":"<ul> <li>Location: <code>poc_agents/query_and_log_agent/</code></li> <li>Purpose: A very basic orchestrator agent that demonstrates agent-to-agent communication. It calls the Registry Query Agent (in LLM test mode) and then calls the Task Logger Agent to log the results.</li> <li>Features:<ul> <li>Uses <code>AgentVaultClient</code> to call other agents.</li> <li>Loads target agent URLs/IDs from environment variables.</li> <li>Manages a simple two-step workflow.</li> </ul> </li> <li>Key Takeaway: Fundamental concept of an agent calling other agents to perform a sequence of actions.</li> </ul> <p>These basic examples provide building blocks and illustrate key techniques used in the more complex end-to-end pipeline POCs.</p>"},{"location":"examples/langchain_integration/","title":"AgentVault LangChain Integration Example","text":"<p>This directory contains a basic example demonstrating how to integrate an AgentVault A2A compliant agent as a tool within the LangChain framework.</p>"},{"location":"examples/langchain_integration/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines the necessary Python dependencies (<code>langchain-core</code>, <code>agentvault</code>, <code>httpx</code>).</li> <li><code>a2a_tool.py</code>: Contains the <code>A2AAgentTool</code> class, which inherits from LangChain's <code>BaseTool</code>. This tool handles the interaction with a remote A2A agent using the <code>agentvault</code> client library.</li> <li><code>example_usage.py</code>: A simple script showing how to instantiate and invoke the <code>A2AAgentTool</code>.</li> </ul>"},{"location":"examples/langchain_integration/#setup","title":"Setup","text":"<ol> <li> <p>Install Dependencies: Navigate to this directory (<code>examples/langchain_integration</code>) in your terminal and install the requirements. This includes installing the local <code>agentvault</code> library in editable mode.     <pre><code>pip install -r requirements.txt\n</code></pre> Note: This assumes your virtual environment is activated and you are in the correct directory. The <code>-e ../../agentvault_library</code> line installs the library from your local source tree.</p> </li> <li> <p>Configure Agent Reference: Open <code>example_usage.py</code> and modify the <code>EXAMPLE_AGENT_REF</code> variable to point to a valid agent:</p> <ul> <li>Agent ID: If using an ID from a running AgentVault Registry (e.g., <code>test-org/my-agent</code>), ensure the <code>AGENTVAULT_REGISTRY_URL</code> environment variable is set correctly or modify the default in <code>a2a_tool.py</code>.</li> <li>Agent URL: Provide the direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>Local File: Provide the path to a local <code>agent-card.json</code> file (e.g., <code>./path/to/your/agent-card.json</code>).</li> </ul> </li> <li> <p>Configure Credentials: If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are set up using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card.</p> </li> </ol>"},{"location":"examples/langchain_integration/#running-the-example","title":"Running the Example","text":"<p>Once set up, you can run the example script:</p> <pre><code>python example_usage.py\n</code></pre> <p>The script will:</p> <ol> <li>Instantiate the <code>A2AAgentTool</code>.</li> <li>Prepare the input (agent reference and text prompt).</li> <li>Invoke the tool's <code>_arun</code> method.</li> <li>The tool will internally use <code>AgentVaultClient</code> to:<ul> <li>Load the agent card.</li> <li>Initiate a task.</li> <li>Stream events (though only assistant text messages are captured in this basic example).</li> <li>Wait for the task to complete.</li> </ul> </li> <li>Print the final aggregated text response from the agent.</li> </ol> <p>Note: This example primarily demonstrates the tool's structure and integration. For it to fully succeed, you need a running A2A agent accessible at the specified <code>EXAMPLE_AGENT_REF</code> that can handle the input prompt. You can use the <code>agentvault-server-sdk</code> examples or your own agent implementation.</p>"},{"location":"examples/library_usage_example/","title":"AgentVault Library Usage Example","text":"<p>This example demonstrates how to use the core <code>agentvault</code> Python client library directly to interact with an A2A-compliant agent, without using the <code>agentvault_cli</code>.</p>"},{"location":"examples/library_usage_example/#concept","title":"Concept","text":"<p>The <code>agentvault</code> library provides the <code>AgentVaultClient</code> class, which handles the complexities of the A2A protocol (JSON-RPC, SSE, authentication via <code>KeyManager</code>). This script shows the basic workflow:</p> <ol> <li>Load the target agent's <code>AgentCard</code>.</li> <li>Instantiate <code>KeyManager</code> to handle potential authentication credentials.</li> <li>Instantiate <code>AgentVaultClient</code> (using <code>async with</code>).</li> <li>Call <code>client.initiate_task</code> to start the interaction.</li> <li>Use <code>async for event in client.receive_messages(...)</code> to stream and process events (status updates, messages, artifacts) from the agent.</li> <li>Handle potential exceptions.</li> </ol>"},{"location":"examples/library_usage_example/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Lists the <code>agentvault</code> library dependency.</li> <li><code>main.py</code>: The Python script demonstrating the library usage. It takes the agent reference and input text as command-line arguments.</li> </ul>"},{"location":"examples/library_usage_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/library_usage_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the <code>agentvault</code> library from your local source tree.</li> <li>Target Agent: By default, the script targets the Basic A2A Server example agent card URL (<code>http://localhost:8000/agent-card.json</code>). Ensure that agent is running if you use the default. You can target other agents using the <code>--agent-ref</code> argument.</li> <li>Credentials (If Needed): If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are configured using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card. The <code>KeyManager</code> within the script will automatically pick them up.</li> </ol>"},{"location":"examples/library_usage_example/#running-the-example","title":"Running the Example","text":"<p>Execute the Python script from your terminal, providing the input text:</p> <pre><code># Run against the default Basic Echo Agent (make sure it's running on port 8000)\npython main.py --input \"Hello from the library!\"\n\n# Run against a different agent (e.g., one requiring auth)\n# Ensure 'my-api-key-service' is configured via `agentvault config` if needed\n# python main.py --agent-ref \"https://some-other-agent.com/card.json\" --input \"Process this data\" --key-service \"my-api-key-service\"\n</code></pre> <p>Expected Output:</p> <p>The script will print logs indicating the steps it's taking (loading card, initiating task) and then print details for each event received from the agent via the SSE stream (status changes, messages, artifacts).</p> <pre><code>INFO:root:Loading agent card: http://localhost:8000/agent-card.json\nINFO:root:Loaded Agent: SDK Basic Echo Agent\nINFO:root:Initiating task...\nINFO:agentvault.client:Initiating task with agent: examples/simple-agent\nINFO:agentvault.client:Task successfully initiated with agent examples/simple-agent. Task ID: simple-xxxxxx\nINFO:root:Task initiated: simple-xxxxxx\nINFO:root:Streaming events...\nINFO:agentvault.client:Subscribing to events for task simple-xxxxxx on agent: examples/simple-agent\nINFO:root:  Status Update: WORKING (Msg: N/A)\nINFO:root:  Message Received (Role: assistant):\nINFO:root:    Text: Echo response for task simple-xxxxxx\nINFO:root:  Status Update: COMPLETED (Msg: N/A)\nINFO:root:  Terminal state reached.\nINFO:root:\n--- Final Aggregated Agent Response ---\nEcho response for task simple-xxxxxx\n---------------------------------------\n</code></pre>"},{"location":"examples/oauth_agent_example/","title":"AgentVault Server SDK - OAuth2 Agent Example","text":"<p>This example demonstrates how to build an A2A agent that requires OAuth2 Client Credentials authentication using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/oauth_agent_example/#components","title":"Components","text":"<ul> <li><code>.env.example</code>: Example environment variables for setting the mock Client ID and Secret the server will accept.</li> <li><code>agent-card.json</code>: Describes the agent, specifying the <code>oauth2</code> auth scheme and the <code>/token</code> endpoint URL.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>, <code>python-dotenv</code>).</li> <li><code>src/oauth_agent_example/agent.py</code>: Defines the simple <code>OAuthProtectedAgent</code> logic.</li> <li><code>src/oauth_agent_example/main.py</code>:<ul> <li>Sets up the FastAPI application.</li> <li>Includes the SDK's A2A router at <code>/a2a</code>.</li> <li>Adds a custom <code>POST /token</code> endpoint to handle the OAuth2 Client Credentials grant flow, validating against environment variables.</li> <li>Adds a FastAPI dependency (<code>verify_token</code>) using <code>HTTPBearer</code> to protect the <code>/a2a</code> router, ensuring requests have a valid mock Bearer token obtained from <code>/token</code>.</li> <li>Includes the required SDK exception handlers.</li> </ul> </li> </ul>"},{"location":"examples/oauth_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/oauth_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> <li>Configure Server Credentials:<ul> <li>Copy <code>.env.example</code> to <code>.env</code>.</li> <li>Review the <code>MOCK_CLIENT_ID</code> and <code>MOCK_CLIENT_SECRET</code> in <code>.env</code>. These are the credentials the server will expect the client to provide to the <code>/token</code> endpoint. You can change them if desired.</li> </ul> </li> </ol>"},{"location":"examples/oauth_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn. It will load the credentials from the <code>.env</code> file.</p> <p><pre><code>uvicorn src.oauth_agent_example.main:app --reload --port 8002\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8002</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint and the <code>/token</code> endpoint.</p>"},{"location":"examples/oauth_agent_example/#configuring-client-credentials","title":"Configuring Client Credentials","text":"<p>Before you can interact with this agent using <code>agentvault_cli</code>, you need to configure the client-side credentials that match the ones the server expects.</p> <ol> <li>Open a NEW terminal window/tab (keep the server running).</li> <li>Activate the AgentVault virtual environment if you haven't already (<code>source .venv/bin/activate</code> or similar).</li> <li> <p>Use <code>agentvault config set</code>: Use the <code>service_identifier</code> from <code>agent-card.json</code> (<code>example-oauth-agent</code>) and the <code>--oauth-configure</code> flag. Enter the same Client ID and Secret that are defined in the server's <code>.env</code> file when prompted.</p> <pre><code>agentvault config set example-oauth-agent --oauth-configure\n# --&gt; Enter OAuth Client ID for 'example-oauth-agent': test-client-id-123\n# --&gt; Enter OAuth Client Secret for 'example-oauth-agent': ************************\n# --&gt; Confirm OAuth Client Secret for 'example-oauth-agent': ************************\n# SUCCESS: OAuth credentials for 'example-oauth-agent' stored successfully in keyring.\n</code></pre> </li> </ol>"},{"location":"examples/oauth_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Now that the server is running and client credentials are configured, you can test the interaction:</p> <pre><code>agentvault run --agent http://localhost:8002/agent-card.json --input \"Test OAuth Auth\"\n</code></pre> <p>Expected Behavior:</p> <ol> <li>The <code>agentvault</code> client library (used by the CLI) will load the agent card.</li> <li>It sees the <code>oauth2</code> scheme and the <code>tokenUrl</code>.</li> <li>It uses the <code>KeyManager</code> to retrieve the Client ID/Secret you configured for <code>example-oauth-agent</code>.</li> <li>It makes a <code>POST</code> request to <code>http://localhost:8002/token</code> with the credentials.</li> <li>The server's <code>/token</code> endpoint validates the credentials against the <code>.env</code> file and returns a mock access token.</li> <li>The client library receives the token.</li> <li>It makes the <code>POST</code> request to <code>http://localhost:8002/a2a</code> for the <code>tasks/send</code> method, including the <code>Authorization: Bearer &lt;mock_access_token&gt;</code> header.</li> <li>The server's <code>verify_token</code> dependency validates the token.</li> <li>The SDK router calls the agent's <code>handle_task_send</code> method.</li> <li>The agent starts the task and sends back SSE events confirming authentication worked.</li> </ol> <p>You should see output similar to the Basic Echo example, but the underlying process involves the OAuth token exchange. If authentication fails (e.g., wrong client credentials configured), the <code>run</code> command will report an authentication error.</p>"},{"location":"examples/poc_dynamics/","title":"Dynamics 365 Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates a multi-agent pipeline simulating the analysis of Dynamics 365 CRM data, enriched with external signals, to generate insights and trigger actions for account managers.</p>"},{"location":"examples/poc_dynamics/#overview","title":"Overview","text":"<p>The pipeline integrates data fetching, external enrichment, rule-based analysis, LLM-driven recommendation and briefing generation, and action execution (task creation, notifications). It showcases how AgentVault can orchestrate complex business workflows involving both internal data and external intelligence.</p>"},{"location":"examples/poc_dynamics/#workflow-diagram","title":"Workflow Diagram","text":"<p>This diagram outlines the flow of data and control between the orchestrator and the various agents involved in the Dynamics 365 pipeline.</p> <p> (Diagram showing the orchestrator coordinating calls to the Dynamics Fetcher, External Enricher, Analyzer, Recommender, Action Executors (Task Creator, Notifiers), and Briefing Generator.)</p>"},{"location":"examples/poc_dynamics/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>dynamics_orchestrator</code>) -&gt; Dynamics Data Fetcher Agent (<code>local-poc/dynamics-data-fetcher</code>)<ul> <li>Input: <code>account_id</code>.</li> <li>Action: Queries a mock PostgreSQL database (simulating Dynamics) for Account, Contact, Opportunity, and Case data related to the <code>account_id</code>.</li> <li>Output: <code>dynamics_data</code> artifact containing the fetched records.</li> </ul> </li> <li>Orchestrator -&gt; External Data Enricher Agent (<code>local-poc/external-data-enricher</code>)<ul> <li>Input: <code>website</code> (extracted from the <code>dynamics_data</code> artifact).</li> <li>Action: Queries a mock database for external signals (News, Intent Signals, Technologies) associated with the company website.</li> <li>Output: <code>external_data</code> artifact.</li> </ul> </li> <li>Orchestrator -&gt; Account Health Analyzer Agent (<code>local-poc/account-health-analyzer</code>)<ul> <li>Input: <code>dynamics_data</code>, <code>external_data</code> artifacts.</li> <li>Action: Applies rule-based logic (or optionally an LLM) to assess account health (Risk, Opportunity, Engagement levels) based on the combined data.</li> <li>Output: <code>account_analysis</code> artifact.</li> </ul> </li> <li>Orchestrator -&gt; Action Recommendation Agent (<code>local-poc/action-recommender</code>)<ul> <li>Input: <code>dynamics_data</code>, <code>external_data</code>, <code>account_analysis</code> artifacts.</li> <li>Action: Uses an LLM to analyze the context and generate 2-3 prioritized, actionable recommendations (Next Best Actions) for the account manager, including rationale and related record IDs where applicable.</li> <li>Output: <code>recommended_actions</code> artifact.</li> </ul> </li> <li>Orchestrator (Action Execution Node):<ul> <li>Input: <code>recommended_actions</code> artifact.</li> <li>Action: Filters for 'High' priority actions. For each:<ul> <li>Calls Dynamics Task Creator Agent (<code>local-poc/dynamics-task-creator</code>) to create a task in the mock DB.</li> <li>Calls Slack Notifier Agent (<code>local-poc/slack-notifier</code>) to log a mock Slack notification.</li> <li>Calls Teams Notifier Agent (<code>local-poc/teams-notifier</code>) to log a mock Teams notification.</li> </ul> </li> <li>Output: Updates state with <code>action_execution_results</code>.</li> </ul> </li> <li>Orchestrator -&gt; Briefing Generator Agent (<code>local-poc/account-briefing-generator</code>)<ul> <li>Input: <code>dynamics_data</code>, <code>external_data</code>, <code>account_analysis</code>, <code>recommendations</code>, <code>execution_results</code> artifacts/state.</li> <li>Action: Uses an LLM to synthesize all gathered information into a concise briefing for the account manager, including a summary of executed actions.</li> <li>Output: <code>account_briefing</code> artifact (text).</li> </ul> </li> <li>Orchestrator: Logs the final status, briefing, and execution results.</li> </ol>"},{"location":"examples/poc_dynamics/#components","title":"Components","text":"<ul> <li><code>poc_agents/dynamics_pipeline/</code>: Root directory for this POC.<ul> <li><code>db/</code>: PostgreSQL initialization scripts (<code>init-d365-data.sql</code>, <code>ensure_mock_tasks.sql</code>).</li> <li><code>agents/</code>: Separate directories for each agent (Fetcher, Enricher, Analyzer, Recommender, Briefer, Task Creator, Slack Notifier, Teams Notifier), each containing source code, <code>agent-card.json</code>, Dockerfile, <code>.env</code>, etc.</li> <li><code>dynamics_pipeline_orchestrator/</code>: LangGraph-based orchestrator managing the workflow.</li> <li><code>docker-compose.yml</code>: Runs the PostgreSQL database, all agents, and the orchestrator.</li> </ul> </li> </ul>"},{"location":"examples/poc_dynamics/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.10+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running. An OpenAI-compatible LLM Server (like LM Studio) is required for the Recommender and Briefer agents.</li> <li>Database: The <code>docker-compose.yml</code> defines a PostgreSQL service (<code>d365-db</code>) initialized with mock CRM data.</li> <li>LLM Server: Ensure your LLM server is running and accessible (e.g., <code>http://host.docker.internal:1234/v1</code>). Load a suitable model (e.g., Llama 3 Instruct 8B).</li> <li>Environment Variables:<ul> <li>Each agent directory has an <code>.env</code> file. Key variables:<ul> <li>Fetcher, Enricher, Task Creator: <code>DATABASE_*</code> variables to connect to <code>d365-db</code>.</li> <li>Analyzer, Briefer, Recommender: <code>LLM_API_URL</code>, <code>LLM_MODEL_NAME</code>.</li> </ul> </li> <li>The orchestrator's <code>.env</code> needs <code>AGENTVAULT_REGISTRY_URL</code>.</li> </ul> </li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/dynamics_pipeline/</code> directory.</li> <li>Run: <code>docker-compose build</code></li> <li>Run: <code>docker-compose up -d</code></li> </ul> </li> </ol>"},{"location":"examples/poc_dynamics/#running-the-poc","title":"Running the POC","text":"<p>The orchestrator runs automatically on startup, triggered by the Dockerfile's <code>CMD</code>. It processes a default Account ID (<code>ACC-GUID-SVA</code> - Quantum Dynamics) specified in the <code>docker-compose.yml</code>. You can change this default or trigger runs for other accounts via <code>docker exec</code>.</p> <ol> <li>Monitor Logs: Observe the orchestrator's logs:     <pre><code>docker logs -f dynamics-pipeline-orchestrator\n</code></pre></li> <li>Run for a Different Account: <pre><code># Example: Run for Acme Corp\ndocker exec -it dynamics-pipeline-orchestrator python -m dynamics_orchestrator.run ACC-GUID-001\n\n# Example: Run for Beta Solutions\ndocker exec -it dynamics-pipeline-orchestrator python -m dynamics_orchestrator.run ACC-GUID-002\n</code></pre></li> <li>Check Database: Connect to the <code>d365-db</code> container or use a DB client (connecting to <code>localhost:5435</code>) to inspect the <code>mock_tasks</code> table for created tasks.</li> </ol>"},{"location":"examples/poc_dynamics/#example-run-gif","title":"Example Run (GIF)","text":"<p>This animation shows the log output when the Dynamics 365 pipeline is run for the default \"Quantum Dynamics\" account, highlighting the various agent calls and the final generated briefing.</p> <p> (Animation showing logs from the orchestrator calling the fetcher, enricher, analyzer, recommender, task creator, notifiers, and briefer agents)</p>"},{"location":"examples/poc_dynamics/#expected-output","title":"Expected Output","text":"<ul> <li>Orchestrator Logs: Show the pipeline steps, agent calls, analysis results, recommendations, action execution attempts (task creation, notifications), and the final briefing.</li> <li><code>mock_tasks</code> Table: Contains new task records if high-priority actions were recommended and the Task Creator agent succeeded.</li> <li>Agent Logs: Individual agent logs show mock database queries, LLM calls (for recommender/briefer), and mock notification attempts.</li> </ul>"},{"location":"examples/poc_dynamics/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Business Workflow Automation: Orchestrating a CRM-centric analysis and action pipeline.</li> <li>Data Integration: Combining mock internal CRM data with mock external signals.</li> <li>Hybrid Analysis: Using both rule-based logic (Analyzer) and LLM generation (Recommender, Briefer).</li> <li>Action Execution: Triggering downstream actions (mock task creation, notifications) based on pipeline insights.</li> <li>Database Interaction: Agents interacting with a PostgreSQL database simulating a CRM backend.</li> <li>LangGraph Orchestration: Defining the complex workflow with conditional logic.</li> <li>AgentVault Client/SDK: Enabling communication and task management.</li> <li>Docker Compose: Managing a multi-container application with a database.</li> </ul>"},{"location":"examples/poc_ecommerce/","title":"E-commerce Recommendation Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates a multi-agent pipeline for generating personalized e-commerce product recommendations.</p>"},{"location":"examples/poc_ecommerce/#overview","title":"Overview","text":"<p>The pipeline simulates a common e-commerce scenario where user behavior, product information, and current trends are combined to suggest relevant products. It showcases how specialized agents can collaborate within the AgentVault framework.</p>"},{"location":"examples/poc_ecommerce/#workflow-diagram","title":"Workflow Diagram","text":"<p>This diagram shows the flow where the orchestrator gathers context from profile, catalog, and trend agents before calling the recommendation engine.</p> <p> (Diagram illustrating the flow: Orchestrator calls User Profile, Product Catalog, and Trend Analysis agents, aggregates the context, and then calls the Recommendation Engine.)</p>"},{"location":"examples/poc_ecommerce/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>ecommerce_orchestrator</code>) -&gt; User Profile Agent (<code>local-poc/ecommerce-user-profile</code>)<ul> <li>Input: <code>user_id</code>.</li> <li>Output: User profile data (purchase history, browsing history, preferences).</li> </ul> </li> <li>Orchestrator -&gt; Product Catalog Agent (<code>local-poc/ecommerce-product-catalog</code>)<ul> <li>Input: Product IDs (e.g., from user history or context) or search term.</li> <li>Output: Detailed product information.</li> </ul> </li> <li>Orchestrator -&gt; Trend Analysis Agent (<code>local-poc/ecommerce-trend-analysis</code>)<ul> <li>Input: Timeframe (e.g., \"7d\").</li> <li>Output: List of trending product IDs and categories.</li> </ul> </li> <li>Orchestrator (Aggregate Node): Combines results from the previous steps.</li> <li>Orchestrator -&gt; Recommendation Engine Agent (<code>local-poc/ecommerce-recommendation-engine</code>)<ul> <li>Input: Aggregated context (user profile, relevant product details, trending data).</li> <li>Output: List of personalized product recommendations with scores and reasoning.</li> </ul> </li> <li>Orchestrator: Saves final recommendations and intermediate artifacts locally.</li> </ol>"},{"location":"examples/poc_ecommerce/#components","title":"Components","text":"<ul> <li><code>poc_agents/ecommerce_pipeline/</code>: Root directory for this POC.<ul> <li><code>ecommerce_user_profile_agent/</code>: Mock agent providing user data.</li> <li><code>ecommerce_product_catalog_agent/</code>: Mock agent providing product details.</li> <li><code>ecommerce_trend_analysis_agent/</code>: Mock agent providing trending data.</li> <li><code>ecommerce_recommendation_engine_agent/</code>: Mock agent generating recommendations based on input.</li> <li><code>ecommerce_pipeline_orchestrator/</code>: LangGraph-based orchestrator managing the workflow.</li> <li><code>docker-compose.yml</code>: Runs all agents and the orchestrator.</li> <li><code>documentation/</code>: Contains explanatory documents (<code>agent_implementations.md</code>, <code>fixes.md</code>).</li> </ul> </li> </ul>"},{"location":"examples/poc_ecommerce/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.10+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running (typically via its own <code>docker-compose.yml</code> in the main <code>agentvault_registry</code> directory).</li> <li>Environment Variables: Review/create <code>.env</code> files within each agent directory and the orchestrator directory if specific configurations (like API keys for real agents) are needed. The orchestrator's <code>.env</code> requires <code>AGENTVAULT_REGISTRY_URL</code>.</li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/ecommerce_pipeline/</code> directory.</li> <li>Run: <code>docker-compose build</code></li> <li>Run: <code>docker-compose up -d</code></li> </ul> </li> </ol>"},{"location":"examples/poc_ecommerce/#running-the-poc","title":"Running the POC","text":"<p>The orchestrator can be triggered manually via <code>docker exec</code>.</p> <ol> <li>Wait for Services: Allow some time for all containers to start and initialize (e.g., 15-30 seconds).</li> <li>Execute Orchestrator: <pre><code># Replace 'test-user-123' with any desired user ID\ndocker exec -it ecommerce-pipeline-orchestrator python -m ecommerce_orchestrator.run test-user-123\n</code></pre> (Note: The orchestrator currently uses a wrapper script (<code>wrapper.py</code>) as its entry point, which in turn calls <code>run.py</code> with a default user ID if none is provided via exec arguments. The command above explicitly passes the user ID)</li> <li>Monitor Logs: Observe the logs of the orchestrator and individual agents:     <pre><code>docker logs -f ecommerce-pipeline-orchestrator\ndocker logs -f ecommerce-user-profile-agent\n# etc.\n</code></pre></li> </ol>"},{"location":"examples/poc_ecommerce/#example-run-gif","title":"Example Run (GIF)","text":"<p>This animation shows the log output as the e-commerce orchestrator calls the various agents to gather context and finally generates recommendations.</p> <p> (Animation showing logs from the e-commerce orchestrator calling user profile, product catalog, trend analysis, and recommendation engine agents)</p>"},{"location":"examples/poc_ecommerce/#expected-output","title":"Expected Output","text":"<ul> <li>Orchestrator Logs: Show the pipeline steps: calling each agent, aggregating results, and generating the final recommendations.</li> <li>Local Artifacts: Generated files stored in the mounted volume (<code>poc_agents/ecommerce_pipeline/ecommerce_pipeline_orchestrator/pipeline_artifacts/ecommerce/&lt;project_id&gt;/</code>).</li> <li>Final State Output: The orchestrator prints the final state, including the list of recommendations.</li> </ul>"},{"location":"examples/poc_ecommerce/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Multi-Agent Collaboration: Orchestrating multiple specialized agents for a complex task.</li> <li>LangGraph Orchestration: Using LangGraph to define and manage the workflow state.</li> <li>AgentVault Client Library: Used by the orchestrator (<code>A2AClientWrapper</code>) to interact with agents.</li> <li>AgentVault Server SDK: Used by the individual agents to expose A2A endpoints.</li> <li>Local Artifact Storage: Saving intermediate and final results to the local filesystem via Docker volumes.</li> <li>Registry Discovery: The orchestrator uses the AgentVault Registry to find agent endpoints.</li> <li>Docker Networking: Agents and orchestrator communicate using Docker service names.</li> </ul>"},{"location":"examples/poc_etl/","title":"ETL Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates a simple Extract, Transform, Load (ETL) pipeline orchestrated using AgentVault and LangGraph.</p>"},{"location":"examples/poc_etl/#overview","title":"Overview","text":"<p>The pipeline simulates processing data from a source (CSV file), transforming it, validating it, and loading it into a mock target. It highlights the use of a shared database for passing artifacts between agents, rather than sending large data payloads directly via A2A messages.</p>"},{"location":"examples/poc_etl/#workflow-diagram","title":"Workflow Diagram","text":"<p>The diagram below shows the sequential flow of the ETL pipeline, where each agent passes the database ID of its output artifact to the next agent.</p> <p> (Diagram illustrating the flow: Orchestrator calls Extractor, which saves to DB and returns ID. Orchestrator calls Transformer with ID, Transformer saves to DB and returns new ID, and so on for Validator and Loader.)</p>"},{"location":"examples/poc_etl/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>etl_orchestrator</code>) -&gt; Data Extractor Agent (<code>local-poc/etl-data-extractor</code>)<ul> <li>Input: Path to source CSV file (e.g., <code>/data/input_data.csv</code>), <code>run_id</code>.</li> <li>Action: Reads CSV, stores raw data content (as JSON list of dicts) in the <code>pipeline_artifacts</code> database table.</li> <li>Output: Database ID (<code>artifact_db_id</code>) of the stored raw data artifact, number of rows extracted.</li> </ul> </li> <li>Orchestrator -&gt; Data Transformer Agent (<code>local-poc/etl-data-transformer</code>)<ul> <li>Input: <code>artifact_db_id</code> of the raw data, <code>run_id</code>.</li> <li>Action: Fetches raw data artifact from DB, performs transformations (e.g., rename columns, convert types), stores transformed data in DB.</li> <li>Output: <code>artifact_db_id</code> of the stored transformed data artifact, number of rows transformed.</li> </ul> </li> <li>Orchestrator -&gt; Data Validator Agent (<code>local-poc/etl-data-validator</code>)<ul> <li>Input: <code>artifact_db_id</code> of the transformed data, <code>run_id</code>.</li> <li>Action: Fetches transformed data artifact from DB, applies validation rules (e.g., check for required fields, valid values), stores validation report in DB.</li> <li>Output: <code>artifact_db_id</code> of the stored validation report artifact, overall validation status (<code>Success</code>, <code>Failed</code>), number of invalid rows.</li> </ul> </li> <li>Orchestrator -&gt; Data Loader Agent (<code>local-poc/etl-data-loader</code>)<ul> <li>Input: <code>artifact_db_id</code> of transformed data, <code>artifact_db_id</code> of validation report, <code>run_id</code>.</li> <li>Action: Fetches transformed data and validation report from DB. If validation status is \"Success\", simulates loading data into a mock target table (<code>loaded_data_target</code>) within the same DB. Stores a load confirmation artifact in DB.</li> <li>Output: <code>artifact_db_id</code> of the stored load confirmation artifact, load status (<code>Success</code>, <code>Aborted</code>, <code>Failed</code>), rows processed, rows loaded.</li> </ul> </li> <li>Orchestrator: Logs the final status and artifact IDs.</li> </ol>"},{"location":"examples/poc_etl/#components","title":"Components","text":"<ul> <li><code>poc_agents/etl_pipeline/</code>: Root directory for this POC.<ul> <li><code>db/</code>: Contains PostgreSQL initialization script (<code>init.sql</code>) to create the <code>pipeline_artifacts</code> table.</li> <li><code>data/</code>: Contains sample input CSV file (<code>input_data.csv</code>). Mounted into agent containers.</li> <li><code>data_extractor_agent/</code>: Agent to read CSV and store raw data artifact.</li> <li><code>data_transformer_agent/</code>: Agent to fetch, transform, and store transformed data artifact.</li> <li><code>data_validator_agent/</code>: Agent to fetch, validate, and store validation report artifact.</li> <li><code>data_loader_agent/</code>: Agent to fetch data/report, mock load, and store confirmation artifact.</li> <li><code>etl_pipeline_orchestrator/</code>: LangGraph-based orchestrator managing the workflow.</li> <li><code>docker-compose.yml</code>: Runs the PostgreSQL database, all agents, and the orchestrator.</li> </ul> </li> </ul>"},{"location":"examples/poc_etl/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.10+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running.</li> <li>Database: The <code>docker-compose.yml</code> file defines a PostgreSQL service (<code>etl-db</code>) specifically for this pipeline's artifact storage. It will be created automatically.</li> <li>Environment Variables:<ul> <li>Each agent directory (<code>data_extractor_agent</code>, etc.) has an <code>.env</code> file containing the necessary <code>DATABASE_*</code> variables to connect to the <code>etl-db</code> service within the Docker network.</li> <li>The orchestrator's <code>.env</code> needs <code>AGENTVAULT_REGISTRY_URL</code>.</li> </ul> </li> <li>Input Data: Place your input CSV file (e.g., <code>input_data.csv</code>) inside the <code>poc_agents/etl_pipeline/data/</code> directory. This directory is mounted into the extractor agent's container at <code>/data</code>.</li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/etl_pipeline/</code> directory.</li> <li>Run: <code>docker-compose build</code></li> <li>Run: <code>docker-compose up -d</code></li> </ul> </li> </ol>"},{"location":"examples/poc_etl/#running-the-poc","title":"Running the POC","text":"<p>The orchestrator runs automatically on startup, triggered by the Dockerfile's <code>CMD</code>. It uses <code>/data/input_data.csv</code> as the default input file path.</p> <ol> <li>Monitor Logs: Observe the orchestrator's logs:     <pre><code>docker logs -f etl-pipeline-orchestrator\n</code></pre>     You can also check individual agent logs (e.g., <code>docker logs -f etl-data-extractor-agent</code>).</li> <li>Check Database: Connect to the <code>etl-db</code> container or use a DB client (connecting to <code>localhost:5434</code>) to inspect the <code>pipeline_artifacts</code> table and the <code>loaded_data_target</code> table (created by the loader).<ul> <li>User: <code>etl_user</code></li> <li>Password: <code>etl_password</code></li> <li>Database: <code>etl_poc_db</code></li> <li>Example Query: <code>SELECT id, run_id, step_name, artifact_type, created_at FROM pipeline_artifacts ORDER BY created_at DESC;</code></li> </ul> </li> </ol>"},{"location":"examples/poc_etl/#example-run-gif","title":"Example Run (GIF)","text":"<p>This animation demonstrates the typical log output from running the ETL pipeline via Docker Compose. It shows the orchestrator calling each agent sequentially and the agents logging their interactions with the database.</p> <p> (Animation showing logs from the orchestrator and ETL agents (Extractor, Transformer, Validator, Loader) interacting with the database)</p>"},{"location":"examples/poc_etl/#expected-output","title":"Expected Output","text":"<ul> <li>Orchestrator Logs: Show the pipeline steps, agent calls, and the final status (COMPLETED or FAILED). It will list the database IDs for each artifact created.</li> <li><code>pipeline_artifacts</code> Table: Contains JSONB records for <code>raw_data</code>, <code>transformed_data</code>, <code>validation_report</code>, and <code>load_confirmation</code>.</li> <li><code>loaded_data_target</code> Table: Contains rows corresponding to the validated data if the pipeline completed successfully.</li> </ul>"},{"location":"examples/poc_etl/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Multi-Agent ETL Workflow: Orchestrating distinct ETL stages using specialized agents.</li> <li>Database as Artifact Store: Using a database (PostgreSQL with JSONB) to pass data between agents instead of large A2A messages. Agents interact via artifact IDs.</li> <li>LangGraph Orchestration: Defining the ETL flow as a state graph.</li> <li>AgentVault Client/SDK: Used by orchestrator and agents for communication and task management.</li> <li>Configuration: Using <code>.env</code> files for agent-specific database credentials and orchestrator configuration (<code>etl_config.json</code>).</li> <li>Docker Networking &amp; Volumes: Enabling communication between services and providing input data.</li> </ul>"},{"location":"examples/poc_mcp_pipeline/","title":"MCP Test Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates how AgentVault can interact with tool servers compliant with the Model Context Protocol (MCP), enabling agents to execute external tools like filesystem operations or code execution securely.</p>"},{"location":"examples/poc_mcp_pipeline/#overview","title":"Overview","text":"<p>The core idea is to use a specialized MCP Tool Proxy Agent. This A2A-compliant agent acts as a bridge:</p> <ol> <li>It receives standard A2A <code>tasks/send</code> requests from an orchestrator (like the MCP Test Orchestrator).</li> <li>The request payload specifies which MCP tool server to target (e.g., 'filesystem', 'code-runner') and the tool method to call (e.g., <code>filesystem.readFile</code>, <code>code.runPython</code>) along with its arguments.</li> <li>The Proxy Agent translates the A2A request into a JSON-RPC 2.0 request suitable for the target MCP server.</li> <li>It sends the JSON-RPC request to the MCP server's <code>/rpc</code> endpoint via HTTP POST.</li> <li>It receives the JSON-RPC response from the MCP server.</li> <li>It translates the MCP response (including success/failure and results/errors) back into an A2A artifact or message for the orchestrator.</li> </ol> <p>This allows LangGraph orchestrators (or any A2A client) to leverage MCP tools without needing direct MCP communication capabilities themselves.</p>"},{"location":"examples/poc_mcp_pipeline/#workflow-diagram","title":"Workflow Diagram","text":"<p>This diagram shows the interaction flow where the orchestrator uses the MCP Tool Proxy Agent to communicate with the custom Filesystem and Code Runner MCP servers.</p> <p> (Diagram showing the orchestrator calling the MCP Tool Proxy, which in turn calls the Filesystem MCP Server and the Code Runner MCP Server via JSON-RPC/HTTP.)</p>"},{"location":"examples/poc_mcp_pipeline/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>mcp_test_orchestrator</code>) -&gt; MCP Tool Proxy Agent (<code>local-poc/mcp-tool-proxy</code>)<ul> <li>Input: A2A Task with <code>DataPart</code> containing: <code>target_mcp_server_id=\"filesystem\"</code>, <code>tool_name=\"filesystem.readFile\"</code>, <code>arguments={\"path\": \"/data/test_script.py\"}</code>.</li> </ul> </li> <li>MCP Tool Proxy Agent -&gt; Filesystem MCP Server (<code>custom-filesystem-mcp</code>)<ul> <li>Input: HTTP POST to <code>/rpc</code> with JSON-RPC payload (<code>method=\"filesystem.readFile\"</code>).</li> </ul> </li> <li>Filesystem MCP Server -&gt; MCP Tool Proxy Agent<ul> <li>Output: HTTP Response with JSON-RPC payload containing file content.</li> </ul> </li> <li>MCP Tool Proxy Agent -&gt; Orchestrator<ul> <li>Output: A2A Task Completion with file content.</li> </ul> </li> <li>Orchestrator (<code>mcp_test_orchestrator</code>) -&gt; MCP Tool Proxy Agent (<code>local-poc/mcp-tool-proxy</code>)<ul> <li>Input: A2A Task with <code>DataPart</code> containing: <code>target_mcp_server_id=\"code\"</code>, <code>tool_name=\"code.runPython\"</code>, <code>arguments={\"code\": \"...\"}</code> (code read from file).</li> </ul> </li> <li>MCP Tool Proxy Agent -&gt; Code Runner MCP Server (<code>custom-code-runner-mcp</code>)<ul> <li>Input: HTTP POST to <code>/rpc</code> with JSON-RPC payload (<code>method=\"code.runPython\"</code>).</li> </ul> </li> <li>Code Runner MCP Server -&gt; MCP Tool Proxy Agent<ul> <li>Output: HTTP Response with JSON-RPC payload containing script stdout/stderr.</li> </ul> </li> <li>MCP Tool Proxy Agent -&gt; Orchestrator<ul> <li>Output: A2A Task Completion with script output.</li> </ul> </li> </ol>"},{"location":"examples/poc_mcp_pipeline/#components","title":"Components","text":"<ul> <li><code>poc_agents/mcp_test_pipeline/</code>: Root directory for this POC.<ul> <li><code>custom-filesystem-mcp/</code>: A Python/FastAPI implementation of an MCP server providing <code>filesystem.*</code> tools. Uses a shared Docker volume (<code>/data</code>). Exposes <code>/rpc</code>.</li> <li><code>custom-code-runner-mcp/</code>: A Python/FastAPI implementation of an MCP server providing <code>code.runPython</code>. Exposes <code>/rpc</code>.</li> <li><code>mcp-tool-proxy-agent/</code>: The A2A agent built with the <code>agentvault-server-sdk</code> that acts as the bridge. It reads target server URLs from its <code>.env</code> file (mapped by logical IDs like \"filesystem\", \"code\").</li> <li><code>mcp_test_orchestrator/</code>: A LangGraph-based orchestrator that defines the read-then-execute workflow.</li> <li><code>mcp_shared_data/</code>: Contains example files (like <code>test_script.py</code>) mounted into the shared Docker volume (<code>/data</code>) accessible by the filesystem server.</li> <li><code>docker-compose.mcp-test.yml</code>: Docker Compose file specifically to run this pipeline, including the custom Python MCP servers and the proxy agent.</li> </ul> </li> </ul>"},{"location":"examples/poc_mcp_pipeline/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.10+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running.</li> <li>Environment Variables:<ul> <li>Review/create <code>.env</code> files within <code>mcp-tool-proxy-agent/</code> and <code>mcp_test_orchestrator/</code>.</li> <li>The <code>mcp-tool-proxy-agent/.env</code> must contain the <code>MCP_SERVER_MAP</code> variable correctly mapping logical server IDs to their internal Docker service URLs:     <pre><code># Example MCP_SERVER_MAP in mcp-tool-proxy-agent/.env\nMCP_SERVER_MAP={\"filesystem\": \"http://custom-filesystem-mcp:8001\", \"code\": \"http://custom-code-runner-mcp:8002\"}\nAGENTVAULT_REGISTRY_URL=http://host.docker.internal:8000 # Or your registry URL\n</code></pre></li> <li>The orchestrator's <code>.env</code> needs <code>AGENTVAULT_REGISTRY_URL</code>.</li> </ul> </li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/mcp_test_pipeline/</code> directory.</li> <li>Run: <code>docker-compose -f docker-compose.mcp-test.yml build</code></li> <li>Run: <code>docker-compose -f docker-compose.mcp-test.yml up -d</code></li> </ul> </li> </ol>"},{"location":"examples/poc_mcp_pipeline/#running-the-poc","title":"Running the POC","text":"<p>The orchestrator runs automatically on startup, processing <code>/data/test_script.py</code>.</p> <ol> <li>Monitor Logs: <pre><code>docker logs -f mcp-test-orchestrator\n</code></pre></li> <li>Expected Log Flow:<ul> <li>Orchestrator starts, discovers proxy agent.</li> <li><code>start_mcp_test</code> node runs.</li> <li><code>read_code_file_via_proxy</code> node runs, calls proxy, which calls filesystem server.</li> <li><code>execute_python_code_via_proxy</code> node runs, calls proxy, which calls code runner server.</li> <li>Pipeline finishes, logs show stdout/stderr from the executed script.</li> </ul> </li> </ol>"},{"location":"examples/poc_mcp_pipeline/#example-run-gif","title":"Example Run (GIF)","text":"<p>This animation displays the log output as the orchestrator interacts with the MCP Tool Proxy Agent, which then communicates with the custom Filesystem and Code Runner MCP servers via JSON-RPC.</p> <p> (Animation showing logs from the orchestrator, proxy agent, filesystem server, and code runner server during the test script execution)</p>"},{"location":"examples/poc_mcp_pipeline/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Model Context Protocol (MCP): Interaction with MCP-compliant tool servers via JSON-RPC over HTTP.</li> <li>A2A-MCP Bridging: Using a proxy agent (<code>mcp-tool-proxy-agent</code>) to allow A2A orchestrators to leverage MCP tools.</li> <li>Tool Execution: Secure execution of external tools (filesystem access, code running) via dedicated servers.</li> <li>Custom MCP Servers: Python/FastAPI implementations of MCP servers providing specific functionalities.</li> <li>Docker Networking &amp; Volumes: Enabling communication and shared file access between services.</li> <li>LangGraph Orchestration: Managing the state and workflow involving proxied tool calls.</li> </ul>"},{"location":"examples/poc_research/","title":"Research Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates a sophisticated multi-agent pipeline designed to automate the research and generation of a comprehensive report on a given topic.</p>"},{"location":"examples/poc_research/#overview","title":"Overview","text":"<p>The pipeline orchestrates 7 specialized agents, each handling a specific stage of the research process, from initial topic exploration to final content editing and visualization. It showcases advanced AgentVault concepts like complex workflows, artifact passing, and leveraging specialized agent skills.</p>"},{"location":"examples/poc_research/#workflow-diagram","title":"Workflow Diagram","text":"<p>The diagram below depicts the flow of control and data artifacts between the orchestrator and the seven agents in the research pipeline.</p> <p> (Diagram showing the orchestrator sequentially calling Topic Research, Content Crawler, Information Extraction, Fact Verification, Content Synthesis, Editor, and Visualization agents, passing artifacts between relevant steps.)</p>"},{"location":"examples/poc_research/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>langgraph_research_orchestrator</code>) -&gt; Topic Research Agent (<code>local-poc/topic-research</code>)<ul> <li>Input: Research <code>topic</code>, <code>depth</code>, <code>focus_areas</code>.</li> <li>Output: Structured <code>research_plan</code> (subtopics, questions) and <code>search_queries</code>.</li> </ul> </li> <li>Orchestrator -&gt; Content Crawler Agent (<code>local-poc/content-crawler</code>)<ul> <li>Input: <code>search_queries</code> from the previous step.</li> <li>Action: Searches the web using configured engines, scrapes content from relevant URLs.</li> <li>Output: <code>raw_content</code> artifact (list of dicts containing URL, title, scraped text, query source).</li> </ul> </li> <li>Orchestrator -&gt; Information Extraction Agent (<code>local-poc/information-extraction</code>)<ul> <li>Input: <code>raw_content</code> artifact.</li> <li>Action: Analyzes scraped text using an LLM to extract key facts, statistics, and direct quotes relevant to the research subtopics.</li> <li>Output: <code>extracted_information</code> artifact (list of all extracted facts/quotes) and <code>info_by_subtopic</code> artifact (facts/quotes grouped by subtopic).</li> </ul> </li> <li>Orchestrator -&gt; Fact Verification Agent (<code>local-poc/fact-verification</code>)<ul> <li>Input: <code>extracted_information</code> artifact.</li> <li>Action: Uses an LLM to assess the credibility of each fact based on source URL and content, assigns a confidence score, and flags potential contradictions.</li> <li>Output: <code>verified_facts</code> artifact (facts annotated with verification status, confidence, notes) and <code>verification_report</code> artifact (list of issues found).</li> </ul> </li> <li>Orchestrator -&gt; Content Synthesis Agent (<code>local-poc/content-synthesis</code>)<ul> <li>Input: <code>verified_facts</code>, <code>research_plan</code>.</li> <li>Action: Uses an LLM to generate a structured draft article (Markdown) based on the verified facts, following the research plan outline. Creates citations.</li> <li>Output: <code>draft_article</code> artifact (Markdown text) and <code>bibliography</code> artifact (structured references).</li> </ul> </li> <li>Orchestrator -&gt; Editor Agent (<code>local-poc/editor</code>)<ul> <li>Input: <code>draft_article</code>.</li> <li>Action: Uses an LLM to review the draft for clarity, style, grammar, and consistency according to configured preferences.</li> <li>Output: <code>edited_article</code> artifact (refined Markdown text) and <code>edit_suggestions</code> artifact (list of changes made or suggested).</li> </ul> </li> <li>Orchestrator -&gt; Visualization Agent (<code>local-poc/visualization</code>)<ul> <li>Input: <code>verified_facts</code>.</li> <li>Action: Identifies data suitable for visualization within the verified facts and generates placeholder visualization metadata (or actual SVGs if configured).</li> <li>Output: <code>viz_metadata</code> artifact (list describing generated visualizations and related facts), potentially individual visualization artifacts (e.g., <code>bar_chart_1.svg</code>).</li> </ul> </li> <li>Orchestrator: Saves final article, visualization metadata, and all intermediate artifacts locally. Logs completion status.</li> </ol>"},{"location":"examples/poc_research/#components","title":"Components","text":"<ul> <li><code>poc_agents/research_pipeline/</code>: Contains the individual agent Python scripts (e.g., <code>topic_research_agent.py</code>), the shared <code>base_agent.py</code>, agent card files (<code>agent_cards/</code>), Dockerfiles (<code>dockerfiles/</code>), environment configuration (<code>envs/</code>), and supporting scripts.</li> <li><code>poc_agents/langgraph_scrapepipe/</code>: Contains the LangGraph-based orchestrator (<code>src/langgraph_research_orchestrator/</code>), its configuration (<code>pipeline_config.json</code>), and runner scripts (<code>run_pipeline.py</code>).</li> </ul>"},{"location":"examples/poc_research/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.11+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running.</li> <li>LLM Server: An OpenAI-compatible LLM server (like LM Studio or Ollama) must be running and accessible to the Docker containers (often via <code>http://host.docker.internal:1234/v1</code>). Ensure the required models (e.g., Llama 3 Instruct, Nomic Embed) are loaded.</li> <li>Environment Variables: Configure the <code>.env</code> files within each agent's corresponding directory under <code>poc_agents/research_pipeline/envs/</code>. These files define the <code>LLM_API_URL</code>, <code>LLM_API_KEY</code>, <code>LLM_MODEL_NAME</code>, <code>PORT</code>, and <code>AGENT_CARD_PATH</code> for each agent.</li> <li>Orchestrator Configuration: Configure the orchestrator's <code>.env</code> file (<code>poc_agents/langgraph_scrapepipe/.env</code>) primarily with <code>AGENTVAULT_REGISTRY_URL</code>. Pipeline behavior (timeouts, artifact paths, etc.) is controlled by <code>pipeline_config.json</code> within the orchestrator's directory. Use <code>config_generator.py</code> to create/modify this file.</li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/research_pipeline/</code> directory.</li> <li>Run: <code>docker-compose build</code> (or <code>docker compose build</code>)</li> <li>Run: <code>docker-compose up -d</code> (or <code>docker compose up -d</code>)</li> </ul> </li> </ol>"},{"location":"examples/poc_research/#running-the-poc","title":"Running the POC","text":"<ol> <li>Navigate: Change to the <code>poc_agents/langgraph_scrapepipe/</code> directory.</li> <li> <p>Run Orchestrator: Use the provided runner script:     ```bash     # Example: Standard depth research on AI in Healthcare     python run_pipeline.py --topic \"Impact of AI on Healthcare\" --depth standard</p>"},{"location":"examples/poc_research/#example-comprehensive-research-with-specific-focus-areas","title":"Example: Comprehensive research with specific focus areas","text":"<p>python run_pipeline.py --topic \"Quantum Computing Applications\" --depth comprehensive --focus-areas \"Cryptography\" \"Drug Discovery\"</p>"},{"location":"examples/poc_research/#example-using-a-custom-configuration-file","title":"Example: Using a custom configuration file","text":"<p>python run_pipeline.py --topic \"Renewable Energy Storage\" --config my_custom_config.json <code>``3.  **Monitor Logs:** Check the orchestrator logs and individual agent logs via</code>docker logs `."},{"location":"examples/poc_research/#example-run-gif","title":"Example Run (GIF)","text":"<p>This animation captures the log output from the research pipeline orchestrator and the various agents involved as they process a research topic.</p> <p> (Animation showing logs from the orchestrator and research agents (topic, crawler, extraction, verification, synthesis, editor, visualization) processing a topic)</p>"},{"location":"examples/poc_research/#expected-output","title":"Expected Output","text":"<ul> <li>Orchestrator Logs: Detailed logs showing each step of the pipeline, agent calls, artifact saving, and the final status.</li> <li>Local Artifacts: Generated files stored in the directory specified by <code>orchestration.artifact_base_path</code> in the orchestrator's configuration file (defaults to <code>poc_agents/langgraph_scrapepipe/pipeline_artifacts/</code>). Files are organized by <code>project_id</code> and then by node name (e.g., <code>pipeline_artifacts/&lt;project_id&gt;/content_synthesis/draft_article.md</code>).</li> </ul>"},{"location":"examples/poc_research/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Complex Multi-Agent Workflow: Orchestrating a 7-step pipeline.</li> <li>LangGraph Orchestration: Defining the workflow as a stateful graph.</li> <li>Agent Specialization: Each agent performs a distinct task in the research process.</li> <li>LLM Integration: Multiple agents leverage LLMs for different tasks (planning, extraction, verification, synthesis, editing).</li> <li>A2A Communication: Agents interact via the AgentVault A2A protocol.</li> <li>Local Artifact Management: Passing data between steps by saving/loading local files.</li> <li>Configuration System: Centralized configuration for pipeline behavior.</li> <li>Error Handling &amp; Retries: Built-in retries for agent communication and error handling within the graph.</li> </ul>"},{"location":"examples/poc_support/","title":"Support Ticket Pipeline Example","text":"<p>This Proof-of-Concept (POC) demonstrates a multi-agent pipeline designed to automate the initial processing and response suggestion for customer support tickets.</p>"},{"location":"examples/poc_support/#overview","title":"Overview","text":"<p>The pipeline simulates a common customer support workflow: receiving a ticket, understanding its context (category, sentiment), gathering relevant information (knowledge base articles, customer history), and suggesting a draft response for a human agent.</p>"},{"location":"examples/poc_support/#workflow-diagram","title":"Workflow Diagram","text":"<p>The following diagram illustrates the sequence of agent interactions in this pipeline:</p> <p> (Diagram illustrating the flow: Orchestrator calls Ticket Analyzer, then KB Search and Customer History concurrently, aggregates results, and finally calls Response Suggester.)</p>"},{"location":"examples/poc_support/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Orchestrator (<code>support_orchestrator</code>) -&gt; Ticket Analyzer Agent (<code>local-poc/support-ticket-analyzer</code>)<ul> <li>Input: <code>ticket_text</code>, <code>customer_identifier</code>.</li> <li>Action: Analyzes the ticket to determine category, sentiment, and extract key entities (e.g., product names, order IDs). Uses mock logic for this POC.</li> <li>Output: <code>ticket_analysis</code> artifact.</li> </ul> </li> <li>Orchestrator -&gt; Knowledge Base Search Agent (<code>local-poc/support-kb-search</code>)<ul> <li>Input: <code>category</code> (from ticket analysis), optional <code>keywords</code>.</li> <li>Action: Searches a mock knowledge base (loaded from <code>mock_kb_data.json</code>) for relevant articles based on the category and keywords.</li> <li>Output: <code>kb_results</code> artifact (list of relevant KB articles with summaries and mock relevance scores).</li> </ul> </li> <li>Orchestrator -&gt; Customer History Agent (<code>local-poc/support-customer-history</code>)<ul> <li>Input: <code>customer_identifier</code>.</li> <li>Action: Retrieves a mock summary of the customer's status (e.g., VIP, Standard) and recent interaction history (loaded from <code>mock_customer_data.json</code>).</li> <li>Output: <code>customer_history</code> artifact.</li> </ul> </li> <li>Orchestrator (Aggregate Node): Combines results from the previous steps (<code>ticket_analysis</code>, <code>kb_results</code>, <code>customer_history</code>) into the pipeline state.</li> <li>Orchestrator -&gt; Response Suggestion Agent (<code>local-poc/support-response-suggester</code>)<ul> <li>Input: Aggregated context (ticket analysis, KB results, customer history).</li> <li>Action: Uses an LLM (configured via environment variables) to generate a draft response based on the provided context. Includes empathy, addresses the issue, and may reference KB articles.</li> <li>Output: <code>suggested_response</code> artifact (text).</li> </ul> </li> <li>Orchestrator: Saves the final suggested response and intermediate artifacts locally. Logs completion status.</li> </ol>"},{"location":"examples/poc_support/#components","title":"Components","text":"<ul> <li><code>poc_agents/support_pipeline/</code>: Root directory for this POC.<ul> <li><code>agents/</code>: Separate directories for each agent (Analyzer, KB Search, History, Suggester), each containing source code, <code>agent-card.json</code>, Dockerfile, <code>.env</code>, etc.</li> <li><code>support_pipeline_orchestrator/</code>: LangGraph-based orchestrator managing the workflow.</li> <li><code>docker-compose.yml</code>: Runs all agents and the orchestrator.</li> <li><code>example_tickets.txt</code>: Sample customer support tickets for testing.</li> <li><code>run_example.bat</code>, <code>run_all_examples_*.bat</code>: Scripts to trigger the pipeline with example tickets.</li> </ul> </li> </ul>"},{"location":"examples/poc_support/#setup","title":"Setup","text":"<ol> <li>Prerequisites: Docker, Docker Compose, Python 3.10+, Poetry. Ensure the <code>agentvault_network</code> Docker network exists (<code>docker network create agentvault_network</code>). The AgentVault Registry should also be running. An OpenAI-compatible LLM Server (like LM Studio) is required for the Response Suggester agent.</li> <li>LLM Server: Ensure your LLM server is running and accessible (e.g., <code>http://host.docker.internal:1234/v1</code>). Load a suitable model (e.g., Llama 3 Instruct 8B).</li> <li>Environment Variables:<ul> <li>Configure the <code>.env</code> file in <code>poc_agents/support_pipeline/response_suggester_agent/</code> with your <code>LLM_API_URL</code>, <code>LLM_MODEL_NAME</code>, etc.</li> <li>Configure the orchestrator's <code>.env</code> file (<code>poc_agents/support_pipeline/support_pipeline_orchestrator/.env</code>) with <code>AGENTVAULT_REGISTRY_URL</code>.</li> </ul> </li> <li>Build &amp; Run Docker Compose:<ul> <li>Navigate to the <code>poc_agents/support_pipeline/</code> directory.</li> <li>Run: <code>docker-compose build</code></li> <li>Run: <code>docker-compose up -d</code></li> </ul> </li> </ol>"},{"location":"examples/poc_support/#running-the-poc","title":"Running the POC","text":"<p>Use the provided batch scripts (or <code>docker exec</code> manually) to run the pipeline with example tickets.</p> <ol> <li>Wait for Services: Allow ~30 seconds for all containers to start and initialize.</li> <li>Run a Specific Ticket: <pre><code># Example: Run ticket #2 (Frustrated User)\n.\\run_example.bat 2\n</code></pre>     This script extracts the ticket text and customer ID from <code>example_tickets.txt</code>, runs the orchestrator via <code>docker exec</code>, and streams the orchestrator logs to a file (<code>ticket_logs/ticket_2_logs.txt</code>) while also showing the last few lines in the console.</li> <li>Run All Tickets: <pre><code># Runs all 10 example tickets sequentially using docker exec\n.\\run_all_examples_via_exec.bat\n</code></pre> (Note: <code>run_all_examples_with_logs.bat</code> opens a separate log window but might require manual closing).</li> <li>Monitor Logs: Observe the orchestrator logs (<code>docker logs -f support-pipeline-orchestrator</code>) or the specific ticket log files created by the batch scripts.</li> </ol>"},{"location":"examples/poc_support/#example-run-gif","title":"Example Run (GIF)","text":"<p>The following animation shows the console output when running the orchestrator for an example support ticket. It displays the logs from the orchestrator and the agents as they process the ticket through the different stages.</p> <p> (Animation showing logs from orchestrator calling analyzer, kb search, history agent, and response suggester, culminating in a final suggested response)</p>"},{"location":"examples/poc_support/#expected-output","title":"Expected Output","text":"<ul> <li>Orchestrator Logs: Show the pipeline steps: analyzing ticket, fetching KB/history, aggregating context, suggesting response. It logs the generated response.</li> <li>Local Artifacts: Generated files (analysis, KB results, history, suggested response) stored in the directory specified by <code>orchestration.artifact_base_path</code> in the orchestrator's configuration file (defaults to <code>/app/pipeline_artifacts/support</code> inside the container, mounted to <code>poc_agents/support_pipeline/support_pipeline_orchestrator/pipeline_artifacts/support</code> on the host).</li> </ul>"},{"location":"examples/poc_support/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Support Workflow Automation: Simulating the initial stages of support ticket processing.</li> <li>Context Aggregation: Combining information from multiple specialized agents (analyzer, KB, history) before generating a response.</li> <li>LLM for Response Generation: Using an LLM via the Suggester agent to draft context-aware responses.</li> <li>LangGraph Orchestration: Managing the state and flow of the support pipeline.</li> <li>AgentVault Client/SDK: Enabling communication and task management between the orchestrator and agents.</li> <li>Local Artifact Storage: Persisting intermediate results for inspection and potential reuse.</li> </ul>"},{"location":"examples/stateful_agent_example/","title":"AgentVault Server SDK - Stateful Agent Example","text":"<p>This example demonstrates how to build an A2A agent that maintains state across multiple interactions within a single task lifecycle using the <code>agentvault-server-sdk</code>.</p>"},{"location":"examples/stateful_agent_example/#concept","title":"Concept","text":"<p>Many agent tasks aren't single-shot requests but involve a conversation or a process that evolves over time. This requires the agent to:</p> <ol> <li>Store Task-Specific State: Remember information relevant to the ongoing task (e.g., conversation history, intermediate results, user preferences).</li> <li>Update State: Modify the stored state based on new messages or internal processing.</li> <li>Handle Multiple Interactions: Accept subsequent <code>tasks/send</code> requests for the same task ID and use the stored state to continue processing.</li> </ol> <p>This example implements a simple chat agent that stores the message history in memory for each task.</p>"},{"location":"examples/stateful_agent_example/#components","title":"Components","text":"<ul> <li><code>agent-card.json</code>: Describes the agent.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>src/stateful_agent_example/state.py</code>: Defines <code>ChatTaskContext</code> which inherits from the SDK's <code>TaskContext</code> and adds a <code>history</code> list to store messages.</li> <li><code>src/stateful_agent_example/agent.py</code>: Defines the <code>StatefulChatAgent</code> logic:<ul> <li>Uses <code>InMemoryTaskStore</code> to store <code>ChatTaskContext</code> instances.</li> <li><code>handle_task_send</code>: Creates a new task context on the first call, storing the initial message. For subsequent calls with the same task ID, it appends the new message to the existing context's history and signals a background processing loop using an <code>asyncio.Event</code>.</li> <li><code>_process_task</code>: A background <code>asyncio</code> task started for each new chat task. It waits for new messages (signaled via the <code>asyncio.Event</code>) and generates simple responses based on the message count.</li> <li>Other handlers (<code>get</code>, <code>cancel</code>, <code>subscribe</code>) interact with the task store.</li> </ul> </li> <li><code>src/stateful_agent_example/main.py</code>: Sets up the FastAPI application, includes the SDK's A2A router, and required exception handlers.</li> </ul>"},{"location":"examples/stateful_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/stateful_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> </ol>"},{"location":"examples/stateful_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <p><pre><code>uvicorn src.stateful_agent_example.main:app --reload --port 8003\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8003</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint.</p>"},{"location":"examples/stateful_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>You can test the stateful interaction using the <code>agentvault_cli</code>:</p> <ol> <li> <p>Initiate Task: Send the first message. Note the <code>Task ID</code> returned.     <pre><code>agentvault run --agent http://localhost:8003/agent-card.json --input \"Hello stateful agent!\"\n# --&gt; SUCCESS: Task initiated successfully. Task ID: stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: WORKING\n# --&gt; Message from Assistant: Received message 1. History length is now 1.\n# --&gt; INFO: Task Status: WORKING # (Agent waits for more input)\n# (Press Ctrl+C here or leave it running)\n</code></pre> Note: The agent stays in the <code>WORKING</code> state, waiting for more input or cancellation.</p> </li> <li> <p>Send Subsequent Message: Open a new terminal (or stop the previous <code>run</code> command with Ctrl+C if desired) and use the same Task ID obtained in step 1 to send another message.     <pre><code># Replace stateful-task-xxxxxx with the actual ID from step 1\nagentvault run --agent http://localhost:8003/agent-card.json --input \"This is the second message.\" --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task message sent successfully to task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; Message from Assistant: Received message 2. History length is now 2.\n# --&gt; INFO: Task Status: WORKING\n# (Press Ctrl+C or leave running)\n</code></pre>     The running agent (or its background task) should detect the new message and send another response via SSE.</p> </li> <li> <p>(Optional) Cancel Task: You can cancel the task using its ID.     <pre><code># Replace stateful-task-xxxxxx with the actual ID\nagentvault run --agent http://localhost:8003/agent-card.json --cancel --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task cancellation request sent successfully for task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: CANCELED\n</code></pre></p> </li> </ol> <p>This demonstrates how the agent uses the <code>task_id</code> to access and update the correct state (<code>ChatTaskContext</code>) stored by the <code>InMemoryTaskStore</code> across multiple <code>run</code> command invocations. In a real application, you would likely use a persistent store instead of <code>InMemoryTaskStore</code>.</p>"},{"location":"guides/client_library/","title":"Developer Guide: Client Library (<code>agentvault</code>)","text":"<p>The <code>agentvault</code> library is the core Python package for interacting with the AgentVault ecosystem from the client-side. It enables applications, scripts, or even other agents to discover A2A agents, manage credentials securely, and communicate using the A2A protocol.</p>"},{"location":"guides/client_library/#installation","title":"Installation","text":"<p>Install the library from PyPI:</p> <pre><code>pip install agentvault\n</code></pre> <p>For optional OS Keyring support (recommended for secure credential storage):</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"guides/client_library/#key-components","title":"Key Components","text":""},{"location":"guides/client_library/#keymanager-key_managerpy","title":"<code>KeyManager</code> (<code>key_manager.py</code>)","text":"<p>Handles secure loading, storage, and retrieval of credentials (API keys, OAuth 2.0 Client ID/Secret) needed for agent authentication.</p> <ul> <li>Purpose: Abstracts credential sources so your client code doesn't need to handle each case explicitly. Provides a consistent interface (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) regardless of where the credential is stored.</li> <li>Initialization: <pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Recommended: Load from environment variables AND OS keyring (if available)\n# Keyring is checked only if the key isn't found in env vars first.\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Load ONLY from a specific .env file (disable env vars and keyring)\n# key_file_path = pathlib.Path(\"path/to/your/keys.env\")\n# km_file_only = KeyManager(key_file_path=key_file_path, use_env_vars=False, use_keyring=False)\n\n# Load from file AND environment (file takes priority over env)\n# key_file_path = pathlib.Path(\"path/to/your/keys.json\")\n# km_file_env = KeyManager(key_file_path=key_file_path, use_env_vars=True, use_keyring=False)\n</code></pre></li> <li>Priority Order: File Cache -&gt; Environment Variable Cache -&gt; OS Keyring (on demand).</li> <li>Service Identifier (<code>service_id</code>): The local alias used to look up credentials (e.g., \"openai\", \"my-custom-agent\"). Often corresponds to <code>AgentCard.authSchemes[].service_identifier</code>.</li> <li>Storage Conventions: See the KeyManager Guide for details on environment variable patterns, file formats (<code>.env</code>, <code>.json</code>), and keyring service names.</li> <li>Retrieving Credentials: <pre><code>km = KeyManager(use_keyring=True) # Example instance\n\n# Get API Key (returns None if not found)\napi_key = km.get_key(\"openai\")\nif api_key:\n    source = km.get_key_source(\"openai\") # 'env', 'file', 'keyring', or None\n    print(f\"Found OpenAI API Key (Source: {source})\")\n\n# Get OAuth Credentials (return None if not found or incomplete)\nclient_id = km.get_oauth_client_id(\"google-oauth-agent\")\nclient_secret = km.get_oauth_client_secret(\"google-oauth-agent\")\nif client_id and client_secret:\n    status = km.get_oauth_config_status(\"google-oauth-agent\")\n    print(f\"Found Google OAuth Credentials ({status})\")\n    print(f\"  Client ID: {client_id}\")\n    # Note: AgentVaultClient uses these to automatically fetch the Bearer token.\n</code></pre></li> <li>Storing Credentials (Primarily for CLI/Setup): Use <code>km.set_key_in_keyring(...)</code> or <code>km.set_oauth_creds_in_keyring(...)</code>. Requires <code>use_keyring=True</code>.</li> </ul> <p>(See KeyManager Guide for full details)</p>"},{"location":"guides/client_library/#agentvaultclient-clientpy","title":"<code>AgentVaultClient</code> (<code>client.py</code>)","text":"<p>The primary class for making asynchronous A2A calls to remote agents.</p> <ul> <li>Purpose: Handles HTTP requests (using <code>httpx</code>), authentication logic (including OAuth2 Client Credentials token fetching/caching), JSON-RPC formatting, SSE streaming, and response parsing according to the A2A Profile v0.2.</li> <li> <p>Usage: Best used as an async context manager (<code>async with</code>) to ensure the underlying HTTP client is properly closed. Requires an <code>AgentCard</code> instance (loaded via <code>agent_card_utils</code>) and a <code>KeyManager</code> instance for authentication.</p> </li> <li> <p>Key Methods:</p> <ul> <li><code>initiate_task(...)</code>: Starts a new task.<ul> <li><code>agent_card</code>: Target <code>AgentCard</code> object.</li> <li><code>initial_message</code>: <code>Message</code> object with initial input.</li> <li><code>key_manager</code>: <code>KeyManager</code> instance.</li> <li><code>mcp_context</code> (Optional): Dictionary for Model Context Protocol data.</li> <li><code>webhook_url</code> (Optional): URL for push notifications (if agent supports).</li> <li>Returns: <code>str</code> (the unique Task ID).</li> </ul> </li> <li><code>send_message(...)</code>: Sends a follow-up message to an existing task.<ul> <li><code>agent_card</code>, <code>task_id</code>, <code>message</code>, <code>key_manager</code>, <code>mcp_context</code> (Optional).</li> <li>Returns: <code>bool</code> (True on acknowledgement, raises error otherwise).</li> </ul> </li> <li><code>get_task_status(...)</code>: Retrieves the full state of a task.<ul> <li><code>agent_card</code>, <code>task_id</code>, <code>key_manager</code>.</li> <li>Returns: <code>Task</code> object.</li> </ul> </li> <li><code>terminate_task(...)</code>: Requests cancellation of a task.<ul> <li><code>agent_card</code>, <code>task_id</code>, <code>key_manager</code>.</li> <li>Returns: <code>bool</code> (True if request acknowledged).</li> </ul> </li> <li><code>receive_messages(...)</code>: Subscribes to and yields Server-Sent Events (SSE) for a task.<ul> <li><code>agent_card</code>, <code>task_id</code>, <code>key_manager</code>.</li> <li>Returns: <code>AsyncGenerator[A2AEvent, None]</code> (yields <code>TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>, or potentially error dicts).</li> </ul> </li> </ul> </li> <li> <p>Example: <pre><code>import asyncio\nimport logging\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, TextPart,\n    agent_card_utils, exceptions as av_exceptions, models as av_models\n)\n\nlogging.basicConfig(level=logging.INFO)\n\nasync def run_agent_task(agent_ref: str, input_text: str):\n    key_manager = KeyManager(use_keyring=True)\n    agent_card = None\n    task_id = None\n\n    try:\n        # --- 1. Load Agent Card (Use appropriate util) ---\n        agent_card = await agent_card_utils.fetch_agent_card_from_url(agent_ref)\n        if not agent_card: raise ValueError(\"Card not found\")\n\n        # --- 2. Prepare Initial Message ---\n        initial_message = Message(role=\"user\", parts=[TextPart(content=input_text)])\n\n        # --- 3. Interact using AgentVaultClient ---\n        async with AgentVaultClient() as client:\n            print(\"Initiating task...\")\n            task_id = await client.initiate_task(\n                agent_card=agent_card, initial_message=initial_message, key_manager=key_manager\n            )\n            print(f\"Task initiated: {task_id}\")\n\n            print(\"Streaming events...\")\n            async for event in client.receive_messages(\n                agent_card=agent_card, task_id=task_id, key_manager=key_manager\n            ):\n                # Process different event types\n                if isinstance(event, av_models.TaskStatusUpdateEvent):\n                    print(f\"  Status: {event.state}\")\n                    if event.state.is_terminal(): break\n                elif isinstance(event, av_models.TaskMessageEvent):\n                    if event.message.role == \"assistant\":\n                        for part in event.message.parts:\n                            if isinstance(part, TextPart): print(f\"  Assistant: {part.content}\")\n                # Add handling for TaskArtifactUpdateEvent, errors etc.\n                else:\n                    print(f\"  Other Event: {type(event)}\")\n\n            print(\"Stream finished.\")\n\n    except av_exceptions.AgentVaultError as e: # Catch base AgentVault errors\n        print(f\"AgentVault Error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected Error: {e}\")\n\n# Example: asyncio.run(run_agent_task(\"http://localhost:8000/agent-card.json\", \"Hello\"))\n</code></pre></p> </li> </ul>"},{"location":"guides/client_library/#models-agentvaultmodels","title":"Models (<code>agentvault.models</code>)","text":"<p>Pydantic models defining the data structures for Agent Cards (<code>AgentCard</code>, <code>AgentProvider</code>, etc.) and the A2A protocol (<code>Message</code>, <code>Part</code>, <code>Task</code>, <code>TaskState</code>, <code>A2AEvent</code>, etc.). Refer to the source code docstrings or the A2A Profile v0.2 for details.</p>"},{"location":"guides/client_library/#exceptions-agentvaultexceptions","title":"Exceptions (<code>agentvault.exceptions</code>)","text":"<p>Custom exceptions provide granular error handling. Catching these allows for more robust client applications. Key exceptions include:</p> <ul> <li><code>AgentCardError</code>, <code>AgentCardValidationError</code>, <code>AgentCardFetchError</code></li> <li><code>A2AError</code>, <code>A2AConnectionError</code>, <code>A2AAuthenticationError</code>, <code>A2ARemoteAgentError</code>, <code>A2ATimeoutError</code>, <code>A2AMessageError</code></li> <li><code>KeyManagementError</code></li> </ul> <p>See the <code>AgentVaultClient</code> example above and the <code>exceptions.py</code> source for details.</p>"},{"location":"guides/client_library/#utilities-agentvaultagent_card_utils-agentvaultmcp_utils","title":"Utilities (<code>agentvault.agent_card_utils</code>, <code>agentvault.mcp_utils</code>)","text":"<ul> <li><code>agent_card_utils</code>: Functions (<code>load_agent_card_from_file</code>, <code>fetch_agent_card_from_url</code>, <code>parse_agent_card_from_dict</code>) to obtain and validate <code>AgentCard</code> objects.</li> <li><code>mcp_utils</code>: Helpers for handling Model Context Protocol data.<ul> <li><code>format_mcp_context</code>: Validates and formats a dictionary for embedding into <code>message.metadata[\"mcp_context\"]</code>.</li> <li><code>get_mcp_context</code>: Safely extracts the <code>mcp_context</code> dictionary from a received <code>Message</code>.</li> </ul> </li> </ul>"},{"location":"guides/getting_started/","title":"Getting Started Guide","text":"<p>This guide provides a quick start for users and developers looking to use the core AgentVault tools (CLI and Client Library) to find and interact with A2A agents.</p>"},{"location":"guides/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: Version 3.10 or 3.11.</li> <li>pip: Python's package installer.</li> <li>(Optional but Recommended) OS Keyring Backend: For secure credential storage (<code>keyring</code> library extras might be needed depending on your OS - see Keyring documentation).</li> </ul>"},{"location":"guides/getting_started/#1-install-agentvault-tools","title":"1. Install AgentVault Tools","text":"<p>Install the command-line interface (CLI), which also includes the core client library:</p> <pre><code># Basic installation\npip install agentvault-cli\n\n# Recommended: Install with OS Keyring support\npip install \"agentvault-cli[os_keyring]\"\n</code></pre> <p>Verify the installation:</p> <pre><code>agentvault_cli --version\n# Expected output: agentvault-cli, version X.Y.Z\n</code></pre>"},{"location":"guides/getting_started/#2-discover-agents","title":"2. Discover Agents","text":"<p>The AgentVault Registry acts as a phonebook for agents. You can search it using the CLI. By default, the CLI uses the public registry hosted at <code>https://agentvault-registry-api.onrender.com</code>.</p> <p>(Note: The public registry runs on a free tier and may take up to 60 seconds to respond to the first request after inactivity. You can visit <code>https://agentvault-registry-api.onrender.com/health</code> in your browser to wake it up.)</p> <pre><code># List the first few registered agents\nagentvault_cli discover --limit 5\n\n# Search for agents related to \"weather\"\nagentvault_cli discover weather\n\n# Search for agents with specific tags\nagentvault_cli discover --tags translation --tags french\n\n# Search for agents declaring TEE support\nagentvault_cli discover --has-tee true\n\n# Use a different registry (e.g., a local one)\n# agentvault_cli discover --registry http://localhost:8000 weather\n</code></pre> <p>Take note of the Agent ID (e.g., <code>examples/simple-agent</code>, <code>your-org/your-agent</code>) or the Agent Card URL of the agent you want to interact with.</p>"},{"location":"guides/getting_started/#3-configure-credentials-if-required","title":"3. Configure Credentials (If Required)","text":"<p>Many agents require authentication (like an API key) to use them. The agent's <code>AgentCard</code> specifies the required <code>authSchemes</code> and often a <code>service_identifier</code>. You need to configure the corresponding credential locally using the <code>agentvault_cli config set</code> command.</p> <p>Example: Imagine you want to use an agent with ID <code>some-org/fancy-translator</code> which requires an API key, and its Agent Card specifies <code>service_identifier: \"fancy_translate_service\"</code>.</p> <ol> <li>Obtain the API key from the agent provider (this happens outside AgentVault).</li> <li> <p>Store the key securely using the CLI, associating it with the <code>service_identifier</code>:     <pre><code># Use the service_identifier from the Agent Card\nagentvault_cli config set fancy_translate_service --keyring\n\n# The CLI will securely prompt for the key:\n# --&gt; Enter API key for 'fancy_translate_service': ********************\n# --&gt; Confirm API key: ********************\n# SUCCESS: API key for 'fancy_translate_service' stored successfully in keyring.\n</code></pre></p> </li> <li> <p>For agents requiring OAuth2 Client Credentials, use the <code>--oauth-configure</code> flag instead:     <pre><code>agentvault_cli config set some-oauth-service --oauth-configure\n# --&gt; Enter OAuth Client ID...\n# --&gt; Enter OAuth Client Secret...\n# --&gt; Confirm OAuth Client Secret...\n</code></pre></p> </li> <li>Always use the OS Keyring (<code>--keyring</code>, <code>--oauth-configure</code>) whenever possible for maximum security.</li> <li>Refer to the KeyManager Guide for details on sources and priority.</li> </ol>"},{"location":"guides/getting_started/#4-run-a-task","title":"4. Run a Task","text":"<p>Now you can interact with the agent using the <code>agentvault_cli run</code> command.</p> <pre><code># --- Using an Agent ID (fetches card from registry) ---\n\n# Agent requires NO authentication\nagentvault_cli run --agent examples/simple-agent --input \"Hello there!\"\n\n# Agent requires API Key (assuming key for 'fancy_translate_service' was configured above)\nagentvault_cli run --agent some-org/fancy-translator --input \"Translate 'hello' to French.\"\n\n# Agent requires API Key, but card didn't specify service_identifier OR\n# you stored the key under a different local name (e.g., 'my_fancy_key')\n# agentvault_cli run --agent some-org/fancy-translator --input \"Translate...\" --key-service my_fancy_key\n\n# --- Using a direct Agent Card URL ---\n# (Authentication still handled via KeyManager based on card's authSchemes)\nagentvault_cli run --agent http://localhost:8000/agent-card.json --input \"Ping!\"\n\n# --- Using a local Agent Card file ---\nagentvault_cli run --agent ./path/to/local-agent-card.json --input \"Local test.\"\n\n# --- Reading input from a file ---\necho \"This is my input text.\" &gt; input.txt\nagentvault_cli run --agent some-org/fancy-translator --input @input.txt\n\n# --- Saving Artifacts ---\n# (If the agent produces artifacts like files)\nmkdir agent_output\nagentvault_cli run --agent some-org/file-generator --input \"Create report\" --output-artifacts ./agent_output\n</code></pre> <p>The CLI will:</p> <ol> <li>Fetch the Agent Card (if an ID is provided).</li> <li>Determine the required authentication using the card's <code>authSchemes</code>.</li> <li>Use <code>KeyManager</code> to retrieve the necessary credentials (using <code>service_identifier</code> from the card or the <code>--key-service</code> flag).</li> <li>Connect to the agent's A2A endpoint (<code>url</code> from the card).</li> <li>Initiate the task (<code>tasks/send</code>).</li> <li>Stream results (status updates, messages, artifacts) back to your terminal using Server-Sent Events (SSE).</li> </ol>"},{"location":"guides/getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore CLI Commands: Use <code>agentvault_cli [command] --help</code> for detailed options.</li> <li>Manage Credentials: Learn more about <code>agentvault_cli config</code> in the KeyManager Guide.</li> <li>Use the Library: Integrate agent interactions into your Python applications using the Client Library Guide.</li> <li>Build Your Own Agent: Refer to the Server SDK Guide.</li> <li>Discover More Agents: Use <code>agentvault_cli discover</code> or browse the Public Registry UI.</li> </ul>"},{"location":"guides/installation/","title":"Installation Guide","text":"<p>This guide covers how to install the different parts of the AgentVault ecosystem, depending on your needs.</p>"},{"location":"guides/installation/#1-installing-for-usage-cli-client-library","title":"1. Installing for Usage (CLI &amp; Client Library)","text":"<p>If you want to use the AgentVault CLI to interact with agents or use the <code>agentvault</code> client library in your own Python projects, install the desired components directly from PyPI (Python Package Index).</p> <p>Prerequisites:</p> <ul> <li>Python 3.10 or 3.11 installed.</li> <li><code>pip</code> (Python's package installer, usually included with Python).</li> <li>(Optional but Recommended) OS Keyring Backend: For secure credential storage with the CLI/Library (<code>keyring</code> library extras might be needed depending on your OS - see Keyring documentation).</li> </ul> <p>Installation Options:</p> <ul> <li> <p>CLI Tool (<code>agentvault-cli</code>):</p> <ul> <li>Includes the core <code>agentvault</code> library as a dependency. <pre><code># Basic installation\npip install agentvault-cli\n\n# Recommended: Install with OS Keyring support for secure credential storage\npip install \"agentvault-cli[os_keyring]\"\n</code></pre></li> </ul> </li> <li> <p>Client Library Only (<code>agentvault</code>):</p> <ul> <li>Use this if you only need to interact with agents programmatically from your own Python code and don't need the CLI application. <pre><code># Basic installation\npip install agentvault\n\n# Recommended: Install with OS Keyring support\npip install \"agentvault[os_keyring]\"\n</code></pre></li> </ul> </li> <li> <p>Server SDK Only (<code>agentvault-server-sdk</code>):</p> <ul> <li>Use this if you are building your own A2A-compliant agent server.</li> <li>Installs the <code>agentvault</code> client library as a dependency. <pre><code>pip install agentvault-server-sdk\n</code></pre></li> </ul> </li> </ul> <p>Verification (CLI):</p> <p>After installing the CLI, check that the command is available:</p> <pre><code>agentvault_cli --version\n# Expected output: agentvault-cli, version X.Y.Z\n</code></pre> <p>Using the Public Registry:</p> <p>The CLI and library can interact with the publicly hosted AgentVault Registry.</p> <ul> <li>Registry URL: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Configure:<ul> <li>Environment Variable (Recommended):<ul> <li>Linux/macOS: <code>export AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code></li> <li>Windows PowerShell: <code>$env:AGENTVAULT_REGISTRY_URL='https://agentvault-registry-api.onrender.com'</code></li> <li>Windows Cmd: <code>set AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code></li> </ul> </li> <li>CLI Flag: Use <code>--registry https://agentvault-registry-api.onrender.com</code> with commands like <code>discover</code> or <code>run</code> (if using an agent ID).</li> </ul> </li> <li>Note (Cold Start): The public registry runs on Render's free tier. It may take up to 60 seconds to respond to the first request after inactivity. Visit <code>/health</code> or <code>/ui</code> to wake it up.</li> <li>Developer Account: Register at <code>https://agentvault-registry-api.onrender.com/ui/register</code>.</li> </ul>"},{"location":"guides/installation/#2-setting-up-for-development-contributing-or-running-from-source","title":"2. Setting up for Development (Contributing or Running from Source)","text":"<p>If you want to contribute to AgentVault, run components locally from the source code (like the registry API), or use features not yet released on PyPI, follow these steps to set up the monorepo development environment.</p> <p>Prerequisites:</p> <ul> <li>Git</li> <li>Python 3.10 or 3.11</li> <li>Poetry (version 1.2+ recommended)</li> <li>(Optional) PostgreSQL Server: Required only if running the <code>agentvault_registry</code> locally.</li> <li>(Optional) SMTP Server/Service: Required only for local registry email features (verification, password reset).</li> </ul> <p>Steps:</p> <ol> <li> <p>Clone the Repository: <pre><code>git clone https://github.com/SecureAgentTools/AgentVault.git\ncd AgentVault\n</code></pre></p> </li> <li> <p>Install Dependencies (using Poetry): Navigate to the project root (<code>AgentVault/</code>) and install dependencies for the entire workspace:     <pre><code># Installs ALL production AND development dependencies for ALL packages\npoetry install --with dev\n\n# To include optional OS Keyring support across components:\n# poetry install --with dev --extras os_keyring\n</code></pre></p> <ul> <li>This reads all <code>pyproject.toml</code> files.</li> <li>It creates a single shared virtual environment (usually <code>.venv/</code> in the root).</li> <li>It installs all packages (library, cli, sdk, registry, testing-utils) in editable mode, along with their dependencies and development tools (like <code>pytest</code>, <code>httpx</code>, <code>uvicorn</code>, <code>alembic</code>, <code>mkdocs</code>).</li> </ul> </li> <li> <p>Activate Virtual Environment: Before running any code, tests, or tools from source, activate the Poetry-managed environment:</p> <ul> <li>Recommended: Use <code>poetry shell</code> from the project root. This spawns a new shell with the environment activated.</li> <li>Manual Activation (Example):<ul> <li>Linux/macOS: <code>source .venv/bin/activate</code></li> <li>Windows PowerShell: <code>.\\.venv\\Scripts\\Activate.ps1</code></li> <li>Windows Cmd: <code>.\\.venv\\Scripts\\activate.bat</code> Your prompt should now indicate you are inside the <code>(.venv)</code> environment.</li> </ul> </li> </ul> </li> <li> <p>Verify Setup: Check access to installed tools:     <pre><code>agentvault_cli --version\npytest --version\nmkdocs --version\nuvicorn --version\n</code></pre></p> </li> </ol> <p>You can now run components directly from source (e.g., <code>uvicorn agentvault_registry.main:app</code> from the <code>agentvault_registry</code> directory) or run tests (<code>pytest agentvault_library/tests/</code>).</p>"},{"location":"guides/installation/#3-running-the-registry-locally-development","title":"3. Running the Registry Locally (Development)","text":"<p>To run the <code>agentvault_registry</code> API service locally:</p> <ol> <li>Complete Development Setup: Follow the steps in section 2 above. Ensure PostgreSQL is running.</li> <li>Navigate: <code>cd agentvault_registry</code></li> <li>Configure <code>.env</code>:<ul> <li>Copy <code>.env.example</code> to <code>.env</code>.</li> <li>Edit <code>.env</code> and set <code>DATABASE_URL</code> to your PostgreSQL connection string (using <code>asyncpg</code> driver, e.g., <code>postgresql+asyncpg://user:pass@host:port/dbname</code>).</li> <li>Set <code>API_KEY_SECRET</code> (e.g., <code>openssl rand -hex 32</code>).</li> <li>(Optional) Configure <code>MAIL_...</code> variables for email features.</li> </ul> </li> <li>Database Migrations: Activate the virtual environment (<code>poetry shell</code> or <code>source .venv/bin/activate</code>) and run from the <code>agentvault_registry/</code> directory:     <pre><code>alembic upgrade head\n</code></pre></li> <li>Run Server: From the <code>agentvault_registry/</code> directory (with venv active):     <pre><code>uvicorn agentvault_registry.main:app --reload --host 0.0.0.0 --port 8000\n</code></pre></li> </ol> <p>The local registry API will be available at <code>http://localhost:8000</code>. Docs at <code>/docs</code>, UI at <code>/ui</code>.</p>"},{"location":"guides/key_manager/","title":"Developer Guide: KeyManager (<code>agentvault.key_manager</code>)","text":"<p>The <code>KeyManager</code> is a core component of the <code>agentvault</code> library responsible for securely managing the credentials (API Keys, OAuth 2.0 Client ID/Secret) that client applications need to authenticate with remote A2A agents.</p>"},{"location":"guides/key_manager/#purpose","title":"Purpose","text":"<ul> <li>Abstraction: Provides a unified interface (<code>get_key()</code>, <code>get_oauth_client_id()</code>, etc.) to retrieve credentials, hiding the underlying storage mechanism (Environment Variables, Files, OS Keyring).</li> <li>Security: Facilitates secure storage by prioritizing the OS Keyring when available and configured.</li> <li>Flexibility: Allows loading credentials from standard sources commonly used in development and deployment workflows.</li> </ul>"},{"location":"guides/key_manager/#credential-sources-priority","title":"Credential Sources &amp; Priority","text":"<p><code>KeyManager</code> loads credentials upon initialization and retrieves them on demand, checking sources in the following order:</p> <ol> <li>Key File Cache (.env or .json): If a <code>key_file_path</code> was provided during initialization, credentials found in that file are loaded into an internal cache. This source takes the highest priority.</li> <li>Environment Variable Cache: If <code>use_env_vars=True</code> (default), credentials found in environment variables matching the expected patterns are loaded into the cache only if not already loaded from the file.</li> <li>OS Keyring (On Demand): If <code>use_keyring=True</code> and a requested credential (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) was not found in the file or environment caches, <code>KeyManager</code> will attempt to load it directly from the OS Keyring (macOS Keychain, Windows Credential Manager, Linux Secret Service via <code>keyring</code> library).</li> </ol> <p>Important: The keyring is checked on demand during <code>get_</code> calls if the credential isn't already cached from file/env. Credentials loaded from the keyring are then cached internally for the lifetime of the <code>KeyManager</code> instance.</p>"},{"location":"guides/key_manager/#service-identifier","title":"Service Identifier","text":"<p>The <code>service_id</code> parameter used in <code>KeyManager</code> methods (e.g., <code>km.get_key(\"openai\")</code>) is the key to retrieving the correct credential.</p> <ul> <li>Definition: A user-defined string acting as a local alias for a specific set of credentials.</li> <li>Case-Insensitive: <code>KeyManager</code> normalizes <code>service_id</code> to lowercase internally for lookups.</li> <li>Source:<ul> <li>Often corresponds to the <code>service_identifier</code> field within an <code>AgentCard</code>'s <code>authSchemes</code>. The <code>AgentVaultClient</code> uses this automatically.</li> <li>Can be explicitly provided by the user/application (e.g., via <code>agentvault_cli run --key-service &lt;your_id&gt;</code>).</li> </ul> </li> <li>Purpose: Allows mapping multiple agents requiring the same credentials (e.g., several agents using the same OpenAI API key) to a single locally stored secret identified by a common <code>service_id</code> like <code>\"openai\"</code>.</li> </ul>"},{"location":"guides/key_manager/#storage-conventions","title":"Storage Conventions","text":"<p>The <code>KeyManager</code> expects credentials to be stored using specific conventions depending on the source:</p> Credential Type Source Convention Example API Key Env Var <code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code> <code>AGENTVAULT_KEY_OPENAI</code> File (.env) <code>&lt;service_id_lower&gt;=key_value</code> <code>openai=sk-...</code> File (.json) <code>{ \"&lt;service_id&gt;\": \"key_value\" }</code> or <code>{ \"&lt;service_id&gt;\": {\"apiKey\": ...}}</code> <code>{ \"openai\": \"sk-...\" }</code> Keyring Service: <code>agentvault:&lt;service_id&gt;</code>, Username: <code>&lt;service_id&gt;</code> Service: <code>agentvault:openai</code>, User: <code>openai</code> OAuth Client ID Env Var <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code> <code>AGENTVAULT_OAUTH_GOOGLE_CLIENT_ID</code> File (.env) <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_ID=id_value</code> <code>AGENTVAULT_OAUTH_google_CLIENT_ID=...</code> File (.json) <code>{ \"&lt;service_id&gt;\": {\"oauth\": {\"clientId\": \"id_value\", ...}}}</code> <code>{ \"google\": {\"oauth\": {\"clientId\": ...}}}</code> Keyring Service: <code>agentvault:oauth:&lt;service_id&gt;</code>, Username: <code>clientId</code> Service: <code>agentvault:oauth:google</code>, User: <code>clientId</code> OAuth Secret Env Var <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code> <code>AGENTVAULT_OAUTH_GOOGLE_CLIENT_SECRET</code> File (.env) <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_SECRET=secret_value</code> <code>AGENTVAULT_OAUTH_google_CLIENT_SECRET=...</code> File (.json) <code>{ \"&lt;service_id&gt;\": {\"oauth\": {..., \"clientSecret\": \"secret_value\"}}}</code> <code>{ \"google\": {\"oauth\": {\"clientSecret\": ...}}}</code> Keyring Service: <code>agentvault:oauth:&lt;service_id&gt;</code>, Username: <code>clientSecret</code> Service: <code>agentvault:oauth:google</code>, User: <code>clientSecret</code> <p>(Note: <code>&lt;SERVICE_ID_UPPER&gt;</code> means the <code>service_id</code> converted to uppercase, <code>&lt;service_id_lower&gt;</code> means lowercase)</p>"},{"location":"guides/key_manager/#initialization","title":"Initialization","text":"<pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Option 1: Defaults - Load from Env Vars only, Keyring disabled\nkm_default = KeyManager()\n\n# Option 2: Load from Env Vars AND use Keyring if needed\n# (Requires 'keyring' package and backend to be installed/functional)\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Option 3: Load ONLY from a specific .env file\n# (Disables Env Vars and Keyring)\nkm_file_only = KeyManager(\n    key_file_path=pathlib.Path(\"./secrets.env\"),\n    use_env_vars=False,\n    use_keyring=False\n)\n\n# Option 4: Load from File THEN Env Vars (File overrides Env)\nkm_file_then_env = KeyManager(\n    key_file_path=\"./my_keys.json\",\n    use_env_vars=True, # Default\n    use_keyring=False\n)\n\n# Option 5: Load from File, then Env, then Keyring\nkm_all = KeyManager(\n    key_file_path=\"./conf/agent_keys.env\",\n    use_env_vars=True,\n    use_keyring=True\n)\n\n# Option 6: Use custom Env Var prefixes\nkm_custom_prefix = KeyManager(\n    env_prefix=\"MYAPP_APIKEY_\",\n    oauth_env_prefix=\"MYAPP_OAUTHCFG_\"\n)\n</code></pre>"},{"location":"guides/key_manager/#usage","title":"Usage","text":""},{"location":"guides/key_manager/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code># Assuming km = KeyManager(use_keyring=True)\n\n# Get API Key\nopenai_key = km.get_key(\"openai\") # Case-insensitive lookup\nif openai_key:\n    print(f\"OpenAI Key found: {openai_key[:4]}...\")\n    source = km.get_key_source(\"openai\")\n    print(f\"Source: {source}\") # e.g., 'env', 'file', 'keyring'\nelse:\n    print(\"OpenAI Key not found.\")\n\n# Get OAuth Credentials for an agent identified as 'my-google-agent'\ngoogle_agent_client_id = km.get_oauth_client_id(\"my-google-agent\")\ngoogle_agent_client_secret = km.get_oauth_client_secret(\"my-google-agent\")\n\nif google_agent_client_id and google_agent_client_secret:\n    print(f\"Found OAuth credentials for my-google-agent:\")\n    print(f\"  Client ID: {google_agent_client_id}\")\n    # Avoid printing the secret!\n    status_str = km.get_oauth_config_status(\"my-google-agent\")\n    print(f\"  Status: {status_str}\")\nelif google_agent_client_id or google_agent_client_secret:\n    print(\"Partially found OAuth credentials for my-google-agent (missing ID or Secret).\")\nelse:\n    print(\"OAuth credentials for my-google-agent not found.\")\n</code></pre>"},{"location":"guides/key_manager/#storing-credentials-via-os-keyring","title":"Storing Credentials (via OS Keyring)","text":"<p>These methods are primarily intended for use by setup tools like <code>agentvault_cli config set</code>.</p> <pre><code>from agentvault import KeyManagementError\n\n# Needs use_keyring=True during init\nkm = KeyManager(use_keyring=True)\n\ntry:\n    # Store an API Key\n    km.set_key_in_keyring(\"anthropic\", \"sk-ant-...\")\n    print(\"Anthropic key stored.\")\n\n    # Store OAuth Credentials\n    km.set_oauth_creds_in_keyring(\n        \"some_oauth_service\",\n        \"your-client-id-here\",\n        \"your-client-secret-here\"\n    )\n    print(\"OAuth credentials stored.\")\n\nexcept KeyManagementError as e:\n    print(f\"Error storing credential in keyring: {e}\")\n    # Handle error (e.g., keyring backend not available)\nexcept ValueError as e:\n    print(f\"Input error: {e}\")\n</code></pre>"},{"location":"guides/key_manager/#security-considerations","title":"Security Considerations","text":"<ul> <li>OS Keyring is Preferred: Storing credentials directly in environment variables or plain text files (<code>.env</code>, <code>.json</code>) carries risks if the environment or file system is compromised. The OS Keyring provides platform-native secure storage.</li> <li>File Permissions: If using file-based storage, ensure the key file has strict permissions (e.g., <code>chmod 600</code> on Linux/macOS) so only the owner can read it.</li> <li>Environment Variables: Be cautious about where and how environment variables are set, especially in shared or logged environments. Avoid committing them to version control.</li> <li>Error Handling: The <code>get_</code> methods return <code>None</code> if a credential isn't found. Methods that interact with the keyring (<code>set_...</code>, or <code>get_...</code> when loading from keyring) can raise <code>KeyManagementError</code> if the keyring backend is unavailable or fails.</li> </ul>"},{"location":"guides/registry_api/","title":"Developer Guide: Registry API (<code>agentvault_registry</code>)","text":"<p>The AgentVault Registry provides a central RESTful API service and Web UI for discovering and managing Agent Cards. Developers interact with it programmatically or via the UI to publish their agents, while clients (like the <code>agentvault_cli</code> or other applications) use it to find agents.</p> <ul> <li>Public Registry &amp; UI: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Public Discovery UI: <code>/ui</code></li> <li>Developer Portal UI: <code>/ui/developer</code></li> <li>API Base Path: <code>/api/v1</code></li> </ul> <p>(Note: The public instance runs on a free tier and may experience cold starts taking up to 60 seconds for the first request after inactivity.)</p>"},{"location":"guides/registry_api/#authentication-developer-registration","title":"Authentication &amp; Developer Registration","text":"<p>Interacting with the registry requires different levels of authentication:</p> <ol> <li>Public Access: Discovering agents (<code>GET /api/v1/agent-cards/</code>, <code>GET /api/v1/agent-cards/{card_id}</code>, <code>GET /api/v1/agent-cards/id/{human_readable_id}</code>) and validating card data (<code>POST /api/v1/utils/validate-card</code>) are generally public and do not require authentication.</li> <li>Developer Account Authentication (JWT): Managing your own agent cards (create, update, deactivate), managing programmatic API keys, and using the agent builder requires you to be logged in as a registered developer. This uses email/password authentication via the <code>/auth/login</code> endpoint, which returns a JSON Web Token (JWT). Subsequent requests to protected developer endpoints must include this JWT in the <code>Authorization: Bearer &lt;token&gt;</code> HTTP header.</li> <li>Programmatic API Key Authentication: For automated scripts or CI/CD pipelines interacting with the registry API (e.g., to update an agent card automatically), developers can generate programmatic API keys. These keys are sent in the <code>X-Api-Key</code> header for specific authenticated endpoints (primarily intended for agent card management, though JWT is preferred for user-driven actions).</li> </ol> <p>Registration Workflow:</p> <ul> <li>Self-Registration: Developers can register via the <code>/ui/register</code> page or the <code>POST /auth/register</code> API endpoint.</li> <li>Required Information: Name, Email, Password.</li> <li>Verification: Upon registration, a verification email is sent to the provided address. The developer must click the link in the email to activate their account (<code>GET /auth/verify-email</code>). Unverified accounts cannot log in.</li> <li>Recovery Keys: During registration, a set of single-use recovery keys are generated and displayed only once. These keys are essential for regaining account access if the password is lost and email reset is unavailable. Store these keys securely offline.</li> <li>Password Reset: A password reset can be requested via email (if email sending is configured on the registry instance) using the <code>/ui/forgot-password</code> page or <code>POST /auth/request-password-reset</code> endpoint. Alternatively, account access can be regained using a recovery key via the <code>/ui/recover-with-key</code> page or <code>POST /auth/recover-account</code> endpoint, which provides a temporary token to set a new password via <code>/ui/set-new-password</code> or <code>POST /auth/set-new-password</code>. Using a recovery key invalidates it.</li> </ul>"},{"location":"guides/registry_api/#api-endpoints","title":"API Endpoints","text":"<p>(Refer to the OpenAPI documentation at <code>/docs</code> or <code>/redoc</code> on the running registry instance for full details, request/response schemas, and interactive testing.)</p>"},{"location":"guides/registry_api/#authentication-auth","title":"Authentication (<code>/auth</code>)","text":"<p>Handles developer registration, login, email verification, and password/account recovery.</p> <ul> <li><code>POST /register</code>: Creates a new developer account. Requires name, email, password. Returns a success message and one-time recovery keys. Triggers verification email.</li> <li><code>POST /login</code>: Authenticates using email/password (sent as form data). Returns a JWT <code>access_token</code> (<code>schemas.Token</code>). Requires verified email.</li> <li><code>GET /verify-email</code>: Endpoint visited via the link in the verification email. Activates the developer account. Redirects user to success/failure UI pages.</li> <li><code>POST /request-password-reset</code>: (Placeholder/Future) Sends a password reset link to the developer's email.</li> <li><code>POST /reset-password</code>: (Placeholder/Future) Sets a new password using a token from the reset email.</li> <li><code>POST /recover-account</code>: Verifies email and a recovery key. Returns a short-lived JWT (<code>schemas.Token</code>) specifically for setting a new password.</li> <li><code>POST /set-new-password</code>: Sets a new password using the temporary token from <code>/recover-account</code>. Requires <code>Authorization: Bearer &lt;temp_token&gt;</code> header and <code>{\"new_password\": \"...\"}</code> body. Invalidates the used recovery key hash.</li> </ul>"},{"location":"guides/registry_api/#developers-developers","title":"Developers (<code>/developers</code>)","text":"<p>Endpoints for managing the authenticated developer's own account and resources. Requires JWT authentication (<code>Authorization: Bearer &lt;token&gt;</code>).</p> <ul> <li><code>GET /me</code>: Returns the profile information (<code>schemas.DeveloperRead</code>) for the currently authenticated developer.</li> <li><code>POST /me/apikeys</code>: Generates a new programmatic API key (prefixed <code>avreg_</code>) associated with the developer. Optionally takes a <code>description</code> in the request body. Returns the plain text key once along with key metadata (<code>schemas.NewApiKeyResponse</code>).</li> <li><code>GET /me/apikeys</code>: Lists metadata (<code>schemas.ApiKeyRead</code>) for all active programmatic API keys belonging to the developer.</li> <li><code>DELETE /me/apikeys/{key_id}</code>: Deactivates (soft deletes) a specific programmatic API key by its integer <code>key_id</code>. Returns <code>204 No Content</code> on success.</li> </ul>"},{"location":"guides/registry_api/#agent-cards-apiv1agent-cards","title":"Agent Cards (<code>/api/v1/agent-cards</code>)","text":"<p>Endpoints for managing and discovering Agent Cards.</p> <ul> <li><code>POST /</code>:<ul> <li>Summary: Submit a new Agent Card.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentCardCreate</code> (contains the <code>card_data</code> dictionary).</li> <li>Response: <code>schemas.AgentCardRead</code> (includes generated UUID, timestamps, <code>developer_is_verified</code> status).</li> <li>Notes: Validates <code>card_data</code>. Extracts <code>name</code>/<code>description</code> for indexing.</li> </ul> </li> <li><code>GET /</code>:<ul> <li>Summary: List Agent Cards (Summaries).</li> <li>Auth: Public, unless <code>owned_only=true</code> is used (requires JWT).</li> <li>Query Params: <code>skip</code>, <code>limit</code>, <code>active_only</code>, <code>search</code>, <code>tags</code>, <code>has_tee</code>, <code>tee_type</code>, <code>owned_only</code>.</li> <li>Response: <code>schemas.AgentCardListResponse</code> (contains <code>items: List[AgentCardSummary]</code> and <code>pagination: PaginationInfo</code>).</li> </ul> </li> <li><code>GET /{card_id}</code>:<ul> <li>Summary: Get Agent Card by UUID.</li> <li>Auth: Public.</li> <li>Response: <code>schemas.AgentCardRead</code> (full card details, including <code>developer_is_verified</code>).</li> </ul> </li> <li><code>GET /id/{human_readable_id:path}</code>:<ul> <li>Summary: Get Agent Card by Human-Readable ID.</li> <li>Auth: Public.</li> <li>Path Param: <code>human_readable_id</code> (e.g., <code>my-org/my-agent</code>). The <code>:path</code> allows slashes.</li> <li>Response: <code>schemas.AgentCardRead</code>.</li> </ul> </li> <li><code>GET /by-hri</code>:<ul> <li>Summary: Get Agent Card by Human-Readable ID (Query Parameter).</li> <li>Auth: Public.</li> <li>Query Param: <code>hri</code> (e.g., <code>my-org/my-agent</code>). Use this if the HRI contains characters problematic for path parameters.</li> <li>Response: <code>schemas.AgentCardRead</code>.</li> </ul> </li> <li><code>PUT /{card_id}</code>:<ul> <li>Summary: Update an Agent Card.</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Request Body: <code>schemas.AgentCardUpdate</code> (can contain <code>card_data</code> and/or <code>is_active</code>). If <code>card_data</code> is present, it replaces the existing card data after validation.</li> <li>Response: <code>schemas.AgentCardRead</code> (updated card details).</li> </ul> </li> <li><code>DELETE /{card_id}</code>:<ul> <li>Summary: Deactivate an Agent Card (Soft Delete).</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Response: <code>204 No Content</code>.</li> </ul> </li> </ul>"},{"location":"guides/registry_api/#agent-builder-agent-builder","title":"Agent Builder (<code>/agent-builder</code>)","text":"<p>Endpoint for generating agent boilerplate code.</p> <ul> <li><code>POST /generate</code>:<ul> <li>Summary: Generate Agent Package.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentBuildConfig</code> (specifies agent name, description, type, backend details, etc.).</li> <li>Response: <code>200 OK</code> with <code>Content-Type: application/zip</code>. The response body is a downloadable ZIP archive containing the generated agent project structure (source code, Dockerfile, config files).</li> <li>Errors: 422 (invalid build config), 500 (generation error).</li> </ul> </li> </ul>"},{"location":"guides/registry_api/#utilities-apiv1utils","title":"Utilities (<code>/api/v1/utils</code>)","text":"<p>Helper endpoints.</p> <ul> <li><code>POST /validate-card</code>:<ul> <li>Summary: Validate Agent Card Data.</li> <li>Auth: Public.</li> <li>Request Body: <code>schemas.AgentCardValidationRequest</code>.</li> <li>Response: <code>schemas.AgentCardValidationResponse</code> (indicates validity and provides details on errors).</li> </ul> </li> </ul>"},{"location":"guides/registry_api/#technology-stack","title":"Technology Stack","text":"<ul> <li>Framework: FastAPI</li> <li>Database: PostgreSQL (using SQLAlchemy ORM and asyncpg driver)</li> <li>Migrations: Alembic</li> <li>Authentication: JWT (python-jose), Passlib (bcrypt hashing)</li> <li>Validation: Pydantic</li> <li>Configuration: Pydantic-Settings, python-dotenv</li> <li>Rate Limiting: SlowAPI</li> <li>Email: fastapi-mail (if configured)</li> <li>Server: Uvicorn</li> </ul>"},{"location":"guides/registry_api/#deployment","title":"Deployment","text":"<ul> <li>Prerequisites: Python 3.10+, PostgreSQL Database.</li> <li>Configuration: Uses environment variables and/or a <code>.env</code> file (see <code>.env.example</code>). Key variables include <code>DATABASE_URL</code> and <code>API_KEY_SECRET</code>. Optional email configuration (<code>MAIL_...</code>).</li> <li>Database Setup: Run <code>alembic upgrade head</code> to apply migrations.</li> <li>Running: Use <code>uvicorn agentvault_registry.main:app --host 0.0.0.0 --port 8000</code>. For production, run behind a reverse proxy (like Nginx) handling HTTPS and use multiple Uvicorn workers or a process manager.</li> <li>Docker: A <code>Dockerfile</code> and <code>docker-compose.yml</code> are provided for containerized deployment, including a PostgreSQL service. See <code>DOCKER_README.md</code>.</li> </ul>"},{"location":"guides/server_sdk/","title":"Developer Guide: Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>The <code>agentvault-server-sdk</code> provides tools and abstractions to simplify the development of A2A-compliant agent servers in Python, particularly when using the FastAPI web framework. It helps you focus on your agent's core logic while the SDK handles much of the A2A protocol boilerplate.</p>"},{"location":"guides/server_sdk/#installation","title":"Installation","text":"<p>Install the SDK from PyPI:</p> <p><pre><code>pip install agentvault-server-sdk\n</code></pre> (Note: This automatically installs the <code>agentvault</code> client library as a dependency).</p> <p>See the main Installation Guide for more details, including setting up a development environment to run from source.</p>"},{"location":"guides/server_sdk/#core-concepts","title":"Core Concepts","text":"<p>The SDK revolves around implementing an agent logic class (inheriting from <code>BaseA2AAgent</code>) and integrating it with a web framework (currently FastAPI).</p>"},{"location":"guides/server_sdk/#1-basea2aagent-agentpy","title":"1. <code>BaseA2AAgent</code> (<code>agent.py</code>)","text":"<p>This is the abstract base class your agent logic should inherit from.</p> <ul> <li>Purpose: Defines the standard interface the A2A protocol expects an agent server to fulfill.</li> <li>Required Methods: If you are not using the <code>@a2a_method</code> decorator for all standard methods, you must implement these <code>async</code> methods in your subclass:<ul> <li><code>handle_task_send(task_id: Optional[str], message: Message) -&gt; str</code>: Processes incoming messages (<code>tasks/send</code> JSON-RPC method). Should handle task creation or updates and return the task ID.</li> <li><code>handle_task_get(task_id: str) -&gt; Task</code>: Retrieves the full state (<code>Task</code> model) of a specific task (<code>tasks/get</code> JSON-RPC method).</li> <li><code>handle_task_cancel(task_id: str) -&gt; bool</code>: Attempts to cancel a task (<code>tasks/cancel</code> JSON-RPC method), returning <code>True</code> if the request is accepted.</li> <li><code>handle_subscribe_request(task_id: str) -&gt; AsyncGenerator[A2AEvent, None]</code>: Returns an async generator yielding <code>A2AEvent</code> objects for SSE streaming (<code>tasks/sendSubscribe</code> JSON-RPC method). The SDK router consumes this generator.</li> </ul> </li> <li>Alternative (<code>@a2a_method</code>): For agents handling only specific or custom methods, or if you prefer a decorator-based approach, you can use the <code>@a2a_method</code> decorator on individual methods instead of implementing all <code>handle_...</code> methods (see below).</li> </ul>"},{"location":"guides/server_sdk/#2-task-state-management-statepy","title":"2. Task State Management (<code>state.py</code>)","text":"<p>Handling asynchronous tasks requires managing their state (Submitted, Working, Completed, etc.) and potentially associated data (messages, artifacts). The SDK provides tools for this.</p> <ul> <li><code>TaskContext</code>: A basic dataclass holding <code>task_id</code>, <code>current_state</code>, <code>created_at</code>, <code>updated_at</code>. You can subclass this to store agent-specific task data.     <pre><code># Example of extending TaskContext\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom agentvault.models import Message, Artifact\nfrom agentvault_server_sdk.state import TaskContext\n\n@dataclass\nclass MyAgentTaskContext(TaskContext):\n    conversation_history: List[Message] = field(default_factory=list)\n    generated_artifacts: List[Artifact] = field(default_factory=list)\n    # Add other fields your agent needs to track per task\n</code></pre></li> <li><code>BaseTaskStore</code>: An abstract base class defining the interface for storing, retrieving, updating, and deleting <code>TaskContext</code> objects (e.g., <code>create_task</code>, <code>get_task</code>, <code>update_task_state</code>, <code>delete_task</code>). It also defines the interface for managing SSE event listeners (<code>add_listener</code>, <code>remove_listener</code>) and notifying them (<code>notify_status_update</code>, <code>notify_message_event</code>, <code>notify_artifact_event</code>).</li> <li><code>InMemoryTaskStore</code>: A simple, non-persistent dictionary-based implementation of <code>BaseTaskStore</code>. Suitable only for development or single-instance agents where task state loss on restart is acceptable. Production agents typically require implementing a custom <code>BaseTaskStore</code> backed by a persistent database (SQL, NoSQL) or a distributed cache (Redis).</li> <li>Notification Helpers: When using a <code>BaseTaskStore</code> implementation (like <code>InMemoryTaskStore</code> or your own), your agent logic (e.g., background processing tasks) should call methods like <code>task_store.notify_status_update(...)</code>, <code>task_store.notify_message_event(...)</code>, <code>task_store.notify_artifact_event(...)</code> whenever a relevant event occurs (e.g., state change, message generation, artifact creation). The <code>create_a2a_router</code> integration uses these notifications to automatically format and send the correct SSE events to subscribed clients via the <code>handle_subscribe_request</code> stream.</li> </ul>"},{"location":"guides/server_sdk/#3-fastapi-integration-fastapi_integrationpy","title":"3. FastAPI Integration (<code>fastapi_integration.py</code>)","text":"<p>The <code>create_a2a_router</code> function bridges your agent logic (either a <code>BaseA2AAgent</code> subclass or a class using <code>@a2a_method</code>) with the FastAPI web framework.</p> <ul> <li>Purpose: Creates a FastAPI <code>APIRouter</code> that automatically exposes the standard A2A JSON-RPC methods (<code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>) and routes them to your agent implementation's corresponding <code>handle_...</code> methods or decorated methods. It also handles JSON-RPC request parsing, basic validation, and SSE stream setup.</li> <li>Authentication: Note that authentication (e.g., checking <code>X-Api-Key</code> or <code>Authorization</code> headers) is typically handled before the request reaches the A2A router, usually via FastAPI Dependencies applied to the router or the main app. The SDK router itself does not perform authentication checks.</li> <li>Usage:<ol> <li>Instantiate Agent and Task Store: <pre><code>from fastapi import FastAPI\nfrom agentvault_server_sdk import BaseA2AAgent\nfrom agentvault_server_sdk.state import InMemoryTaskStore # Or your custom store\n# Import your agent class\nfrom my_agent_logic import MyAgent\n\ntask_store = InMemoryTaskStore()\nmy_agent_instance = MyAgent(task_store_ref=task_store) # Pass store if needed\n</code></pre></li> <li>Create the A2A Router: Pass the agent instance and the task store. Optionally pass <code>dependencies</code> (a list of FastAPI <code>Depends()</code> calls) to apply authentication/other checks to all A2A routes.     <pre><code>from agentvault_server_sdk import create_a2a_router\nfrom fastapi import Depends # If adding dependencies\n\n# Example: Add a dependency (replace with your actual auth logic)\n# async def verify_api_key(x_api_key: str = Header(...)): ...\n# router_deps = [Depends(verify_api_key)]\n\na2a_router = create_a2a_router(\n    agent=my_agent_instance,\n    task_store=task_store, # Required for SSE notifications\n    dependencies=[] # Or pass router_deps if needed\n)\n</code></pre></li> <li>Create FastAPI App and Include Router: Mount the router, typically at <code>/a2a</code>.     <pre><code>app = FastAPI(title=\"My A2A Agent\")\napp.include_router(a2a_router, prefix=\"/a2a\") # Standard path\n</code></pre></li> <li>Add Exception Handlers (CRITICAL): Add the SDK's exception handlers to your main FastAPI <code>app</code>. This ensures correct JSON-RPC error formatting.     <pre><code># (Imports assumed from fastapi_integration.py)\napp.add_exception_handler(TaskNotFoundError, task_not_found_handler)\napp.add_exception_handler(ValueError, validation_exception_handler)\napp.add_exception_handler(TypeError, validation_exception_handler)\napp.add_exception_handler(PydanticValidationError, validation_exception_handler)\napp.add_exception_handler(AgentServerError, agent_server_error_handler)\napp.add_exception_handler(Exception, generic_exception_handler) # Catch-all LAST\n</code></pre></li> </ol> </li> </ul>"},{"location":"guides/server_sdk/#4-a2a-method-decorator-a2a_method","title":"4. A2A Method Decorator (<code>@a2a_method</code>)","text":"<p>An alternative or supplement to implementing the full <code>BaseA2AAgent</code> interface.</p> <ul> <li>Purpose: Expose individual <code>async def</code> methods as specific JSON-RPC methods. Useful for simpler agents or custom methods.</li> <li>Usage: <pre><code>from agentvault_server_sdk import BaseA2AAgent, a2a_method, BaseTaskStore\nfrom agentvault.models import Task # Example import\n\nclass DecoratedAgent(BaseA2AAgent): # Still inherit for structure\n\n    def __init__(self, task_store: BaseTaskStore):\n        self.task_store = task_store # Inject store if needed\n\n    @a2a_method(\"custom/ping\")\n    async def ping_handler(self) -&gt; str:\n        return \"pong\"\n\n    @a2a_method(\"tasks/get\") # Override standard method\n    # Add BaseTaskStore dependency if method needs it\n    async def custom_get_task(self, task_id: str, task_store: BaseTaskStore) -&gt; Task:\n        # Params validated from type hints\n        task_context = await task_store.get_task(task_id)\n        if not task_context: raise TaskNotFoundError(task_id)\n        # ... build Task object ...\n        return Task(...) # Return value validated\n\n    # No need to implement handle_task_get if decorated method exists\n</code></pre></li> <li>Validation: <code>create_a2a_router</code> validates incoming <code>params</code> against the function's type hints (using Pydantic). Return values are also validated. Standard FastAPI dependencies (like <code>Header</code>, <code>Query</code>, <code>Depends</code>) can be used within decorated methods.</li> </ul>"},{"location":"guides/server_sdk/#5-packaging-tool-agentvault-sdk-package-packagerclipy","title":"5. Packaging Tool (<code>agentvault-sdk package</code>) (<code>packager/cli.py</code>)","text":"<p>A CLI tool to help prepare your agent project for deployment, typically via Docker.</p> <ul> <li>Command: <code>agentvault-sdk package [OPTIONS]</code></li> <li>Functionality: Generates a standard multi-stage <code>Dockerfile</code>, a <code>.dockerignore</code> file, and copies <code>requirements.txt</code> and optionally <code>agent-card.json</code> to a specified output directory.</li> <li>Key Options: <code>--output-dir</code>, <code>--entrypoint</code>, <code>--python</code>, <code>--suffix</code>, <code>--port</code>, <code>--requirements</code>, <code>--agent-card</code>.</li> <li>Example: <pre><code># Assuming FastAPI app is src/my_agent/main.py::app\nagentvault-sdk package -o ./build -e my_agent.main:app -r requirements.txt -c agent-card.json\n# Then build: docker build -t my-agent:latest -f ./build/Dockerfile .\n</code></pre></li> </ul>"},{"location":"guides/server_sdk/#building-a-basic-agent-summary","title":"Building a Basic Agent (Summary)","text":"<ol> <li>Define Agent Logic: Subclass <code>BaseA2AAgent</code> or use <code>@a2a_method</code>.</li> <li>Implement Handlers/Methods: Implement <code>async handle_...</code> or decorate methods.</li> <li>Manage State: Choose/implement <code>BaseTaskStore</code> (e.g., <code>InMemoryTaskStore</code>). Call <code>notify_...</code> methods from background tasks.</li> <li>Create FastAPI App: Standard <code>main.py</code>.</li> <li>Instantiate &amp; Integrate: Create agent/store instances, use <code>create_a2a_router</code>, include in app.</li> <li>Add Exception Handlers: Add SDK handlers to the main <code>app</code>.</li> <li>Create Agent Card: Write <code>agent-card.json</code> pointing to the <code>/a2a</code> endpoint.</li> <li>Run/Package: Use <code>uvicorn</code> or <code>agentvault-sdk package</code> + <code>docker build</code>.</li> </ol> <p>Refer to the Basic A2A Server Example and Stateful Agent Example for complete implementations.</p>"},{"location":"user_guide/cli/","title":"User Guide: AgentVault CLI (<code>agentvault_cli</code>)","text":"<p>The <code>agentvault_cli</code> is your command-line tool for interacting with the AgentVault ecosystem. It allows you to manage credentials for accessing agents, discover agents registered in the central registry, and execute tasks on remote A2A-compliant agents.</p>"},{"location":"user_guide/cli/#installation","title":"Installation","text":"<p>Please refer to the main Installation Guide for instructions on installing the CLI using <code>pip</code>.</p>"},{"location":"user_guide/cli/#core-commands","title":"Core Commands","text":"<p>The CLI is structured around several main commands. Get an overview by running:</p> <pre><code>agentvault_cli --help\n</code></pre>"},{"location":"user_guide/cli/#config","title":"<code>config</code>","text":"<p>Manage local API keys and OAuth credentials required to authenticate with different agents or services. Credentials can be stored securely in the OS keyring or referenced via environment variables or files.</p> <p>Usage:</p> <pre><code>agentvault_cli config --help\n</code></pre> <p>This command group helps you configure how the <code>agentvault_cli run</code> command (and underlying library) finds the necessary secrets to talk to different agents.</p> <p>Key Subcommands:</p> <ul> <li> <p><code>set &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Configure how credentials for a specific service (identified by <code>&lt;service_id&gt;</code>) are sourced or stored. The <code>&lt;service_id&gt;</code> is a name you choose locally (e.g., <code>openai</code>, <code>my-custom-agent-key</code>, <code>google-oauth-agent</code>) that the <code>KeyManager</code> uses to find the right secret. It often corresponds to the <code>service_identifier</code> in an Agent Card's <code>authSchemes</code>, but can be different.</li> <li>Options:<ul> <li><code>--env</code>: Guidance Only. Prints instructions on how to set environment variables (<code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code>). It does not store anything itself.</li> <li><code>--file &lt;path&gt;</code>: Guidance Only. Prints instructions on how to format a <code>.env</code> or <code>.json</code> file to store credentials that the <code>KeyManager</code> could potentially load (if configured during library initialization, which the CLI doesn't do by default).</li> <li><code>--keyring</code>: Stores API Key. Securely prompts for an API key and stores it in your operating system's default keyring, associated with the <code>&lt;service_id&gt;</code>. This is the recommended secure method for storing API keys via the CLI.</li> <li><code>--oauth-configure</code>: Stores OAuth Credentials. Securely prompts for an OAuth 2.0 Client ID and Client Secret and stores them in the OS keyring, associated with the <code>&lt;service_id&gt;</code>. Required for agents using the <code>oauth2</code> authentication scheme.</li> </ul> </li> </ul> <p>Example (Store OpenAI API Key securely): <pre><code># Use 'openai' as the local service_id\nagentvault_cli config set openai --keyring\n# --&gt; Enter API key: ************\n# --&gt; Confirm API key: ************\n# SUCCESS: API key for 'openai' stored successfully in keyring.\n</code></pre> Example (Configure OAuth for a Google agent): <pre><code># Use 'google-agent-oauth' as the local service_id\nagentvault_cli config set google-agent-oauth --oauth-configure\n# --&gt; Enter OAuth Client ID for 'google-agent-oauth': &lt;paste_client_id&gt;\n# --&gt; Enter OAuth Client Secret for 'google-agent-oauth': ************\n# --&gt; Confirm OAuth Client Secret for 'google-agent-oauth': ************\n# SUCCESS: OAuth credentials for 'google-agent-oauth' stored successfully in keyring.\n</code></pre> Example (Guidance for Environment Variables): <pre><code>agentvault_cli config set anthropic --env\n# --&gt; Guidance: To use environment variables for 'anthropic':\n# --&gt;   For API Key: Set AGENTVAULT_KEY_ANTHROPIC=&lt;your_api_key&gt;\n# --&gt;   ... (OAuth guidance also shown) ...\n</code></pre></p> </li> <li> <p><code>get &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Checks how credentials for a given <code>&lt;service_id&gt;</code> are currently being sourced by the <code>KeyManager</code> (Environment, File, Keyring). It checks the cache first, then attempts to load from the keyring if enabled.</li> <li>Options:<ul> <li><code>--show-key</code>: Displays the first few characters of the found API key (use with caution).</li> <li><code>--show-oauth-id</code>: Displays the configured OAuth Client ID if found. Example: <pre><code>agentvault_cli config get openai\n# --&gt; Credential status for service 'openai':\n# --&gt;   API Key: Found (Source: KEYRING)\n# --&gt;     (Use --show-key to display a masked version)\n# --&gt;   OAuth Credentials: Not Configured\n\nagentvault_cli config get google-agent-oauth --show-oauth-id\n# --&gt; Credential status for service 'google-agent-oauth':\n# --&gt;   API Key: Not Found\n# --&gt;   OAuth Credentials: Configured (Source: KEYRING)\n# --&gt;     Client ID: 12345-abcde.apps.googleusercontent.com\n</code></pre></li> </ul> </li> </ul> </li> <li> <p><code>list</code>:</p> <ul> <li>Purpose: Shows a summary of services for which credentials have been detected during initialization from environment variables or specified key files (if the underlying library was configured with a key file path, which the default CLI is not).</li> <li>Note: This command does not actively scan the OS keyring. Keys stored only in the keyring will typically not appear in this list unless they were accessed previously by a <code>get</code> command in the same CLI invocation.</li> </ul> </li> </ul>"},{"location":"user_guide/cli/#discover","title":"<code>discover</code>","text":"<p>Search for agents registered in the central AgentVault Registry.</p> <p>Usage:</p> <pre><code>agentvault_cli discover --help\nagentvault_cli discover [SEARCH_QUERY] [OPTIONS]\n</code></pre> <ul> <li><code>[SEARCH_QUERY]</code> (Optional): Text to search for (case-insensitive) in agent names or descriptions.</li> <li><code>--registry &lt;url&gt;</code>: Specify the URL of the AgentVault Registry API.<ul> <li>Defaults to the value of the <code>AGENTVAULT_REGISTRY_URL</code> environment variable if set.</li> <li>If the environment variable is not set, it defaults to the public registry: <code>https://agentvault-registry-api.onrender.com</code>.</li> <li>(Note: The public registry runs on a free tier and may take up to 60 seconds to wake up on the first request.)</li> </ul> </li> <li><code>--limit &lt;n&gt;</code>: Maximum results per page (default: 25, max: 250).</li> <li><code>--offset &lt;n&gt;</code>: Number of results to skip (for pagination, default: 0).</li> <li><code>--tags &lt;tag&gt;</code> (Repeatable): Filter by tags. Only agents possessing all specified tags will be returned (e.g., <code>--tags weather --tags forecast</code>).</li> <li><code>--has-tee [true|false]</code> (Optional): Filter agents based on whether they declare TEE support in their Agent Card.</li> <li><code>--tee-type &lt;type&gt;</code> (Optional): Filter agents by the specific TEE type declared (e.g., <code>AWS Nitro Enclaves</code>, <code>Intel SGX</code>).</li> </ul> <p>Example: <pre><code># List first 10 agents containing \"weather\" from the public registry\nagentvault_cli discover weather --limit 10\n\n# List agents tagged with \"nlp\" from a local registry\nagentvault_cli discover --tags nlp --registry http://localhost:8000\n\n# Find agents declaring TEE support on the public registry\nagentvault_cli discover --has-tee true\n</code></pre></p> <p>The output is displayed in a table format.</p>"},{"location":"user_guide/cli/#run","title":"<code>run</code>","text":"<p>Execute a task on a specific remote agent using the A2A protocol.</p> <p>Usage:</p> <pre><code>agentvault_cli run --help\nagentvault_cli run --agent &lt;agent_ref&gt; --input &lt;input_data&gt; [OPTIONS]\n</code></pre> <ul> <li><code>--agent &lt;agent_ref&gt;</code> / <code>-a &lt;agent_ref&gt;</code> (Required): Identifies the target agent. This is crucial. It can be:<ul> <li>An Agent ID from the registry (e.g., <code>examples/simple-agent</code>, <code>my-org/my-agent</code>). The CLI will use the <code>--registry</code> URL to fetch the corresponding Agent Card.</li> <li>A direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>A local file path to the agent's <code>agent-card.json</code> (e.g., <code>../examples/basic_a2a_server/agent-card.json</code>).</li> </ul> </li> <li><code>--input &lt;input_data&gt;</code> / <code>-i &lt;input_data&gt;</code> (Required): The input text for the agent's task.<ul> <li>To read input from a file, prefix the path with <code>@</code>. Example: <code>--input @./prompts/my_request.txt</code>.</li> </ul> </li> <li><code>--context-file &lt;path&gt;</code>: Path to a local JSON file containing MCP context data to send with the initial message.</li> <li><code>--registry &lt;url&gt;</code>: Registry URL (only used if <code>&lt;agent_ref&gt;</code> is an Agent ID). Defaults to <code>AGENTVAULT_REGISTRY_URL</code> env var or the public registry <code>https://agentvault-registry-api.onrender.com</code>. (Note the cold start delay for the public instance).</li> <li><code>--key-service &lt;service_id&gt;</code>: Important for Authentication. If the agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>) and its Agent Card doesn't specify a <code>service_identifier</code>, or if you want to use credentials stored under a different local name, use this flag to tell the <code>KeyManager</code> which local service ID to use for lookup. Example: <code>--key-service openai</code>.</li> <li><code>--auth-key &lt;key&gt;</code>: INSECURE - FOR TESTING ONLY. Directly provide the API key on the command line. This bypasses the <code>KeyManager</code> lookup for agents using the <code>apiKey</code> scheme. Avoid using this for sensitive keys.</li> <li><code>--output-artifacts &lt;directory&gt;</code>: If provided, artifact content larger than 1KB received via SSE will be saved to files in this directory (named using artifact ID and inferred extension) instead of being printed (truncated) to the console.</li> </ul> <p>Example (Running the basic SDK example agent locally): <pre><code># Assumes the basic_a2a_server example is running on port 8000\nagentvault_cli run --agent http://localhost:8000/agent-card.json --input \"Hello Agent!\"\n</code></pre></p> <p>Example (Running an agent from the public registry requiring an OpenAI key): <pre><code># First, ensure the key is configured:\n# agentvault config set openai --keyring (and enter key)\n\n# Then run the task (assuming agent 'some-org/openai-agent' uses 'openai' service ID)\n# The --registry flag is omitted, so it uses the default public registry\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize the concept of AI agents.\"\n\n# Or, if the agent card didn't specify 'openai' as service_identifier:\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize...\" --key-service openai\n</code></pre></p> <p>The <code>run</code> command connects to the agent and streams Server-Sent Events (SSE) back to your terminal, showing status updates, messages from the agent/tools, and artifact information using <code>rich</code> formatting for better readability.</p>"},{"location":"user_guide/cli/#usage-tips","title":"Usage Tips","text":"<p>(Same as before - Shell History, fzf + awk)</p>"},{"location":"user_guide/cli/#re-running-run-commands","title":"Re-running <code>run</code> Commands","text":"<p>The <code>agentvault_cli run</code> command can sometimes involve long agent identifiers or input strings. To easily recall and reuse previous commands:</p> <ul> <li>Shell History Search (Ctrl+R): Most shells allow you to search your command history interactively. Press <code>Ctrl+R</code> and start typing parts of the command you want to find (e.g., <code>run</code>, the agent ID, part of the input).</li> <li><code>history</code> Command: Use <code>history | grep agentvault_cli run</code> (or similar filter) to list previous run commands. You can then execute a specific command number (e.g., <code>!123</code>).</li> <li><code>fzf</code> (Fuzzy Finder): If you have <code>fzf</code> installed, you can pipe your history to it for interactive fuzzy searching: <code>history | fzf</code>. Select the desired command and press Enter to execute it. This is very powerful for quickly finding complex commands.</li> </ul>"},{"location":"user_guide/cli/#interactive-agent-selection-discover-fzf","title":"Interactive Agent Selection (<code>discover</code> + <code>fzf</code>)","text":"<p>If you have command-line tools like <code>fzf</code> (fuzzy finder) and <code>awk</code> installed, you can create powerful interactive workflows. For example, to discover agents, select one interactively, and then immediately run a task on it:</p> <pre><code># Example: Discover agents matching \"weather\", select one, run with input\n# Assumes default public registry or AGENTVAULT_REGISTRY_URL is set\nagentvault_cli discover weather | fzf --height 40% --border --header \"Select Agent:\" | awk '{print $1}' | xargs -I {} agentvault_cli run --agent {} --input \"What is the forecast for London?\"\n</code></pre> <p>Explanation:</p> <ol> <li><code>agentvault_cli discover weather</code>: Lists agents matching \"weather\" from the configured registry.</li> <li><code>| fzf ...</code>: Pipes the list to <code>fzf</code> for interactive selection.</li> <li><code>| awk '{print $1}'</code>: Extracts the first column (the Agent ID) from the line selected in <code>fzf</code>. Note: You might need to adjust <code>$1</code> if the ID is in a different column based on your terminal width or <code>discover</code> output format.</li> <li><code>| xargs -I {} ...</code>: Takes the extracted ID (<code>{}</code>) and inserts it into the <code>agentvault_cli run</code> command.</li> </ol> <p>This allows you to quickly find and use agents without manually copying and pasting IDs.</p>"}]}