{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AgentVault","text":"<p>AgentVault is an open-source ecosystem designed to facilitate secure and interoperable communication between AI agents (Agent-to-Agent or A2A).</p> <p>In a world with increasingly sophisticated and numerous AI agents, the ability for them to discover each other, communicate reliably, and collaborate securely is paramount. AgentVault provides the foundational infrastructure and tooling to make this possible, fostering a more connected and capable AI landscape.</p> <p>This documentation serves as the central hub for understanding, using, and contributing to the AgentVault project.</p>"},{"location":"#why-agentvault","title":"Why AgentVault?","text":"<ul> <li>Interoperability: Based on emerging open standards like A2A, AgentVault enables agents built by different developers on different platforms to communicate effectively.</li> <li>Discovery: The central AgentVault Registry allows users and agents to find other agents based on capabilities, identity, and other metadata described in standardized \"Agent Cards\".</li> <li>Security: Provides tools for secure credential management and incorporates security considerations like TEE awareness into its design.</li> <li>Developer Experience: Offers Python libraries (Client &amp; Server SDK), a command-line tool, and testing utilities to simplify the development and integration of A2A-compliant agents.</li> <li>Open Source: Licensed under Apache 2.0, encouraging community involvement, transparency, and preventing vendor lock-in.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Understand the Concepts: Familiarize yourself with the Core Concepts.</li> <li>Explore the Architecture: See how the components fit together in the Architecture Overview.</li> <li>Installation: Follow the Installation Guide to set up the CLI or development environment.</li> <li>User Guide: Learn how to use the Command Line Interface (CLI).</li> <li>Developer Guides: Dive into building or interacting with agents using the:<ul> <li>Client Library (<code>agentvault</code>)</li> <li>Server SDK (<code>agentvault-server-sdk</code>)</li> <li>Registry API (<code>agentvault_registry</code>)</li> <li>Testing Utilities (<code>agentvault-testing-utils</code>)</li> </ul> </li> </ol>"},{"location":"#project-components","title":"Project Components","text":"<ul> <li>AgentVault Library (<code>agentvault</code>): Core Python client library.</li> <li>AgentVault CLI (<code>agentvault_cli</code>): Command-line tool for users.</li> <li>AgentVault Registry (<code>agentvault_registry</code>): Central discovery API and UI.</li> <li>AgentVault Server SDK (<code>agentvault-server-sdk</code>): Tools for building A2A agents.</li> <li>Testing Utilities (<code>agentvault-testing-utils</code>): Shared testing resources.</li> <li>Examples: Practical usage examples.</li> </ul> <p>(This documentation is under active development alongside the AgentVault project.)</p>"},{"location":"a2a_profile_v0.2/","title":"AgentVault A2A Profile v0.2","text":"<p>This document specifies the Agent-to-Agent (A2A) communication profile implemented by AgentVault components (as of v0.2.x of the libraries/SDK). It defines how clients interact with A2A-compliant agent servers, aligning with concepts from emerging A2A standards like Google's A2A protocol.</p>"},{"location":"a2a_profile_v0.2/#overview","title":"Overview","text":"<ul> <li>Protocol: JSON-RPC 2.0 Specification.</li> <li>Transport: HTTP/1.1 or HTTP/2. HTTPS is REQUIRED for all communication except potentially during local development targeting <code>localhost</code>.</li> <li>Request Method: <code>POST</code> for all JSON-RPC requests.</li> <li>Streaming: Server-Sent Events (SSE) via the <code>tasks/sendSubscribe</code> method for real-time updates.</li> <li>Data Format: JSON (UTF-8 encoding).</li> <li>Authentication: Defined via <code>authSchemes</code> in the Agent Card. Supported schemes include <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials Grant).</li> </ul>"},{"location":"a2a_profile_v0.2/#transport-details","title":"Transport Details","text":"<p>All JSON-RPC requests, including method calls and notifications (if used), MUST be sent using the HTTP <code>POST</code> method to the agent's designated A2A endpoint URL (found in the <code>url</code> field of its Agent Card).</p> <ul> <li>Request Headers:<ul> <li><code>Content-Type: application/json</code> is REQUIRED.</li> <li>Authentication headers (e.g., <code>X-Api-Key</code> or <code>Authorization: Bearer &lt;token&gt;</code>) MUST be included if required by the agent's <code>authSchemes</code>.</li> </ul> </li> <li>Request Body: Contains the standard JSON-RPC 2.0 request object (see below).</li> <li>Response Body (Non-Streaming): Contains the standard JSON-RPC 2.0 response object (either <code>result</code> or <code>error</code>).</li> <li>Response Body (Streaming via <code>tasks/sendSubscribe</code>): The server responds with HTTP <code>200 OK</code> and <code>Content-Type: text/event-stream</code>. The body then contains a stream of Server-Sent Events (see SSE section below).</li> </ul>"},{"location":"a2a_profile_v0.2/#authentication","title":"Authentication","text":"<p>Refer to the main Security Considerations document for details on how <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials) schemes are implemented and handled by the <code>agentvault</code> client library and expected by servers.</p>"},{"location":"a2a_profile_v0.2/#json-rpc-20-structure","title":"JSON-RPC 2.0 Structure","text":"<p>All requests and responses adhere to the JSON-RPC 2.0 specification.</p> <p>Request Object:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"method_name\",\n  \"params\": &lt;parameters_object_or_array&gt;,\n  \"id\": &lt;request_id_string_or_number_or_null&gt;\n}\n</code></pre> <ul> <li><code>jsonrpc</code>: MUST be exactly \"2.0\".</li> <li><code>method</code>: A string containing the name of the method to be invoked (e.g., \"tasks/send\").</li> <li><code>params</code>: An optional structured value (object or array) containing parameter values. If omitted, the method is assumed to take no parameters. AgentVault methods use parameter objects (dictionaries).</li> <li><code>id</code>: An identifier established by the Client. If included, the response MUST include the same value. If omitted (for notifications), the server MUST NOT reply. AgentVault methods generally expect an ID.</li> </ul> <p>Response Object (Success):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": &lt;result_value&gt;,\n  \"id\": &lt;matching_request_id&gt;\n}\n</code></pre> <ul> <li><code>result</code>: The value returned by the method invocation. Its structure depends on the method called.</li> <li><code>id</code>: Must match the <code>id</code> from the Request Object.</li> </ul> <p>Response Object (Error):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": &lt;integer&gt;,\n    \"message\": &lt;string&gt;,\n    \"data\": &lt;optional_any&gt;\n  },\n  \"id\": &lt;matching_request_id_or_null&gt;\n}\n</code></pre> <ul> <li><code>error</code>: An object describing the error.<ul> <li><code>code</code>: A Number that indicates the error type that occurred. See Error Codes.</li> <li><code>message</code>: A String providing a short description of the error.</li> <li><code>data</code>: Optional. A Primitive or Structured value containing additional information about the error.</li> </ul> </li> <li><code>id</code>: Must match the <code>id</code> from the Request Object. If the error occurred before the ID could be determined (e.g., Parse Error), it SHOULD be <code>null</code>.</li> </ul>"},{"location":"a2a_profile_v0.2/#standard-a2a-methods","title":"Standard A2A Methods","text":"<p>These methods form the core of the AgentVault A2A interaction model.</p>"},{"location":"a2a_profile_v0.2/#taskssend","title":"<code>tasks/send</code>","text":"<p>Initiates a new task or sends a subsequent message to an existing task.</p> <ul> <li>Params: <code>TaskSendParams</code> object     <pre><code>// Example: Initiate a new task\n{\n  \"message\": {\n    \"role\": \"user\",\n    \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}],\n    \"metadata\": {\n      \"mcp_context\": { /* Optional MCP data */ }\n    }\n  },\n  \"webhookUrl\": \"https://my-client.example.com/webhook/task-updates\" // Optional\n}\n\n// Example: Send subsequent message to existing task\n{\n  \"id\": \"task-abc-123\",\n  \"message\": {\n    \"role\": \"user\",\n    \"parts\": [{\"type\": \"text\", \"content\": \"What about tomorrow?\"}]\n  }\n}\n</code></pre><ul> <li><code>id</code> (Optional[str]): Task ID if continuing, omit/null if initiating.</li> <li><code>message</code> (Message): The message object.</li> <li><code>webhookUrl</code> (Optional[str]): URL for agent push notifications (if supported).</li> </ul> </li> <li>Result: <code>TaskSendResult</code> object     <pre><code>{\n  \"id\": \"task-abc-123\" // The ID of the task (new or existing)\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#tasksget","title":"<code>tasks/get</code>","text":"<p>Retrieve the current status and details of a specific task.</p> <ul> <li>Params: <code>TaskGetParams</code> object (or just the <code>id</code> field)     <pre><code>{\n  \"id\": \"task-abc-123\"\n}\n</code></pre></li> <li>Result: <code>Task</code> object (See <code>agentvault.models.Task</code> for full structure)     <pre><code>{\n  \"id\": \"task-abc-123\",\n  \"state\": \"WORKING\", // Or COMPLETED, FAILED, etc.\n  \"createdAt\": \"2024-04-15T10:00:00Z\",\n  \"updatedAt\": \"2024-04-15T10:05:30Z\",\n  \"messages\": [\n    {\"role\": \"user\", \"parts\": [...]},\n    {\"role\": \"assistant\", \"parts\": [...]}\n  ],\n  \"artifacts\": [\n    {\"id\": \"artifact-1\", \"type\": \"log\", \"content\": \"...\", \"mediaType\": \"text/plain\"}\n  ],\n  \"metadata\": { /* Optional task-level metadata */ }\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskscancel","title":"<code>tasks/cancel</code>","text":"<p>Request the cancellation of an ongoing task.</p> <ul> <li>Params: <code>TaskCancelParams</code> object (or just the <code>id</code> field)     <pre><code>{\n  \"id\": \"task-abc-123\"\n}\n</code></pre></li> <li>Result: <code>TaskCancelResult</code> object     <pre><code>{\n  \"success\": true, // Indicates request was accepted, not necessarily completed cancellation\n  \"message\": \"Cancellation request received.\" // Optional\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskssendsubscribe","title":"<code>tasks/sendSubscribe</code>","text":"<p>Subscribe to real-time updates for a task via Server-Sent Events (SSE).</p> <ul> <li>Params: Object containing the task ID     <pre><code>{\n  \"id\": \"task-abc-123\"\n}\n</code></pre></li> <li>Response: HTTP <code>200 OK</code> with <code>Content-Type: text/event-stream</code>, followed by SSE stream in the body. No JSON-RPC <code>result</code> field is sent in the initial HTTP response body.</li> </ul>"},{"location":"a2a_profile_v0.2/#task-states-taskstate-enum","title":"Task States (<code>TaskState</code> Enum)","text":"<p>The defined states for an A2A task lifecycle:</p> <ul> <li><code>SUBMITTED</code>: Task received, awaiting execution.</li> <li><code>WORKING</code>: Task actively being processed.</li> <li><code>INPUT_REQUIRED</code>: Task paused, awaiting further client input (advanced use case).</li> <li><code>COMPLETED</code>: Task finished successfully. (Terminal)</li> <li><code>FAILED</code>: Task terminated due to an error. (Terminal)</li> <li><code>CANCELED</code>: Task canceled by request. (Terminal)</li> </ul>"},{"location":"a2a_profile_v0.2/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Used for the <code>tasks/sendSubscribe</code> stream.</p> <ul> <li>Format: Standard SSE. Each event consists of <code>event:</code> and <code>data:</code> lines, terminated by <code>\\n\\n</code>.     <pre><code>event: &lt;event_type&gt;\ndata: &lt;json_payload_string&gt;\n\nevent: &lt;another_event_type&gt;\ndata: &lt;another_json_payload_string&gt;\n</code></pre></li> <li>Event Types (<code>event:</code> field):<ul> <li><code>task_status</code>: Task state change. <code>data</code> is JSON of <code>TaskStatusUpdateEvent</code>.</li> <li><code>task_message</code>: New message added. <code>data</code> is JSON of <code>TaskMessageEvent</code>.</li> <li><code>task_artifact</code>: Artifact created/updated. <code>data</code> is JSON of <code>TaskArtifactUpdateEvent</code>.</li> <li><code>error</code>: Server-side error during streaming. <code>data</code> is a JSON object like <code>{\"error\": \"code\", \"message\": \"desc\"}</code>.</li> </ul> </li> <li>Data Payload (<code>data:</code> field): A single line containing a JSON string representing the corresponding event model (e.g., <code>TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>).</li> </ul> <p>Example SSE Stream:</p> <pre><code>event: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\nevent: task_artifact\ndata: {\"taskId\": \"task-abc-123\", \"artifact\": {\"id\": \"log-1\", \"type\": \"debug_log\", \"content\": \"Processing step 1\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:10Z\"}\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"COMPLETED\", \"timestamp\": \"2024-04-15T10:05:15Z\", \"message\": \"Task finished successfully.\"}\n</code></pre>"},{"location":"a2a_profile_v0.2/#json-rpc-error-codes","title":"JSON-RPC Error Codes","text":"<p>Standard codes should be used where applicable. AgentVault defines some application-specific codes in the <code>-32000</code> to <code>-32099</code> range.</p> Code Message Meaning -32700 Parse error Invalid JSON was received by the server. -32600 Invalid Request The JSON sent is not a valid Request object. -32601 Method not found The method does not exist / is not available. -32602 Invalid Params Invalid method parameter(s). -32603 Internal error Internal JSON-RPC error on the server. -32000 Agent Server Error Generic application error on the agent. -32001 Task Not Found Specified <code>task_id</code> does not exist. -32002 Authentication Error API Key / Token invalid or missing. -32003 Authorization Error Authenticated user cannot perform action. -32004 Invalid State Operation not allowed in current task state. others Implementation Defined Server may define other -320xx errors. <p>Servers SHOULD include meaningful information in the <code>message</code> and optionally the <code>data</code> part of the error object.</p>"},{"location":"architecture/","title":"AgentVault Architecture","text":"<p>This document provides a high-level overview of the AgentVault ecosystem architecture, illustrating how the different components interact to enable secure agent discovery and communication.</p>"},{"location":"architecture/#vision","title":"Vision","text":"<p>AgentVault aims to be the open-source backbone for a thriving multi-agent ecosystem. It provides the standards, tools, and infrastructure necessary for agents built by anyone, anywhere, to find each other and collaborate effectively and securely.</p>"},{"location":"architecture/#component-overview","title":"Component Overview","text":"<p>The ecosystem consists of several distinct but interconnected Python packages and services:</p> <ol> <li><code>agentvault_library</code> (Core Client Library): The foundation for client-side interactions. Contains the <code>AgentVaultClient</code> (handles A2A protocol logic), <code>KeyManager</code> (secure credential storage), Pydantic models (AgentCard, A2A messages), and utility functions (card parsing, MCP handling). Used by the CLI and any custom application wanting to interact with agents.</li> <li><code>agentvault_cli</code> (Command Line Interface): The primary tool for end-users and developers to interact with the system from the terminal. Uses the <code>agentvault_library</code> to perform actions like configuring keys, discovering agents via the registry, and running tasks on agents.</li> <li><code>agentvault_registry</code> (Registry API &amp; UI): A central FastAPI web service acting as the discovery hub. It stores Agent Card metadata submitted by developers in a PostgreSQL database. It provides a public REST API for searching/retrieving cards and an authenticated API for developers to manage their listings. It also serves a basic web UI for discovery and developer management.</li> <li><code>agentvault_server_sdk</code> (Server SDK): A toolkit for developers building A2A-compliant agents. Provides base classes (<code>BaseA2AAgent</code>), FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code>), task state management abstractions, and packaging utilities (<code>agentvault-sdk package</code>) to simplify agent development and deployment.</li> <li><code>agentvault_testing_utils</code> (Testing Utilities): A shared internal package containing mocks, pytest fixtures, factories, and assertion helpers used across the test suites of the other components to ensure consistency and reduce boilerplate. Not intended for direct use by end-users.</li> </ol>"},{"location":"architecture/#interaction-flow-diagram","title":"Interaction Flow Diagram","text":"<pre><code>graph LR\n    subgraph User/Client Side\n        User[User / Client App] --&gt;|Uses| CLI(agentvault_cli)\n        CLI --&gt;|Uses| Lib(agentvault_library)\n        User --&gt;|Uses| Lib\n        Lib --&gt;|Manages Keys| KeyStore([Local Credential Store&lt;br&gt;(Env, File, Keyring)])\n    end\n\n    subgraph Developer Side\n        Dev[Agent Developer] --&gt;|Uses| SDK(agentvault_server_sdk)\n        SDK --&gt;|Builds Agent + Card| AgentServer(A2A Agent Server)\n        Dev --&gt;|Creates/Manages Keys| DevKeyStore([Developer API Key])\n        Dev --&gt;|Submits Card via API| RegistryAPI(Registry API&lt;br&gt;/api/v1)\n    end\n\n    subgraph Central Service\n        RegistryAPI --&gt;|Reads/Writes| DB[(Registry PostgreSQL DB)]\n        RegistryAPI --&gt;|Serves UI| RegistryUI(Registry Web UI&lt;br&gt;/ui, /ui/developer)\n        User --&gt;|Browses| RegistryUI\n    end\n\n    subgraph Communication Paths\n        Lib -- 1. Discover Agent --&gt; RegistryAPI\n        Lib -- 2. Get Agent Card --&gt; RegistryAPI\n        Lib -- 3. Authenticate &amp; Run Task (A2A Protocol) --&gt; AgentServer\n        AgentServer --&gt;|Optional: Uses Lib/SDK| ExternalService[External APIs / Services]\n    end\n\n    style Dev fill:#f9f,stroke:#333,stroke-width:2px\n    style User fill:#ccf,stroke:#333,stroke-width:2px\n    style KeyStore stroke-dasharray: 5 5\n    style DevKeyStore stroke-dasharray: 5 5\n</code></pre> <p>Explanation of Flows:</p> <ol> <li>Discovery: A user or client application (using the Library or CLI) queries the Registry API to find agents based on criteria (search, tags, etc.).</li> <li>Card Retrieval: The client retrieves the specific Agent Card for the desired agent from the Registry API.</li> <li>Interaction:<ul> <li>The client uses the information in the Agent Card (endpoint <code>url</code>, <code>authSchemes</code>).</li> <li>The <code>agentvault_library</code> uses the <code>KeyManager</code> to retrieve the necessary local credentials based on the agent's required <code>authSchemes</code> and <code>service_identifier</code>.</li> <li>The library constructs and sends A2A protocol requests (JSON-RPC over POST/SSE) directly to the target Agent Server's endpoint (<code>url</code>).</li> <li>Authentication headers (<code>X-Api-Key</code> or <code>Authorization: Bearer</code>) are added automatically by the library based on the retrieved credentials and scheme.</li> <li>The Agent Server (potentially built with the <code>agentvault-server-sdk</code>) receives the request, authenticates it, processes the task, and sends back responses or streams events.</li> </ul> </li> <li>Registration (Developer): The developer uses their unique Developer API Key to interact with the authenticated endpoints of the Registry API to submit or manage their Agent Cards.</li> </ol>"},{"location":"architecture/#key-architectural-principles","title":"Key Architectural Principles","text":"<ul> <li>Decentralized Execution: Agents run independently. The registry is only for discovery, not execution or proxying.</li> <li>Standardized Interface: Communication relies on the defined A2A profile (JSON-RPC/SSE) and Agent Card schema.</li> <li>Component-Based: The ecosystem is broken down into logical components (library, CLI, registry, SDK) with distinct responsibilities.</li> <li>Security Focus: Secure key management on the client, hashed keys on the registry, HTTPS enforcement (recommended), and TEE awareness are integrated.</li> <li>Developer Experience: SDK and CLI tools aim to simplify common tasks for both agent developers and users.</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This page defines the key concepts and terminology used throughout the AgentVault ecosystem. Understanding these concepts is crucial for effectively using the tools and contributing to the project.</p>"},{"location":"concepts/#agent-card","title":"Agent Card","text":"<ul> <li>Definition: A standardized JSON document (typically named <code>agent-card.json</code>) containing metadata that describes an A2A-compliant agent. It's the agent's \"business card\" for the digital world.</li> <li>Purpose: Enables discovery via the AgentVault Registry and provides essential information for clients (other agents or applications) to connect, authenticate, and interact with the agent.</li> <li>Schema: The structure and required fields are defined by the AgentVault project, aligning with emerging A2A standards. See the A2A Profile v0.2 for the current specification details.</li> <li>Key Fields: Includes the agent's unique <code>humanReadableId</code>, display <code>name</code>, <code>description</code>, the A2A endpoint <code>url</code>, technical <code>capabilities</code> (like supported protocol versions), required <code>authSchemes</code>, and details about the <code>provider</code>.</li> </ul>"},{"location":"concepts/#agent-to-agent-a2a-protocol","title":"Agent-to-Agent (A2A) Protocol","text":"<ul> <li>Definition: The standardized communication protocol enabling direct interaction between AgentVault clients and A2A-compliant agent servers. It defines the methods, message formats, and interaction patterns.</li> <li>Based On: Inspired by and aligned with concepts from the Google A2A Protocol specification, utilizing JSON-RPC 2.0 over HTTP POST for requests and Server-Sent Events (SSE) over HTTP for asynchronous streaming updates.</li> <li>Key Methods: Defines standard operations like initiating tasks (<code>tasks/send</code>), retrieving task status (<code>tasks/get</code>), requesting cancellation (<code>tasks/cancel</code>), and subscribing to real-time updates (<code>tasks/sendSubscribe</code>).</li> <li>Profile: The specific implementation details, method signatures, payload structures, and state transitions used within AgentVault are documented in the AgentVault A2A Profile v0.2.</li> </ul>"},{"location":"concepts/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Definition: (Conceptual / Future Work) A protocol intended for exchanging richer, structured contextual information between agents beyond simple text prompts. This might include user profiles, conversation history summaries, references to external data, or task-specific parameters.</li> <li>Status: Currently in the conceptual phase within AgentVault. The <code>agentvault_library</code> provides basic utilities (<code>mcp_utils.py</code>) for embedding arbitrary context data within the <code>metadata['mcp_context']</code> field of A2A <code>Message</code> objects. A formal MCP specification is planned for future development.</li> <li>Goal: To enable more sophisticated, context-aware collaboration and task handoff between specialized agents.</li> </ul>"},{"location":"concepts/#agentvault-registry","title":"AgentVault Registry","text":"<ul> <li>Definition: A central API service and web UI acting as the discovery hub for the ecosystem. Developers register their agents by submitting Agent Cards, and clients query the registry to find agents based on various criteria.</li> <li>Component: <code>agentvault_registry</code></li> <li>Features: Public API for listing, searching (by name, description, tags, TEE support), and retrieving Agent Cards. Authenticated API for developers to submit, update, and deactivate their cards. Includes Agent Card validation, developer verification status, and a basic web UI for discovery and developer management. See the Registry API Guide.</li> </ul>"},{"location":"concepts/#agentvault-library-client","title":"AgentVault Library (Client)","text":"<ul> <li>Definition: The core Python library (<code>agentvault</code>) providing the client-side tools needed to interact with the ecosystem.</li> <li>Component: <code>agentvault_library</code></li> <li>Features: Provides the <code>AgentVaultClient</code> for making A2A calls (handling JSON-RPC, SSE, authentication), the <code>KeyManager</code> for secure local credential handling (API keys, OAuth credentials from env/file/keyring), utilities for Agent Card parsing and validation (<code>agent_card_utils</code>), and Pydantic models defining all necessary data structures. See the Library Guide.</li> </ul>"},{"location":"concepts/#agentvault-server-sdk","title":"AgentVault Server SDK","text":"<ul> <li>Definition: A Python Software Development Kit (<code>agentvault-server-sdk</code>) designed to accelerate the development of A2A-compliant agent servers.</li> <li>Component: <code>agentvault_server_sdk</code></li> <li>Features: Includes the <code>BaseA2AAgent</code> abstract class, FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code> decorator) to automatically expose agent logic via the A2A protocol, abstractions for task state management (<code>BaseTaskStore</code>, <code>InMemoryTaskStore</code>), utilities for handling MCP context server-side, and a command-line tool (<code>agentvault-sdk package</code>) for packaging agents into Docker containers. See the Server SDK Guide.</li> </ul>"},{"location":"concepts/#agentvault-cli","title":"AgentVault CLI","text":"<ul> <li>Definition: A command-line interface (<code>agentvault-cli</code>) providing a user-friendly way to interact with AgentVault features.</li> <li>Component: <code>agentvault_cli</code></li> <li>Features: Allows users to manage local credentials (<code>config</code>), discover agents in the registry (<code>discover</code>), and execute tasks on remote agents (<code>run</code>). Built using the <code>agentvault</code> library. See the CLI User Guide.</li> </ul>"},{"location":"concepts/#trusted-execution-environment-tee","title":"Trusted Execution Environment (TEE)","text":"<ul> <li>Definition: A secure, isolated environment within a computer's processor that provides hardware-level guarantees for the confidentiality and integrity of code and data executed within it. Examples include Intel SGX, AMD SEV, AWS Nitro Enclaves.</li> <li>Relevance: Agents can optionally run within a TEE to enhance security and provide verifiable guarantees about their execution environment. Agent Cards can declare TEE usage (<code>capabilities.teeDetails</code>) including the type and potentially an attestation endpoint. The registry allows filtering for TEE-enabled agents.</li> <li>Current Scope: AgentVault currently supports the declaration and discovery of TEE capabilities. Automated verification of TEE attestations during A2A communication is a planned future enhancement. See the TEE Profile (placeholder).</li> </ul>"},{"location":"concepts/#service-identifier","title":"Service Identifier","text":"<ul> <li>Definition: A string used by the <code>KeyManager</code> to look up the correct local credentials (API Key or OAuth Client ID/Secret) for a specific agent or service.</li> <li>Source: Can be explicitly defined in an agent's <code>AgentCard</code> within the <code>authSchemes[].service_identifier</code> field. If omitted, clients might default to using the agent's <code>humanReadableId</code> or require the user to specify an override (e.g., via <code>agentvault_cli run --key-service</code>).</li> <li>Purpose: Allows a single credential (like an OpenAI key) stored locally under one <code>service_identifier</code> (e.g., \"openai\") to be used by multiple different agents that all require OpenAI authentication.</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide covers how to install the different parts of the AgentVault ecosystem.</p>"},{"location":"installation/#1-installing-the-cli-agentvault_cli","title":"1. Installing the CLI (<code>agentvault_cli</code>)","text":"<p>This is the primary tool for end-users and developers interacting with the registry and agents.</p> <p>Prerequisites:</p> <ul> <li>Python 3.10 or 3.11 installed.</li> <li><code>pip</code> (Python's package installer).</li> </ul> <p>Installation from PyPI (Recommended):</p> <p>Once published, you can install the CLI directly using pip:</p> <pre><code>pip install agentvault-cli\n</code></pre> <p>To include optional OS Keyring support for secure credential storage:</p> <pre><code>pip install \"agentvault-cli[os_keyring]\"\n</code></pre> <p>Verification:</p> <p>After installation, check that the command is available:</p> <pre><code>agentvault_cli --version\n</code></pre>"},{"location":"installation/#2-setting-up-the-development-environment-for-contributors","title":"2. Setting up the Development Environment (for Contributors)","text":"<p>If you want to contribute to AgentVault or run components locally from source, follow these steps:</p> <p>Prerequisites:</p> <ul> <li>Git</li> <li>Python 3.10 or 3.11</li> <li>Poetry (Python dependency management and packaging tool)</li> </ul> <p>Steps:</p> <ol> <li> <p>Clone the Repository: <pre><code>git clone https://github.com/SecureAgentTools/AgentVault.git\ncd AgentVault\n</code></pre></p> </li> <li> <p>Install Dependencies: Navigate to the project root (<code>AgentVault/</code>) and use Poetry to install all dependencies for all workspace packages, including development dependencies:     <pre><code>poetry install --with dev\n</code></pre></p> <ul> <li>This command reads the <code>pyproject.toml</code> files in each component directory (<code>agentvault_library</code>, <code>agentvault_cli</code>, etc.).</li> <li>It resolves all dependencies across the workspace.</li> <li>It installs everything into a single virtual environment located in the project root (usually <code>.venv/</code>).</li> <li>The <code>--with dev</code> flag ensures development tools (like <code>pytest</code>, <code>httpx</code> for testing, <code>mkdocs</code> for docs) are also installed.</li> </ul> </li> <li> <p>Activate Virtual Environment: Before running any commands or tests, activate the environment created by Poetry:</p> <ul> <li>Linux/macOS (bash/zsh): <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Windows (PowerShell): <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\.venv\\Scripts\\activate.bat\n</code></pre> You should see <code>(.venv)</code> appear at the beginning of your command prompt line.</li> </ul> </li> <li> <p>Verify Installation: You can now run commands from different components, e.g.:     <pre><code>agentvault_cli --version\npytest agentvault_library/tests/\nmkdocs --version\n</code></pre></p> </li> </ol>"},{"location":"installation/#3-installing-libraries-agentvault-agentvault-server-sdk","title":"3. Installing Libraries (<code>agentvault</code>, <code>agentvault-server-sdk</code>)","text":"<p>If you only need to use the client library or the server SDK in your own Python project (without the CLI or registry), you can install them individually from PyPI.</p> <p>Client Library (<code>agentvault</code>):</p> <pre><code>pip install agentvault\n</code></pre> <p>With optional OS Keyring support:</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>Server SDK (<code>agentvault-server-sdk</code>):</p> <pre><code>pip install agentvault-server-sdk\n</code></pre> <p>(Note: The Server SDK depends on the <code>agentvault</code> library, so pip will install both).</p>"},{"location":"installation/#4-running-the-registry-local-development","title":"4. Running the Registry (Local Development)","text":"<p>To run the <code>agentvault_registry</code> API locally (e.g., for testing agents or the CLI against it):</p> <ol> <li>Complete Development Setup: Follow the steps in section 2 above.</li> <li>Navigate: <pre><code>cd agentvault_registry\n</code></pre></li> <li>Configure Database &amp; Secrets:<ul> <li>Copy <code>.env.example</code> to <code>.env</code> (if it exists) or create a <code>.env</code> file.</li> <li>Set the <code>DATABASE_URL</code> environment variable in the <code>.env</code> file to point to your local PostgreSQL instance (ensure it uses the <code>asyncpg</code> driver, e.g., <code>postgresql+asyncpg://user:pass@host:port/dbname</code>).</li> <li>Set the <code>API_KEY_SECRET</code> environment variable in the <code>.env</code> file (generate a strong secret, e.g., <code>openssl rand -hex 32</code>).</li> </ul> </li> <li>Database Setup:<ul> <li>Ensure your PostgreSQL server is running and the specified database exists.</li> <li>Run database migrations using Alembic (make sure your virtual environment is activated):     <pre><code>alembic upgrade head\n</code></pre></li> </ul> </li> <li>Run the Server: Use Uvicorn (which was installed as part of FastAPI dependencies):     <pre><code>uvicorn agentvault_registry.main:app --reload --host 0.0.0.0 --port 8000\n</code></pre><ul> <li><code>--reload</code>: Automatically restarts the server when code changes.</li> <li><code>--host 0.0.0.0</code>: Makes the server accessible from other devices on your network (use <code>127.0.0.1</code> for localhost only).</li> <li><code>--port 8000</code>: The default port.</li> </ul> </li> </ol> <p>The registry API should now be running at <code>http://localhost:8000</code>. You can access the API docs at <code>http://localhost:8000/docs</code>.</p>"},{"location":"security/","title":"AgentVault Security Considerations","text":"<p>Security is a fundamental aspect of the AgentVault ecosystem, designed to enable trustworthy interactions between agents and protect user/developer credentials. This document details the security mechanisms, considerations, and best practices.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Authentication verifies the identity of the communicating parties. AgentVault employs different mechanisms for client-to-agent and developer-to-registry interactions.</p>"},{"location":"security/#1-client-to-agent-authentication-a2a","title":"1. Client-to-Agent Authentication (A2A)","text":"<p>Agents declare how clients should authenticate in their <code>AgentCard</code> (<code>authSchemes</code>). The <code>agentvault</code> library (used by the CLI and custom clients) supports:</p> <ul> <li><code>none</code>:<ul> <li>Mechanism: No authentication headers are sent.</li> <li>Use Case: Suitable for public agents providing non-sensitive information or actions.</li> <li>Security: Offers no protection against unauthorized access. Use only when the agent's functionality requires no access control.</li> </ul> </li> <li><code>apiKey</code>:<ul> <li>Mechanism: The client sends a pre-shared secret key in the <code>X-Api-Key</code> HTTP header.</li> <li>Client-Side: The <code>agentvault</code> library's <code>KeyManager</code> retrieves the key associated with the agent's <code>service_identifier</code> from local storage (env, file, or OS keyring).</li> <li>Server-Side: The agent server (implementer) is responsible for receiving the <code>X-Api-Key</code> header and validating the key against its own secure storage (e.g., environment variable, configuration management system, database with hashed keys). Never hardcode keys in agent source code.</li> <li>Security: Relies on the secrecy of the key and secure transport (HTTPS). Simpler to implement but less flexible than OAuth.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant):<ul> <li>Mechanism: The client uses its own credentials (Client ID &amp; Secret) to obtain a short-lived Bearer token from the agent's designated Token Endpoint (<code>tokenUrl</code> in Agent Card), then uses that token for subsequent A2A requests.</li> <li>Client-Side: <code>KeyManager</code> retrieves the Client ID/Secret for the agent's <code>service_identifier</code>. <code>AgentVaultClient</code> performs the POST request to the <code>tokenUrl</code> to get the <code>access_token</code> and caches it (in memory). It sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>Server-Side: The agent server must provide a <code>/token</code> endpoint compliant with the OAuth 2.0 Client Credentials grant flow. It validates the received Client ID/Secret and issues a signed, potentially short-lived Bearer token (e.g., a JWT). The main <code>/a2a</code> endpoint must then validate incoming Bearer tokens (check signature, expiry, audience, scopes if applicable).</li> <li>Security: More complex but standard-based. Allows for token revocation, scopes, and avoids sending long-lived secrets directly to the agent endpoint after initial token exchange. Requires secure handling of Client ID/Secret on the client and robust token validation on the server.</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Mechanism: The client sends a pre-existing Bearer token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>Client-Side: Assumes the client application has obtained a suitable token through some other means (e.g., user login flow, separate OAuth process). The <code>agentvault</code> library simply passes this token along if configured.</li> <li>Server-Side: The agent server must validate the received Bearer token.</li> <li>Security: Depends entirely on the security of the token issuance and validation process external to the basic A2A interaction.</li> </ul> </li> </ul>"},{"location":"security/#2-developer-to-registry-authentication","title":"2. Developer-to-Registry Authentication","text":"<ul> <li>Mechanism: Uses an API Key (<code>X-Api-Key</code> header) specific to the developer.</li> <li>Key Generation: Keys are generated by registry administrators (currently manual, future portal TBD) using <code>secrets.token_urlsafe</code> and prefixed (<code>avreg_</code>).</li> <li>Storage: The hash of the developer's API key is stored in the registry database (<code>Developer.api_key_hash</code>) using <code>passlib</code> with <code>bcrypt</code>. Plain text keys are never stored.</li> <li>Verification: The registry API uses <code>passlib.verify(plain_key, stored_hash)</code> to authenticate developers attempting to manage their Agent Cards.</li> <li>Security: Relies on the developer keeping their plain-text key secret and secure transport (HTTPS). Hashing prevents exposure of the plain key even if the database is compromised. The current lookup method iterates hashes, which is a scalability concern but not a direct security flaw for moderate numbers of developers.</li> </ul>"},{"location":"security/#credential-management-keymanager","title":"Credential Management (<code>KeyManager</code>)","text":"<p>The <code>agentvault</code> library's <code>KeyManager</code> provides a unified way for clients (like the CLI) to manage credentials needed for agent authentication.</p> <ul> <li>Secure Storage: Strongly recommends using the OS Keyring (<code>--keyring</code> option in CLI <code>config set</code>) for storing sensitive API keys and OAuth secrets. This leverages platform-specific secure storage mechanisms.</li> <li>Alternative Sources: Supports loading from environment variables and <code>.env</code>/<code>.json</code> files for flexibility, but users should be aware of the security implications of storing secrets in these locations (filesystem permissions, environment variable visibility).</li> <li>Abstraction: Client code interacts with <code>KeyManager</code> (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) without needing to know where the credential came from.</li> </ul>"},{"location":"security/#transport-security","title":"Transport Security","text":"<ul> <li>HTTPS is MANDATORY for all communication with the AgentVault Registry API and any A2A agent endpoint not running on <code>localhost</code>.</li> <li>Agent Card <code>url</code> and <code>tokenUrl</code> fields should use <code>https://</code>.</li> <li>Failure to use HTTPS exposes authentication credentials (API keys, Bearer tokens) and message content to eavesdropping.</li> </ul>"},{"location":"security/#data-validation","title":"Data Validation","text":"<ul> <li>Pydantic: All components heavily utilize Pydantic models for defining data structures (Agent Cards, API request/response bodies, A2A messages). Pydantic performs automatic data validation on input, preventing many types of injection or malformed data errors.</li> <li>Registry: Validates submitted <code>card_data</code> against the canonical <code>agentvault.models.AgentCard</code> schema before storing it.</li> <li>Server SDK: The <code>create_a2a_router</code> automatically validates incoming JSON-RPC <code>params</code> against the type hints of the corresponding agent handler method.</li> </ul>"},{"location":"security/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Registry: Implements basic IP-based rate limiting using <code>slowapi</code> to mitigate simple denial-of-service and abuse patterns. Production deployments may require more sophisticated limiting.</li> <li>Agents: Agent developers are responsible for implementing appropriate rate limiting on their own A2A endpoints if needed.</li> </ul>"},{"location":"security/#trusted-execution-environments-tee","title":"Trusted Execution Environments (TEE)","text":"<ul> <li>Declaration: Agent Cards can declare (<code>capabilities.teeDetails</code>) that an agent runs within a TEE, providing metadata like the TEE type and potentially an attestation endpoint URL.</li> <li>Discovery: The registry allows filtering agents based on TEE support.</li> <li>Verification (Future Work): Currently, AgentVault clients do not automatically verify TEE attestations. Implementing robust, automated attestation verification and potentially establishing secure channels based on TEE keys is a complex task planned for future development. Users currently rely on the agent's declaration and must perform any verification manually or through out-of-band mechanisms.</li> </ul>"},{"location":"security/#dependency-security","title":"Dependency Security","text":"<ul> <li>Auditing: The project includes a GitHub Actions workflow (<code>dependency_audit.yml</code>) using <code>pip-audit</code> to automatically scan dependencies listed in <code>poetry.lock</code> files for known vulnerabilities on pushes/PRs to <code>main</code>.</li> <li>Updates: Regularly updating dependencies (e.g., via <code>poetry update</code>) is crucial to patch vulnerabilities.</li> </ul>"},{"location":"security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Please report suspected security vulnerabilities privately according to the Security Policy (SECURITY.md).</p>"},{"location":"tee_profile/","title":"AgentVault TEE Profile (v0.1 - Declarative)","text":"<p>This document outlines the initial support for Trusted Execution Environments (TEEs) within the AgentVault ecosystem, focusing on declaration and discovery.</p> <p>Version: 0.1 (Declarative Phase)</p>"},{"location":"tee_profile/#overview","title":"Overview","text":"<p>Trusted Execution Environments (TEEs) like Intel SGX, AMD SEV, AWS Nitro Enclaves, etc., provide hardware-level isolation to protect the confidentiality and integrity of code and data being processed. Leveraging TEEs can significantly enhance the security posture of AI agents, especially when handling sensitive information or performing critical tasks.</p> <p>AgentVault aims to facilitate the use of TEEs by allowing agents to declare their TEE usage and enabling clients to discover agents based on this capability.</p>"},{"location":"tee_profile/#agent-card-declaration","title":"Agent Card Declaration","text":"<p>Agents running within a TEE can declare this capability in their <code>agent-card.json</code> file within the <code>capabilities</code> object, using the optional <code>teeDetails</code> field.</p> <p>Schema:</p> <ul> <li><code>capabilities.teeDetails</code> (Optional Object): Contains details about the TEE. If present, indicates the agent utilizes a TEE.<ul> <li><code>type</code> (String, Required if <code>teeDetails</code> is present): An identifier for the specific TEE technology used. Examples: <code>\"Intel SGX\"</code>, <code>\"AMD SEV-SNP\"</code>, <code>\"AWS Nitro Enclaves\"</code>, <code>\"Azure Confidential Computing\"</code>, <code>\"Confidential Space\"</code>. Standardized identifiers are preferred, but custom strings are allowed.</li> <li><code>attestationEndpoint</code> (String, Optional, Format: URL): A URL where clients can potentially obtain or verify an attestation document for the specific TEE instance hosting the agent. The format and verification process for the attestation document are specific to the TEE type and are outside the scope of this profile version.</li> <li><code>publicKey</code> (String, Optional): A public key associated with the TEE instance, potentially used for establishing secure channels or verifying attestations. The format (e.g., PEM, JWK) depends on the TEE type and attestation protocol.</li> <li><code>description</code> (String, Optional): A human-readable description of the TEE setup, its purpose, or the guarantees it provides for this agent.</li> </ul> </li> </ul> <p>Example <code>agent-card.json</code> Snippet:</p> <pre><code>{\n  \"schemaVersion\": \"1.0\",\n  // ... other fields ...\n  \"capabilities\": {\n    \"a2aVersion\": \"1.0\",\n    // ... other capabilities ...\n    \"teeDetails\": {\n      \"type\": \"AWS Nitro Enclaves\",\n      \"attestationEndpoint\": \"https://attestation.example-agent.com/verify\",\n      \"description\": \"Agent runs within an AWS Nitro Enclave for enhanced data confidentiality during processing.\"\n    }\n  },\n  // ... other fields ...\n}\n</code></pre>"},{"location":"tee_profile/#discovery-via-registry","title":"Discovery via Registry","text":"<p>The AgentVault Registry API (<code>agentvault_registry</code>) supports filtering agents based on their TEE declaration:</p> <ul> <li><code>GET /api/v1/agent-cards/?has_tee=true</code>: Returns only agents whose Agent Card includes the <code>capabilities.teeDetails</code> object (regardless of its content).</li> <li><code>GET /api/v1/agent-cards/?has_tee=false</code>: Returns only agents whose Agent Card does not include the <code>capabilities.teeDetails</code> object.</li> <li><code>GET /api/v1/agent-cards/?tee_type=&lt;type_string&gt;</code>: Returns only agents where <code>capabilities.teeDetails.type</code> matches the provided <code>&lt;type_string&gt;</code> (case-insensitive comparison recommended for the registry implementation). Example: <code>?tee_type=AWS%20Nitro%20Enclaves</code>.</li> </ul> <p>The public Registry Web UI also includes a filter option to show only TEE-enabled agents.</p>"},{"location":"tee_profile/#current-scope-limitations-v01","title":"Current Scope &amp; Limitations (v0.1)","text":"<ul> <li>Declarative Only: This version focuses solely on allowing agents to declare their TEE usage and enabling discovery based on that declaration.</li> <li>No Automated Verification: AgentVault clients (library, CLI) do not automatically perform TEE attestation verification based on the <code>attestationEndpoint</code> or <code>publicKey</code>. Implementing robust and generic attestation verification is complex due to the variety of TEE technologies and attestation protocols.</li> <li>Client Responsibility: Clients wishing to verify an agent's TEE status must currently implement the verification logic themselves, specific to the declared <code>teeDetails.type</code> and using the provided <code>attestationEndpoint</code> or other out-of-band mechanisms.</li> <li>No Secure Channel Guarantee: Declaring TEE usage does not automatically establish a TEE-secured communication channel. Standard transport security (HTTPS) is still required.</li> </ul>"},{"location":"tee_profile/#future-work","title":"Future Work","text":"<ul> <li>Researching and potentially integrating standardized TEE attestation verification libraries or protocols into the <code>agentvault</code> client library.</li> <li>Defining mechanisms for establishing secure communication channels directly with TEE enclaves, possibly leveraging the declared <code>publicKey</code>.</li> <li>Standardizing <code>teeDetails.type</code> identifiers.</li> </ul>"},{"location":"developer_guide/library/","title":"Developer Guide: Client Library (<code>agentvault</code>)","text":"<p>The <code>agentvault</code> library is the core Python package for interacting with the AgentVault ecosystem from the client-side. It enables applications, scripts, or even other agents to discover A2A agents, manage credentials securely, and communicate using the A2A protocol.</p>"},{"location":"developer_guide/library/#installation","title":"Installation","text":"<p>Install the library from PyPI:</p> <pre><code>pip install agentvault\n</code></pre> <p>For optional OS Keyring support (recommended for secure credential storage):</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"developer_guide/library/#key-components","title":"Key Components","text":""},{"location":"developer_guide/library/#keymanager","title":"<code>KeyManager</code>","text":"<p>Handles secure loading, storage, and retrieval of credentials needed for agent authentication.</p> <ul> <li>Purpose: Abstracts credential sources (environment variables, files, OS keyring) so your client code doesn't need to handle each case explicitly.</li> <li>Initialization: <pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Load from environment variables (default) and OS keyring (if enabled)\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Load ONLY from a specific .env file (disable env vars and keyring)\n# key_file = pathlib.Path(\"path/to/your/keys.env\")\n# km_file_only = KeyManager(key_file_path=key_file, use_env_vars=False, use_keyring=False)\n\n# Load from file AND environment (file takes priority)\n# km_file_env = KeyManager(key_file_path=key_file, use_env_vars=True)\n</code></pre></li> <li>Priority Order: File (<code>key_file_path</code>) &gt; Environment Variables (<code>use_env_vars=True</code>) &gt; OS Keyring (<code>use_keyring=True</code>, only checked on demand via <code>get_</code> methods if not found in file/env cache).</li> <li>Service Identifier (<code>service_id</code>): This is the key used to look up credentials. It's a local name you choose (e.g., \"openai\", \"my-agent-key\", \"google-oauth\") that maps to the credentials needed for a specific agent or service. It often corresponds to the <code>service_identifier</code> field in an Agent Card's <code>authSchemes</code>.</li> <li>Retrieving Credentials: <pre><code># Get API Key (returns None if not found)\napi_key = km_env_keyring.get_key(\"openai\")\nif api_key:\n    print(\"Found OpenAI API Key\")\n\n# Get OAuth Credentials (return None if not found or incomplete)\nclient_id = km_env_keyring.get_oauth_client_id(\"google-oauth-agent\")\nclient_secret = km_env_keyring.get_oauth_client_secret(\"google-oauth-agent\")\nif client_id and client_secret:\n    print(f\"Found Google OAuth Client ID: {client_id}\")\n\n# Check source\nsource = km_env_keyring.get_key_source(\"openai\") # e.g., 'keyring', 'env', 'file', None\noauth_status = km_env_keyring.get_oauth_config_status(\"google-oauth-agent\") # e.g., \"Configured (Source: KEYRING)\"\nprint(f\"OpenAI key source: {source}\")\nprint(f\"Google OAuth status: {oauth_status}\")\n</code></pre></li> <li>Storing Credentials (Primarily for CLI/Setup): <pre><code>from agentvault import KeyManagementError\n\ntry:\n    # Store API Key securely (requires keyring backend)\n    km_env_keyring.set_key_in_keyring(\"my-new-service\", \"sk-abc...\")\n\n    # Store OAuth creds securely (requires keyring backend)\n    km_env_keyring.set_oauth_creds_in_keyring(\"my-oauth-service\", \"client_id_123\", \"client_secret_xyz\")\nexcept KeyManagementError as e:\n    print(f\"Failed to store credentials in keyring: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid input for storing credentials: {e}\")\n</code></pre></li> <li>Storage Conventions: See the <code>KeyManager</code> docstring or the Security Guide for details on environment variable names and file formats.</li> </ul>"},{"location":"developer_guide/library/#agentvaultclient","title":"<code>AgentVaultClient</code>","text":"<p>The primary class for making asynchronous A2A calls to remote agents.</p> <ul> <li>Purpose: Handles HTTP requests, authentication, JSON-RPC formatting, SSE streaming, and response parsing according to the A2A Profile v0.2.</li> <li>Usage: Best used as an async context manager. Requires an <code>AgentCard</code> instance (loaded via <code>agent_card_utils</code>) and a <code>KeyManager</code> instance for authentication.     <pre><code>import asyncio\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, TextPart,\n    agent_card_utils, exceptions as av_exceptions, models as av_models\n)\n\nasync def run_agent_task(agent_ref: str, input_text: str):\n    key_manager = KeyManager(use_keyring=True) # Use keyring and env vars\n    agent_card = None\n    task_id = None\n\n    try:\n        # Load agent card (adjust based on agent_ref type)\n        if agent_ref.startswith(\"http\"):\n            agent_card = await agent_card_utils.fetch_agent_card_from_url(agent_ref)\n        else: # Assume ID or file path (add more robust handling if needed)\n            # This part might need adjustment based on whether it's an ID or file\n            # For simplicity, assuming fetch_agent_card_from_url handles IDs via registry later\n            # Or use load_agent_card_from_file(pathlib.Path(agent_ref))\n            raise NotImplementedError(\"Loading by ID/File needs specific implementation here\")\n\n        if not agent_card:\n             print(f\"Error: Could not load agent card for {agent_ref}\")\n             return\n\n        initial_message = Message(role=\"user\", parts=[TextPart(content=input_text)])\n\n        async with AgentVaultClient() as client:\n            # 1. Initiate Task\n            print(f\"Initiating task with {agent_card.name}...\")\n            task_id = await client.initiate_task(\n                agent_card=agent_card,\n                initial_message=initial_message,\n                key_manager=key_manager\n                # mcp_context={\"user_pref\": \"concise\"}, # Optional MCP\n                # webhook_url=\"https://...\", # Optional webhook\n            )\n            print(f\"Task initiated: {task_id}\")\n\n            # 2. Stream Events\n            print(\"Streaming events...\")\n            final_response = \"\"\n            async for event in client.receive_messages(\n                agent_card=agent_card, task_id=task_id, key_manager=key_manager\n            ):\n                if isinstance(event, av_models.TaskStatusUpdateEvent):\n                    print(f\"  Status: {event.state} (Msg: {event.message or ''})\")\n                    if event.state in [av_models.TaskState.COMPLETED, av_models.TaskState.FAILED, av_models.TaskState.CANCELED]:\n                        print(\"  Terminal state reached.\")\n                        break\n                elif isinstance(event, av_models.TaskMessageEvent):\n                    print(f\"  Message ({event.message.role}):\")\n                    for part in event.message.parts:\n                        if isinstance(part, TextPart):\n                            print(f\"    Text: {part.content}\")\n                            if event.message.role == \"assistant\":\n                                final_response += part.content + \"\\n\"\n                        # Add handling for FilePart, DataPart if needed\n                        else:\n                            print(f\"    Part ({part.type}): {part}\")\n                elif isinstance(event, av_models.TaskArtifactUpdateEvent):\n                     print(f\"  Artifact ({event.artifact.type}, ID: {event.artifact.id}):\")\n                     print(f\"    Content: {str(event.artifact.content)[:100]}...\") # Example\n                     print(f\"    URL: {event.artifact.url}\")\n                     print(f\"    Media Type: {event.artifact.media_type}\")\n                else:\n                    print(f\"  Unknown Event: {event}\")\n\n            # 3. (Optional) Get Final Status if needed\n            # final_task_status = await client.get_task_status(agent_card, task_id, key_manager)\n            # print(f\"Final task status check: {final_task_status.state}\")\n\n            print(\"\\n--- Final Agent Response ---\")\n            print(final_response.strip())\n            print(\"--------------------------\")\n\n    except av_exceptions.AgentCardError as e:\n        print(f\"Error loading agent card: {e}\")\n    except av_exceptions.A2AAuthenticationError as e:\n        print(f\"Authentication error: {e}\")\n        print(\"Hint: Ensure credentials for the required service_id are configured using 'agentvault config set'.\")\n    except av_exceptions.A2AConnectionError as e:\n        print(f\"Connection error: {e}\")\n    except av_exceptions.A2ARemoteAgentError as e:\n        print(f\"Agent returned an error: {e.status_code} - {e}\")\n        print(f\"  Response Body: {e.response_body}\")\n    except av_exceptions.A2AError as e:\n        print(f\"A2A protocol error: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n        logging.exception(\"Unexpected error details:\")\n\n# Example usage (replace with a real agent reference)\n# asyncio.run(run_agent_task(\"http://localhost:8000/agent-card.json\", \"Tell me a joke.\"))\n</code></pre></li> </ul>"},{"location":"developer_guide/library/#models-agentvaultmodels","title":"Models (<code>agentvault.models</code>)","text":"<p>Pydantic models defining the data structures for Agent Cards and the A2A protocol. Refer to the source code docstrings or the A2A Profile v0.2 for details on specific models like <code>AgentCard</code>, <code>Message</code>, <code>Task</code>, <code>TaskState</code>, <code>A2AEvent</code>, etc.</p>"},{"location":"developer_guide/library/#exceptions-agentvaultexceptions","title":"Exceptions (<code>agentvault.exceptions</code>)","text":"<p>Custom exceptions provide granular error handling. Key exceptions to catch include:</p> <ul> <li><code>AgentCardError</code>: Problems loading or validating the Agent Card.</li> <li><code>A2AAuthenticationError</code>: Missing or invalid credentials, OAuth flow failures.</li> <li><code>A2AConnectionError</code>: Network issues connecting to the agent or token endpoint.</li> <li><code>A2ATimeoutError</code>: Request timed out.</li> <li><code>A2ARemoteAgentError</code>: The agent returned a non-2xx HTTP status or a JSON-RPC error object. Access <code>e.status_code</code> and <code>e.response_body</code>.</li> <li><code>A2AMessageError</code>: Invalid JSON-RPC format, unexpected response structure.</li> <li><code>KeyManagementError</code>: Issues saving/loading keys with <code>KeyManager</code>.</li> </ul>"},{"location":"developer_guide/library/#utilities-agentvaultagent_card_utils-agentvaultmcp_utils","title":"Utilities (<code>agentvault.agent_card_utils</code>, <code>agentvault.mcp_utils</code>)","text":"<ul> <li><code>agent_card_utils</code>: Functions like <code>load_agent_card_from_file</code> and <code>fetch_agent_card_from_url</code> simplify obtaining and validating <code>AgentCard</code> objects.</li> <li><code>mcp_utils</code>:<ul> <li><code>format_mcp_context</code>: (Primarily for server-side or advanced clients) Validates and formats a dictionary intended as MCP context.</li> <li><code>get_mcp_context</code>: (Client-side) Safely extracts the <code>mcp_context</code> dictionary from a received <code>Message</code>'s metadata.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/","title":"Developer Guide: Registry API (<code>agentvault_registry</code>)","text":"<p>The AgentVault Registry provides a central RESTful API service for discovering and managing Agent Cards. Developers interact with it to publish their agents, while clients (like the <code>agentvault_cli</code> or other applications) use it to find agents.</p>"},{"location":"developer_guide/registry/#api-base-path","title":"API Base Path","text":"<p>All registry API endpoints are prefixed with <code>/api/v1</code>. The full URL depends on where the registry is deployed (e.g., <code>http://localhost:8000/api/v1</code> for local development).</p>"},{"location":"developer_guide/registry/#authentication","title":"Authentication","text":"<p>Endpoints related to managing agent cards (creating, updating, deleting) require developer authentication. This is handled via an API key specific to the developer, provided in the <code>X-Api-Key</code> HTTP header.</p> <p>Public endpoints (listing/searching agents, getting details by ID, validating cards) do not require authentication, although some filtering options (like <code>owned_only=true</code> on the list endpoint) do require authentication to identify the owner.</p>"},{"location":"developer_guide/registry/#common-error-responses","title":"Common Error Responses","text":"<ul> <li><code>401 Unauthorized</code>: Invalid or missing <code>X-Api-Key</code> header provided for a protected endpoint, or when required for a specific filter like <code>owned_only=true</code>.</li> <li><code>403 Forbidden</code>: A valid <code>X-Api-Key</code> was provided, but the authenticated developer does not have permission for the requested action (e.g., attempting to modify or delete another developer's Agent Card).</li> <li><code>404 Not Found</code>: The requested resource (e.g., an Agent Card with a specific UUID) does not exist.</li> <li><code>422 Unprocessable Entity</code>: The request body (e.g., for <code>POST</code> or <code>PUT</code>) failed validation. This commonly occurs if the submitted <code>card_data</code> does not conform to the Agent Card schema or if other required fields in the request schema are missing/invalid. The response <code>detail</code> field usually contains specific information about the validation errors.</li> <li><code>500 Internal Server Error</code>: An unexpected error occurred on the server (e.g., database connection issue, unhandled exception in the API logic).</li> </ul>"},{"location":"developer_guide/registry/#api-endpoints","title":"API Endpoints","text":""},{"location":"developer_guide/registry/#agent-cards-agent-cards","title":"Agent Cards (<code>/agent-cards</code>)","text":""},{"location":"developer_guide/registry/#post","title":"<code>POST /</code>","text":"<ul> <li>Summary: Submit a new Agent Card</li> <li>Description: Submits a new Agent Card associated with the authenticated developer. The provided <code>card_data</code> is validated against the canonical Agent Card schema.</li> <li>Authentication: Required (<code>X-Api-Key</code>).</li> <li>Request Body: <code>schemas.AgentCardCreate</code> <pre><code>{\n  \"card_data\": {\n    \"schemaVersion\": \"1.0\",\n    \"humanReadableId\": \"your-org/your-agent\",\n    \"agentVersion\": \"1.1.0\",\n    \"name\": \"My Awesome Agent\",\n    \"description\": \"This agent does amazing things.\",\n    \"url\": \"https://my-agent.example.com/a2a\",\n    \"provider\": { \"name\": \"My Org\" },\n    \"capabilities\": { \"a2aVersion\": \"1.0\" },\n    \"authSchemes\": [ { \"scheme\": \"apiKey\", \"service_identifier\": \"my-agent-service\" } ]\n    // ... other valid Agent Card fields ...\n  }\n}\n</code></pre></li> <li>Success Response (201 Created): <code>schemas.AgentCardRead</code> - Returns the full details of the newly created card record, including its generated UUID (<code>id</code>), timestamps, and the <code>developer_is_verified</code> status.     <pre><code>{\n  \"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",\n  \"developer_id\": 15,\n  \"developer_is_verified\": false,\n  \"card_data\": { /* ... submitted card_data ... */ },\n  \"name\": \"My Awesome Agent\",\n  \"description\": \"This agent does amazing things.\",\n  \"is_active\": true,\n  \"created_at\": \"2024-04-15T12:00:00Z\",\n  \"updated_at\": \"2024-04-15T12:00:00Z\"\n}\n</code></pre></li> <li>Errors: 401, 403, 422 (e.g., invalid <code>card_data</code>, duplicate <code>humanReadableId</code> if enforced), 500.</li> </ul>"},{"location":"developer_guide/registry/#get","title":"<code>GET /</code>","text":"<ul> <li>Summary: List Agent Cards</li> <li>Description: Retrieves a paginated list of Agent Cards, with options for filtering. By default, only active cards are returned.</li> <li>Authentication: Optional. Required only if <code>owned_only=true</code>.</li> <li>Query Parameters:<ul> <li><code>skip</code> (int, default: 0): Offset for pagination (e.g., <code>?skip=20</code>).</li> <li><code>limit</code> (int, default: 100, max: 250): Max items per page (e.g., <code>?limit=50</code>).</li> <li><code>active_only</code> (bool, default: true): Set to <code>false</code> to include inactive cards (e.g., <code>?active_only=false</code>).</li> <li><code>search</code> (str, optional): Case-insensitive search term applied to <code>name</code> and <code>description</code> (e.g., <code>?search=weather</code>).</li> <li><code>tags</code> (list[str], optional): Filter by tags. Provide the parameter multiple times for AND logic (e.g., <code>?tags=weather&amp;tags=forecast</code>). Requires agents to have all specified tags in <code>card_data.tags</code>.</li> <li><code>has_tee</code> (bool, optional): Filter by TEE support declaration (e.g., <code>?has_tee=true</code>).</li> <li><code>tee_type</code> (str, optional): Filter by specific TEE type string (e.g., <code>?tee_type=Intel SGX</code>).</li> <li><code>owned_only</code> (bool, default: false): If <code>true</code>, requires <code>X-Api-Key</code> header and returns only cards owned by the authenticated developer.</li> </ul> </li> <li>Success Response (200 OK): <code>schemas.AgentCardListResponse</code> <pre><code>{\n  \"items\": [\n    {\n      \"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",\n      \"name\": \"My Awesome Agent\",\n      \"description\": \"This agent does amazing things.\"\n    },\n    // ... other AgentCardSummary objects ...\n  ],\n  \"pagination\": {\n    \"total_items\": 150,\n    \"limit\": 100,\n    \"offset\": 0,\n    \"total_pages\": 2,\n    \"current_page\": 1\n  }\n}\n</code></pre></li> <li>Errors: 401 (if <code>owned_only=true</code> and auth fails), 500.</li> </ul>"},{"location":"developer_guide/registry/#get-card_id","title":"<code>GET /{card_id}</code>","text":"<ul> <li>Summary: Get Agent Card by ID</li> <li>Description: Retrieves the full details of a specific Agent Card by its UUID.</li> <li>Authentication: Public.</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The unique ID of the agent card (e.g., <code>a1b2c3d4-e5f6-7890-1234-567890abcdef</code>).</li> </ul> </li> <li>Success Response (200 OK): <code>schemas.AgentCardRead</code> (Similar structure to the <code>POST /</code> success response). Includes <code>card_data</code> and <code>developer_is_verified</code>.</li> <li>Errors: 404 (if ID not found), 500.</li> </ul>"},{"location":"developer_guide/registry/#put-card_id","title":"<code>PUT /{card_id}</code>","text":"<ul> <li>Summary: Update an Agent Card</li> <li>Description: Updates an existing Agent Card. Only the authenticated owner of the card can perform this action. Fields not included in the request body are left unchanged. If <code>card_data</code> is provided, it replaces the existing card data entirely after validation.</li> <li>Authentication: Required (<code>X-Api-Key</code>, must match card owner).</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The ID of the agent card to update.</li> </ul> </li> <li>Request Body: <code>schemas.AgentCardUpdate</code> <pre><code>{\n  \"card_data\": { /* ... complete new card data ... */ },\n  \"is_active\": false // Optional: Deactivate the card\n}\n</code></pre> Note: You only need to include the fields you want to change (<code>card_data</code> or <code>is_active</code>).</li> <li>Success Response (200 OK): <code>schemas.AgentCardRead</code> - Returns the full details of the updated card record.</li> <li>Errors: 401, 403 (if not owner), 404, 422 (if <code>card_data</code> is provided and invalid), 500.</li> </ul>"},{"location":"developer_guide/registry/#delete-card_id","title":"<code>DELETE /{card_id}</code>","text":"<ul> <li>Summary: Deactivate an Agent Card</li> <li>Description: Marks an Agent Card as inactive (<code>is_active = false</code>). This is a soft delete; the record remains but is typically excluded from public listings. Only the owner can deactivate.</li> <li>Authentication: Required (<code>X-Api-Key</code>, must match card owner).</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The ID of the agent card to deactivate.</li> </ul> </li> <li>Success Response: <code>204 No Content</code> (Empty body).</li> <li>Errors: 401, 403 (if not owner), 404, 500.</li> </ul>"},{"location":"developer_guide/registry/#utilities-utils","title":"Utilities (<code>/utils</code>)","text":""},{"location":"developer_guide/registry/#post-validate-card","title":"<code>POST /validate-card</code>","text":"<ul> <li>Summary: Validate Agent Card Data</li> <li>Description: Validates provided JSON data against the official AgentVault Agent Card schema without registering or storing it. Useful for developers checking their <code>agent-card.json</code> before submission.</li> <li>Authentication: Public.</li> <li>Request Body: <code>schemas.AgentCardValidationRequest</code> <pre><code>{\n  \"card_data\": {\n    \"schemaVersion\": \"1.0\",\n    \"name\": \"Agent to Validate\",\n    // ... other card fields ...\n  }\n}\n</code></pre></li> <li>Success Response (200 OK): <code>schemas.AgentCardValidationResponse</code><ul> <li>If Valid: <pre><code>{\n  \"is_valid\": true,\n  \"detail\": null,\n  \"validated_card_data\": { /* ... validated/normalized card data ... */ }\n}\n</code></pre></li> <li>If Invalid: <pre><code>{\n  \"is_valid\": false,\n  \"detail\": \"Validation Error: Field required [type=missing, loc=('humanReadableId',), ...]\",\n  \"validated_card_data\": null\n}\n</code></pre></li> </ul> </li> <li>Errors: 422 (if the request body itself is invalid, e.g., missing <code>card_data</code>), 500.</li> </ul>"},{"location":"developer_guide/server_sdk/","title":"Developer Guide: Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>The <code>agentvault-server-sdk</code> provides tools and abstractions to simplify the development of A2A-compliant agent servers in Python, particularly when using the FastAPI web framework. It helps you focus on your agent's core logic while the SDK handles much of the A2A protocol boilerplate.</p>"},{"location":"developer_guide/server_sdk/#installation","title":"Installation","text":"<p>Install the SDK from PyPI:</p> <pre><code>pip install agentvault-server-sdk\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"developer_guide/server_sdk/#core-concepts","title":"Core Concepts","text":"<p>The SDK revolves around implementing an agent logic class and integrating it with a web framework (currently FastAPI).</p>"},{"location":"developer_guide/server_sdk/#1-basea2aagent","title":"1. <code>BaseA2AAgent</code>","text":"<p>This is the abstract base class your agent logic should inherit from.</p> <ul> <li>Purpose: Defines the standard interface the A2A protocol expects.</li> <li>Required Methods: You must implement these <code>async</code> methods in your subclass:<ul> <li><code>handle_task_send(task_id: Optional[str], message: Message) -&gt; str</code>: Processes incoming messages, manages task creation/updates, returns the task ID.</li> <li><code>handle_task_get(task_id: str) -&gt; Task</code>: Retrieves the full state (<code>Task</code> model) of a specific task.</li> <li><code>handle_task_cancel(task_id: str) -&gt; bool</code>: Attempts to cancel a task, returning <code>True</code> if the request is accepted.</li> <li><code>handle_subscribe_request(task_id: str) -&gt; AsyncGenerator[A2AEvent, None]</code>: Returns an async generator yielding <code>A2AEvent</code> objects (status updates, messages, artifacts) for SSE streaming.</li> </ul> </li> <li>Alternative (<code>@a2a_method</code>): For agents handling only specific or custom methods, you can use the <code>@a2a_method</code> decorator instead of implementing all <code>handle_...</code> methods.</li> </ul>"},{"location":"developer_guide/server_sdk/#2-task-state-management-agentvault_server_sdkstate","title":"2. Task State Management (<code>agentvault_server_sdk.state</code>)","text":"<p>Handling asynchronous tasks requires managing their state (Submitted, Working, Completed, etc.) and potentially associated data (messages, artifacts).</p> <ul> <li><code>TaskContext</code>: A basic dataclass holding <code>task_id</code>, <code>current_state</code>, timestamps. Subclass this to store agent-specific task data.</li> <li><code>BaseTaskStore</code>: An abstract class defining the interface for storing and retrieving <code>TaskContext</code> objects (<code>create_task</code>, <code>get_task</code>, <code>update_task_state</code>, <code>delete_task</code>). It also defines interfaces for managing SSE listeners and notifying them.</li> <li><code>InMemoryTaskStore</code>: A simple, non-persistent dictionary-based implementation of <code>BaseTaskStore</code>. Suitable for development or single-instance agents where persistence isn't required. Production agents typically require a persistent store (e.g., Redis, Database).</li> <li>Notification Helpers: When using a <code>BaseTaskStore</code>, call methods like <code>task_store.notify_status_update(...)</code>, <code>task_store.notify_message_event(...)</code>, <code>task_store.notify_artifact_event(...)</code> from your agent logic. The SDK's router integration uses these to automatically send SSE events to subscribed clients.</li> </ul>"},{"location":"developer_guide/server_sdk/#3-fastapi-integration-create_a2a_router","title":"3. FastAPI Integration (<code>create_a2a_router</code>)","text":"<p>This function bridges your agent logic with the FastAPI web framework.</p> <ul> <li>Purpose: Creates a FastAPI <code>APIRouter</code> that automatically exposes the standard A2A JSON-RPC methods (<code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>) and routes them to your <code>BaseA2AAgent</code> implementation's corresponding <code>handle_...</code> methods (or decorated methods).</li> <li>Usage: <pre><code># In your main FastAPI app file (e.g., main.py)\nfrom fastapi import FastAPI\nfrom agentvault_server_sdk import create_a2a_router, BaseA2AAgent\nfrom agentvault_server_sdk.state import InMemoryTaskStore\n# Import your agent class\nfrom my_agent_logic import MyAgent\n\n# 1. Instantiate your agent and task store\ntask_store = InMemoryTaskStore()\nmy_agent_instance = MyAgent(task_store_ref=task_store) # Pass store if needed\n\n# 2. Create the A2A router\na2a_router = create_a2a_router(\n    agent=my_agent_instance,\n    task_store=task_store # Provide the store instance\n)\n\n# 3. Create the FastAPI app and include the router\napp = FastAPI(title=\"My A2A Agent\")\napp.include_router(a2a_router, prefix=\"/a2a\") # Mount at /a2a\n\n# 4. IMPORTANT: Add required exception handlers\n# (See example below and basic_a2a_server example)\n# ... add exception handlers ...\n</code></pre></li> <li>Exception Handling: The router relies on specific exception handlers being added to the main FastAPI app to translate internal errors (like <code>TaskNotFoundError</code>, <code>ValueError</code>, <code>AgentServerError</code>) into correct JSON-RPC error responses. You must add these handlers:     <pre><code>from fastapi import Request, FastAPI\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError as PydanticValidationError\nfrom agentvault_server_sdk.exceptions import AgentServerError, TaskNotFoundError\nfrom agentvault_server_sdk.fastapi_integration import (\n    task_not_found_handler, validation_exception_handler,\n    agent_server_error_handler, generic_exception_handler\n)\n\napp = FastAPI() # Your app instance\n# ... include router ...\n\napp.add_exception_handler(TaskNotFoundError, task_not_found_handler)\napp.add_exception_handler(ValueError, validation_exception_handler)\napp.add_exception_handler(TypeError, validation_exception_handler)\napp.add_exception_handler(PydanticValidationError, validation_exception_handler)\napp.add_exception_handler(AgentServerError, agent_server_error_handler)\napp.add_exception_handler(Exception, generic_exception_handler) # Catch-all\n</code></pre></li> </ul>"},{"location":"developer_guide/server_sdk/#4-a2a-method-decorator-a2a_method","title":"4. A2A Method Decorator (<code>@a2a_method</code>)","text":"<p>An alternative for exposing specific methods without implementing the full <code>BaseA2AAgent</code> interface.</p> <ul> <li>Purpose: Expose individual <code>async def</code> methods in your class as specific JSON-RPC methods. Useful for simpler agents or custom methods.</li> <li>Usage: <pre><code>from agentvault_server_sdk import BaseA2AAgent, a2a_method\nfrom agentvault.models import Task # Example import\n\nclass DecoratedAgent(BaseA2AAgent):\n\n    @a2a_method(\"custom/ping\")\n    async def ping_handler(self) -&gt; str:\n        return \"pong\"\n\n    @a2a_method(\"tasks/get\") # Override standard method\n    async def custom_get(self, id: str) -&gt; Task: # Params validated from type hints\n        # ... custom logic to fetch task ...\n        task_data = await get_my_task_data(id)\n        # Return value validated against type hint\n        return Task(**task_data)\n\n    # No need to implement handle_task_send, handle_task_cancel etc.\n    # if only using decorators for the methods you support.\n    # The router will return \"Method not found\" for others.\n</code></pre></li> <li>Validation: The router automatically validates incoming <code>params</code> against the decorated function's type hints and validates the return value against the function's return type hint using Pydantic.</li> </ul>"},{"location":"developer_guide/server_sdk/#5-packaging-tool-agentvault-sdk-package","title":"5. Packaging Tool (<code>agentvault-sdk package</code>)","text":"<p>A CLI tool to help prepare your agent for deployment, typically via Docker.</p> <ul> <li>Command: <code>agentvault-sdk package [OPTIONS]</code></li> <li>Functionality: Generates a standard multi-stage <code>Dockerfile</code>, a <code>.dockerignore</code> file, and copies <code>requirements.txt</code> and optionally <code>agent-card.json</code> to an output directory.</li> <li>Key Options:<ul> <li><code>--output-dir</code> / <code>-o</code> (Required): Where to put generated files.</li> <li><code>--entrypoint</code> / <code>-e</code> (Required): Import path to your FastAPI app instance (e.g., <code>my_agent.main:app</code>).</li> <li><code>--python</code>: Python version for Docker image (default: 3.11).</li> <li><code>--suffix</code>: Base image suffix (default: slim-bookworm).</li> <li><code>--port</code>: Port inside the container (default: 8000).</li> <li><code>--requirements</code> / <code>-r</code>: Path to <code>requirements.txt</code> (defaults to <code>./requirements.txt</code>).</li> <li><code>--agent-card</code> / <code>-c</code>: Path to <code>agent-card.json</code> to copy.</li> </ul> </li> <li>Example: <pre><code>agentvault-sdk package -o ./build -e my_agent.main:app -r ./requirements.txt -c ./agent-card.json\n# Then build: docker build -t my-agent-image -f ./build/Dockerfile .\n</code></pre></li> </ul>"},{"location":"developer_guide/server_sdk/#building-a-basic-agent-conceptual-steps","title":"Building a Basic Agent (Conceptual Steps)","text":"<ol> <li>Define Agent Logic: Create a class inheriting from <code>BaseA2AAgent</code>.</li> <li>Implement Handlers/Methods: Implement the required <code>handle_...</code> methods or use the <code>@a2a_method</code> decorator for the A2A methods your agent supports. Use a <code>TaskStore</code> (like <code>InMemoryTaskStore</code> initially) to manage state. Use <code>notify_...</code> methods on the store to trigger SSE events.</li> <li>Create FastAPI App: Set up a basic FastAPI application (<code>main.py</code>).</li> <li>Instantiate Agent &amp; Store: Create instances of your agent class and task store.</li> <li>Create &amp; Include Router: Use <code>create_a2a_router(agent=..., task_store=...)</code> and include it in your FastAPI app (e.g., at prefix <code>/a2a</code>).</li> <li>Add Exception Handlers: Add the required handlers (shown above) to your main FastAPI app instance.</li> <li>Create Agent Card: Write an <code>agent-card.json</code> describing your agent, ensuring the <code>url</code> points to your FastAPI endpoint (e.g., <code>http://your-host/a2a</code>).</li> <li>Run: Use <code>uvicorn main:app --host ... --port ...</code>.</li> <li>(Optional) Package: Use <code>agentvault-sdk package</code> to create Docker artifacts.</li> </ol> <p>Refer to the Basic A2A Server Example for a runnable implementation.</p>"},{"location":"developer_guide/testing/","title":"Developer Guide: Testing Utilities (<code>agentvault-testing-utils</code>)","text":"<p>The <code>agentvault-testing-utils</code> package is an internal development tool providing shared mocks, pytest fixtures, data factories, and helper functions. Its purpose is to streamline and standardize testing across the different AgentVault components (<code>agentvault_library</code>, <code>agentvault_cli</code>, <code>agentvault_registry</code>, <code>agentvault_server_sdk</code>).</p> <p>Note: This package is not intended for end-users or for distribution on PyPI. It's used within the AgentVault monorepo's development workflow.</p>"},{"location":"developer_guide/testing/#installation","title":"Installation","text":"<p>This package is installed as a development dependency when setting up the main project environment using Poetry:</p> <pre><code># From the monorepo root (AgentVault/)\npoetry install --with dev\n</code></pre>"},{"location":"developer_guide/testing/#provided-utilities","title":"Provided Utilities","text":""},{"location":"developer_guide/testing/#1-mocks-mockspy","title":"1. Mocks (<code>mocks.py</code>)","text":"<ul> <li><code>MockAgentVaultClient</code>:<ul> <li>Purpose: A mock implementation of <code>agentvault.client.AgentVaultClient</code>. Use this in tests for components that use the client library (like the CLI or potentially other agents) to simulate A2A interactions without network calls.</li> <li>Features:<ul> <li>Configurable return values for async methods (e.g., <code>initiate_task_return_value</code>).</li> <li>Configurable side effects (exceptions) for async methods (e.g., <code>get_task_status_side_effect = A2AConnectionError(...)</code>).</li> <li>Call recording via the <code>call_recorder</code> attribute (an <code>unittest.mock.AsyncMock</code> instance).</li> <li>Supports async context management (<code>async with</code>).</li> </ul> </li> <li>Example: <pre><code>import pytest\nfrom agentvault_testing_utils.mocks import MockAgentVaultClient\nfrom agentvault.models import Task, TaskState\nfrom agentvault.exceptions import A2AConnectionError\nfrom unittest.mock import call\n\n@pytest.mark.asyncio\nasync def test_cli_run_logic(mocker): # Assuming mocker fixture\n    mock_client = MockAgentVaultClient()\n    # Patch the client instantiation in the module under test\n    mocker.patch('agentvault_cli.commands.run.av_client.AgentVaultClient', return_value=mock_client)\n\n    # Configure mock behavior\n    mock_client.initiate_task_return_value = \"task-from-mock\"\n    mock_task_result = Task(...) # Create or mock a Task object\n    mock_client.get_task_status_return_value = mock_task_result\n\n    # --- Run the CLI command or function under test ---\n    # result = await run_cli_command(...)\n\n    # --- Assert interactions with the mock client ---\n    mock_client.call_recorder.initiate_task.assert_awaited_once()\n    mock_client.call_recorder.get_task_status.assert_awaited_with(\n         agent_card=ANY, task_id=\"task-from-mock\", key_manager=ANY\n    )\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#2-mock-server-fixtures-mock_serverpy-fixturespy","title":"2. Mock Server &amp; Fixtures (<code>mock_server.py</code>, <code>fixtures.py</code>)","text":"<ul> <li><code>mock_a2a_server</code> (Pytest Fixture):<ul> <li>Purpose: Provides a more realistic testing environment by mocking the HTTP endpoints of an A2A agent server and its associated OAuth token endpoint using <code>respx</code>. Useful for testing the <code>AgentVaultClient</code> itself or components that make real HTTP requests.</li> <li>Features:<ul> <li>Sets up <code>respx</code> routes for <code>POST /a2a</code> and <code>POST /token</code>.</li> <li>Handles basic JSON-RPC routing (<code>tasks/send</code>, <code>get</code>, <code>cancel</code>, <code>sendSubscribe</code>).</li> <li>Simulates basic task state via an in-memory <code>task_store</code> dictionary accessible from the fixture.</li> <li>Simulates SSE streaming for <code>tasks/sendSubscribe</code> based on an <code>sse_event_store</code> dictionary accessible from the fixture.</li> <li>Provides the <code>base_url</code> of the mock server.</li> </ul> </li> <li>Return Type: <code>MockServerInfo</code> (NamedTuple) with fields <code>base_url</code>, <code>task_store</code>, <code>sse_event_store</code>.</li> <li>Example: <pre><code>import pytest\nimport httpx\nfrom agentvault_testing_utils.fixtures import mock_a2a_server, MockServerInfo\nfrom agentvault.models import TaskState, TaskStatusUpdateEvent # Example event\nimport datetime\n\n@pytest.mark.asyncio\nasync def test_client_against_mock_server(mock_a2a_server: MockServerInfo):\n    # Configure the mock server's state BEFORE making the call\n    task_id = \"live-test-task\"\n    mock_a2a_server.task_store[task_id] = {\"state\": TaskState.WORKING}\n    mock_a2a_server.sse_event_store[task_id] = [\n        TaskStatusUpdateEvent(taskId=task_id, state=TaskState.COMPLETED, timestamp=datetime.datetime.now(datetime.timezone.utc))\n    ]\n\n    # Use httpx or AgentVaultClient to interact with mock_a2a_server.base_url\n    async with httpx.AsyncClient() as client:\n        response = await client.post(f\"{mock_a2a_server.base_url}/a2a\", json={...})\n        # ... assertions ...\n\n    # Check if the mock server state was updated (e.g., after a cancel call)\n    # assert mock_a2a_server.task_store[task_id][\"state\"] == TaskState.CANCELED\n</code></pre></li> </ul> </li> <li><code>setup_mock_a2a_routes</code>: The underlying function used by the fixture to configure <code>respx</code>. Can be used directly for custom setups.</li> <li>JSON-RPC Helpers: <code>create_jsonrpc_success_response</code>, <code>create_jsonrpc_error_response</code>.</li> </ul>"},{"location":"developer_guide/testing/#3-factories-factoriespy","title":"3. Factories (<code>factories.py</code>)","text":"<ul> <li><code>create_test_agent_card(**overrides)</code>:<ul> <li>Purpose: Generates <code>agentvault.models.AgentCard</code> Pydantic model instances with sensible default values. Simplifies creating valid test data.</li> <li>Features: Accepts keyword arguments to override any top-level or nested field in the default card structure. Performs validation using the actual <code>AgentCard</code> model.</li> <li>Example: <pre><code>from agentvault_testing_utils.factories import create_test_agent_card\n\ndefault_card = create_test_agent_card()\ncustom_card = create_test_agent_card(\n    name=\"OAuth Agent\",\n    authSchemes=[{\"scheme\": \"oauth2\", \"tokenUrl\": \"https://test.com/token\"}]\n)\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#4-test-agents-agentspy","title":"4. Test Agents (<code>agents.py</code>)","text":"<ul> <li><code>EchoAgent</code>:<ul> <li>Purpose: A minimal, functional implementation of <code>agentvault_server_sdk.BaseA2AAgent</code>. It stores received messages in memory, echoes the first message content back via SSE, and transitions through basic states (Submitted -&gt; Working -&gt; Completed).</li> <li>Use Case: Ideal for testing the Server SDK's <code>create_a2a_router</code>, basic A2A client interactions, and SSE streaming logic without needing a complex real agent.</li> <li>Example: See the Server SDK Developer Guide or the <code>basic_a2a_server</code> example.</li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#5-assertion-helpers-assertionspy","title":"5. Assertion Helpers (<code>assertions.py</code>)","text":"<ul> <li>Purpose: Provide convenient functions for asserting that specific A2A calls were made, simplifying tests that interact with <code>MockAgentVaultClient</code> or <code>respx</code>.</li> <li>Key Functions:<ul> <li><code>assert_a2a_call(mock_calls, method, params_contain=None, req_id=None)</code>: Checks if any call in the provided list (<code>httpx.Request</code> list or <code>MagicMock.call_args_list</code>) matches the specified JSON-RPC <code>method</code>, optional <code>req_id</code>, and optionally contains the key-value pairs in <code>params_contain</code> within its <code>params</code> object.</li> <li><code>assert_a2a_sequence(mock_calls, expected_sequence)</code>: Checks if the sequence of parseable A2A calls matches the <code>expected_sequence</code> (a list of <code>(method, params_contain)</code> tuples).</li> <li>Example: <pre><code>from agentvault_testing_utils.assertions import assert_a2a_call, assert_a2a_sequence\nfrom unittest.mock import call # For sequence assertion\n\n# Using MockAgentVaultClient\n# await mock_client.initiate_task(...)\n# await mock_client.get_task_status(...)\n# assert_a2a_call(mock_client.call_recorder, method=\"tasks/get\", params_contain={\"id\": \"task-id\"})\n# expected_seq = [(\"initiate_task\", None), (\"get_task_status\", {\"task_id\": \"task-id\"})] # Note: Uses method name for mock recorder\n# assert_a2a_sequence(mock_client.call_recorder, expected_seq)\n\n# Using respx\n# with respx.mock:\n#     # setup routes...\n#     # make httpx calls...\n# assert_a2a_call(respx.calls, method=\"tasks/send\", params_contain={\"message\": {\"role\": \"user\"}})\n</code></pre></li> </ul> </li> </ul>"},{"location":"user_guide/cli/","title":"User Guide: AgentVault CLI (<code>agentvault_cli</code>)","text":"<p>The <code>agentvault_cli</code> is your command-line tool for interacting with the AgentVault ecosystem. It allows you to manage credentials for accessing agents, discover agents registered in the central registry, and execute tasks on remote A2A-compliant agents.</p>"},{"location":"user_guide/cli/#installation","title":"Installation","text":"<p>Please refer to the main Installation Guide for instructions on installing the CLI using <code>pip</code>.</p>"},{"location":"user_guide/cli/#core-commands","title":"Core Commands","text":"<p>The CLI is structured around several main commands. Get an overview by running:</p> <pre><code>agentvault_cli --help\n</code></pre>"},{"location":"user_guide/cli/#config","title":"<code>config</code>","text":"<p>Manage local API keys and OAuth credentials required to authenticate with different agents or services. Credentials can be stored securely in the OS keyring or referenced via environment variables or files.</p> <p>Usage:</p> <pre><code>agentvault_cli config --help\n</code></pre> <p>This command group helps you configure how the <code>agentvault_cli run</code> command (and underlying library) finds the necessary secrets to talk to different agents.</p> <p>Key Subcommands:</p> <ul> <li> <p><code>set &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Configure how credentials for a specific service (identified by <code>&lt;service_id&gt;</code>) are sourced or stored. The <code>&lt;service_id&gt;</code> is a name you choose locally (e.g., <code>openai</code>, <code>my-custom-agent-key</code>, <code>google-oauth-agent</code>) that the <code>KeyManager</code> uses to find the right secret. It often corresponds to the <code>service_identifier</code> in an Agent Card's <code>authSchemes</code>, but can be different.</li> <li>Options:<ul> <li><code>--env</code>: Guidance Only. Prints instructions on how to set environment variables (<code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code>). It does not store anything itself.</li> <li><code>--file &lt;path&gt;</code>: Guidance Only. Prints instructions on how to format a <code>.env</code> or <code>.json</code> file to store credentials that the <code>KeyManager</code> could potentially load (if configured during library initialization, which the CLI doesn't do by default).</li> <li><code>--keyring</code>: Stores API Key. Securely prompts for an API key and stores it in your operating system's default keyring, associated with the <code>&lt;service_id&gt;</code>. This is the recommended secure method for storing API keys via the CLI.</li> <li><code>--oauth-configure</code>: Stores OAuth Credentials. Securely prompts for an OAuth 2.0 Client ID and Client Secret and stores them in the OS keyring, associated with the <code>&lt;service_id&gt;</code>. Required for agents using the <code>oauth2</code> authentication scheme.</li> </ul> </li> </ul> <p>Example (Store OpenAI API Key securely): <pre><code># Use 'openai' as the local service_id\nagentvault_cli config set openai --keyring\n# --&gt; Enter API key: ************\n# --&gt; Confirm API key: ************\n# SUCCESS: API key for 'openai' stored successfully in keyring.\n</code></pre> Example (Configure OAuth for a Google agent): <pre><code># Use 'google-agent-oauth' as the local service_id\nagentvault_cli config set google-agent-oauth --oauth-configure\n# --&gt; Enter OAuth Client ID for 'google-agent-oauth': &lt;paste_client_id&gt;\n# --&gt; Enter OAuth Client Secret for 'google-agent-oauth': ************\n# --&gt; Confirm OAuth Client Secret for 'google-agent-oauth': ************\n# SUCCESS: OAuth credentials for 'google-agent-oauth' stored successfully in keyring.\n</code></pre> Example (Guidance for Environment Variables): <pre><code>agentvault_cli config set anthropic --env\n# --&gt; Guidance: To use environment variables for 'anthropic':\n# --&gt;   For API Key: Set AGENTVAULT_KEY_ANTHROPIC=&lt;your_api_key&gt;\n# --&gt;   ... (OAuth guidance also shown) ...\n</code></pre></p> </li> <li> <p><code>get &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Checks how credentials for a given <code>&lt;service_id&gt;</code> are currently being sourced by the <code>KeyManager</code> (Environment, File, Keyring). It checks the cache first, then attempts to load from the keyring if enabled.</li> <li>Options:<ul> <li><code>--show-key</code>: Displays the first few characters of the found API key (use with caution).</li> <li><code>--show-oauth-id</code>: Displays the configured OAuth Client ID if found. Example: <pre><code>agentvault_cli config get openai\n# --&gt; Credential status for service 'openai':\n# --&gt;   API Key: Found (Source: KEYRING)\n# --&gt;     (Use --show-key to display a masked version)\n# --&gt;   OAuth Credentials: Not Configured\n\nagentvault_cli config get google-agent-oauth --show-oauth-id\n# --&gt; Credential status for service 'google-agent-oauth':\n# --&gt;   API Key: Not Found\n# --&gt;   OAuth Credentials: Configured (Source: KEYRING)\n# --&gt;     Client ID: 12345-abcde.apps.googleusercontent.com\n</code></pre></li> </ul> </li> </ul> </li> <li> <p><code>list</code>:</p> <ul> <li>Purpose: Shows a summary of services for which credentials have been detected during initialization from environment variables or specified key files (if the underlying library was configured with a key file path, which the default CLI is not).</li> <li>Note: This command does not actively scan the OS keyring. Keys stored only in the keyring will typically not appear in this list unless they were accessed previously by a <code>get</code> command in the same CLI invocation.</li> </ul> </li> </ul>"},{"location":"user_guide/cli/#discover","title":"<code>discover</code>","text":"<p>Search for agents registered in the central AgentVault Registry.</p> <p>Usage:</p> <pre><code>agentvault_cli discover --help\nagentvault_cli discover [SEARCH_QUERY] [OPTIONS]```\n\n*   **`[SEARCH_QUERY]` (Optional):** Text to search for (case-insensitive) in agent names or descriptions.\n*   **`--registry &lt;url&gt;`:** Specify the URL of the AgentVault Registry. Defaults to `http://localhost:8000` or the value of the `AGENTVAULT_REGISTRY_URL` environment variable if set.\n*   **`--limit &lt;n&gt;`:** Maximum results per page (default: 25, max: 250).\n*   **`--offset &lt;n&gt;`:** Number of results to skip (for pagination, default: 0).\n*   **`--tags &lt;tag&gt;` (Repeatable):** Filter by tags. Only agents possessing *all* specified tags will be returned (e.g., `--tags weather --tags forecast`).\n*   **`--has-tee [true|false]` (Optional):** Filter agents based on whether they declare TEE support in their Agent Card.\n*   **`--tee-type &lt;type&gt;` (Optional):** Filter agents by the specific TEE type declared (e.g., `AWS Nitro Enclaves`, `Intel SGX`).\n\n*Example:*\n```bash\n# List first 10 agents containing \"weather\"\nagentvault_cli discover weather --limit 10\n\n# List agents tagged with both \"summarization\" and \"nlp\"\nagentvault_cli discover --tags summarization --tags nlp\n\n# Find agents declaring TEE support\nagentvault_cli discover --has-tee true\n</code></pre> <p>The output is displayed in a table format.</p>"},{"location":"user_guide/cli/#run","title":"<code>run</code>","text":"<p>Execute a task on a specific remote agent using the A2A protocol.</p> <p>Usage:</p> <pre><code>agentvault_cli run --help\nagentvault_cli run --agent &lt;agent_ref&gt; --input &lt;input_data&gt; [OPTIONS]\n</code></pre> <ul> <li><code>--agent &lt;agent_ref&gt;</code> / <code>-a &lt;agent_ref&gt;</code> (Required): Identifies the target agent. This is crucial. It can be:<ul> <li>An Agent ID from the registry (e.g., <code>examples/simple-agent</code>, <code>my-org/my-agent</code>). The CLI will use the <code>--registry</code> URL to fetch the corresponding Agent Card.</li> <li>A direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>A local file path to the agent's <code>agent-card.json</code> (e.g., <code>../examples/basic_a2a_server/agent-card.json</code>).</li> </ul> </li> <li><code>--input &lt;input_data&gt;</code> / <code>-i &lt;input_data&gt;</code> (Required): The input text for the agent's task.<ul> <li>To read input from a file, prefix the path with <code>@</code>. Example: <code>--input @./prompts/my_request.txt</code>.</li> </ul> </li> <li><code>--context-file &lt;path&gt;</code>: Path to a local JSON file containing MCP context data to send with the initial message.</li> <li><code>--registry &lt;url&gt;</code>: Registry URL (only used if <code>&lt;agent_ref&gt;</code> is an Agent ID). Defaults to <code>http://localhost:8000</code> or <code>AGENTVAULT_REGISTRY_URL</code> env var.</li> <li><code>--key-service &lt;service_id&gt;</code>: Important for Authentication. If the agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>) and its Agent Card doesn't specify a <code>service_identifier</code>, or if you want to use credentials stored under a different local name, use this flag to tell the <code>KeyManager</code> which local service ID to use for lookup. Example: <code>--key-service openai</code>.</li> <li><code>--auth-key &lt;key&gt;</code>: INSECURE - FOR TESTING ONLY. Directly provide the API key on the command line. This bypasses the <code>KeyManager</code> lookup for agents using the <code>apiKey</code> scheme. Avoid using this for sensitive keys.</li> <li><code>--output-artifacts &lt;directory&gt;</code>: If provided, artifact content larger than 1KB received via SSE will be saved to files in this directory (named using artifact ID and inferred extension) instead of being printed (truncated) to the console.</li> </ul> <p>Example (Running the basic SDK example agent): <pre><code># Assumes the basic_a2a_server example is running on port 8000\nagentvault_cli run --agent http://localhost:8000/agent-card.json --input \"Hello Agent!\"\n</code></pre></p> <p>Example (Running an agent from registry requiring an OpenAI key): <pre><code># First, ensure the key is configured:\n# agentvault config set openai --keyring (and enter key)\n\n# Then run the task (assuming agent 'some-org/openai-agent' uses 'openai' service ID)\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize the concept of AI agents.\"\n\n# Or, if the agent card didn't specify 'openai' as service_identifier:\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize...\" --key-service openai```\n\nThe `run` command connects to the agent and streams Server-Sent Events (SSE) back to your terminal, showing status updates, messages from the agent/tools, and artifact information using `rich` formatting for better readability.\n\n## Usage Tips\n\n*(Same as before - Shell History, fzf + awk)*\n\n### Re-running `run` Commands\n\nThe `agentvault_cli run` command can sometimes involve long agent identifiers or input strings. To easily recall and reuse previous commands:\n\n*   **Shell History Search (Ctrl+R):** Most shells allow you to search your command history interactively. Press `Ctrl+R` and start typing parts of the command you want to find (e.g., `run`, the agent ID, part of the input).\n*   **`history` Command:** Use `history | grep agentvault_cli run` (or similar filter) to list previous run commands. You can then execute a specific command number (e.g., `!123`).\n*   **`fzf` (Fuzzy Finder):** If you have `fzf` installed, you can pipe your history to it for interactive fuzzy searching: `history | fzf`. Select the desired command and press Enter to execute it. This is very powerful for quickly finding complex commands.\n\n### Interactive Agent Selection (`discover` + `fzf`)\n\nIf you have command-line tools like `fzf` (fuzzy finder) and `awk` installed, you can create powerful interactive workflows. For example, to discover agents, select one interactively, and then immediately run a task on it:\n\n```bash\n# Example: Discover agents matching \"weather\", select one, run with input\nagentvault_cli discover weather | fzf --height 40% --border --header \"Select Agent:\" | awk '{print $1}' | xargs -I {} agentvault_cli run --agent {} --input \"What is the forecast for London?\"\n</code></pre></p> <p>Explanation:</p> <ol> <li><code>agentvault_cli discover weather</code>: Lists agents matching \"weather\".</li> <li><code>| fzf ...</code>: Pipes the list to <code>fzf</code> for interactive selection.</li> <li><code>| awk '{print $1}'</code>: Extracts the first column (the Agent ID) from the line selected in <code>fzf</code>. Note: You might need to adjust <code>$1</code> if the ID is in a different column based on your terminal width or <code>discover</code> output format.</li> <li><code>| xargs -I {} ...</code>: Takes the extracted ID (<code>{}</code>) and inserts it into the <code>agentvault_cli run</code> command.</li> </ol> <p>This allows you to quickly find and use agents without manually copying and pasting IDs.</p>"}]}