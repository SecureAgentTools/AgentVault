{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentVault","text":"<p>AgentVault is an open-source ecosystem designed to facilitate secure and interoperable communication between AI agents (Agent-to-Agent or A2A).</p> <p>This project provides libraries, tools, and specifications to enable seamless interaction in a multi-agent world.</p> <p>\u27a1\ufe0f Public Registry &amp; UI Available!</p> <p>A live instance of the AgentVault Registry API and its associated Web UI is hosted at: <code>https://agentvault-registry-api.onrender.com</code></p> <ul> <li>Public Discovery UI: <code>https://agentvault-registry-api.onrender.com/ui</code></li> <li>Developer Portal UI: <code>https://agentvault-registry-api.onrender.com/ui/developer</code> (Login/Register here to manage agents)</li> <li>API Base: <code>https://agentvault-registry-api.onrender.com/api/v1</code></li> <li>Note (Cold Start): This is hosted on Render's free tier. If inactive, it may take up to 60 seconds to \"wake up\" on the first request. You can visit the <code>/health</code> endpoint or the UI to wake it up.</li> </ul> <p>\u27a1\ufe0f For detailed documentation, please visit the AgentVault Documentation Hub \u2b05\ufe0f</p>"},{"location":"#components","title":"Components","text":"<p>The AgentVault monorepo contains the following key components:</p> <ul> <li><code>agentvault_library</code>: (Developer Guide) Core Python client library for interacting with A2A agents, managing keys, and handling protocols (A2A, MCP).</li> <li><code>agentvault_cli</code>: (User Guide) Command-line interface for users and developers to manage credentials, discover agents, and run tasks.</li> <li><code>agentvault_registry</code>: (Developer Guide) Backend API server (FastAPI) acting as the central discovery point for registered agents. Also serves a Web UI for public discovery (<code>/ui</code>) and developer management (<code>/ui/developer</code>). (Live instance available above)</li> <li><code>agentvault_server_sdk</code>: (Developer Guide) Python SDK to help developers build A2A-compliant agent servers easily, integrating with frameworks like FastAPI. Includes packaging tools.</li> <li><code>agentvault_testing_utils</code>: (Developer Guide) Shared mocks, fixtures, factories, and helpers for testing AgentVault components.</li> <li><code>examples/</code>: Contains practical examples demonstrating how to use the SDK and library (e.g., basic A2A server, LangChain integration). See the Examples Overview.</li> <li><code>automation_scripts/</code>: Scripts to automate common workflows like agent packaging and deployment.</li> <li><code>docs/</code>: Source files for this documentation website (built with MkDocs).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Please refer to the Installation Guide. For development setup, see the Contributing Guide.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Contributing Guide for details on setting up the development environment, running tests, and submitting changes.</p>"},{"location":"#license","title":"License","text":"<p>AgentVault is licensed under the Apache License, Version 2.0. See the LICENSE file in the project root for details.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to AgentVault","text":"<p>First off, thank you for considering contributing to AgentVault! It's people like you that make open source great. Your contributions help build a robust and interoperable ecosystem for AI agents.</p> <p>Please take a moment to review this document in order to make the contribution process easy and effective for everyone involved.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository: Start by forking the main AgentVault repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.     <pre><code>git clone https://github.com/YOUR-USERNAME/AgentVault.git\ncd AgentVault\n</code></pre></li> <li>Install Prerequisites: Ensure you have Git and a compatible Python version (3.10 or 3.11) installed.</li> <li>Install Poetry: If you don't have Poetry installed, follow the instructions on the official Poetry website. Poetry is used for dependency management and packaging across the monorepo.</li> <li>Set up Virtual Environment &amp; Install Dependencies: Navigate to the project root (<code>AgentVault/</code>) and run:     <pre><code>poetry install --with dev\n</code></pre>     This command performs several crucial steps:<ul> <li>Reads the <code>pyproject.toml</code> files within each component package (<code>agentvault_library</code>, <code>agentvault_cli</code>, etc.).</li> <li>Resolves all dependencies across the entire workspace, ensuring compatibility.</li> <li>Creates a single virtual environment (usually <code>.venv/</code> in the project root) for the whole project.</li> <li>Installs all production and development dependencies (like <code>pytest</code>, <code>httpx</code>, <code>mkdocs</code>, <code>ruff</code>) into this shared virtual environment.</li> </ul> </li> <li>Activate Virtual Environment: Before running any commands, tests, or development servers, activate the virtual environment:<ul> <li>Linux/macOS (bash/zsh): <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Windows (PowerShell): <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\.venv\\Scripts\\activate.bat\n</code></pre> Your command prompt should now indicate you are inside the <code>(.venv)</code> environment.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":"<ol> <li>Find/Create an Issue: Look for existing issues or create a new one on GitHub to discuss the bug or feature you want to work on. This helps coordinate efforts.</li> <li>Branching: Create a descriptive feature branch off the <code>main</code> branch:     <pre><code>git checkout main\ngit pull origin main # Ensure your main is up-to-date\ngit checkout -b feat/my-new-feature # Or fix/resolve-issue-123\n</code></pre></li> <li>Coding:<ul> <li>Make your changes within the relevant component directory (e.g., <code>agentvault_library/src/agentvault/</code>, <code>agentvault_cli/src/agentvault_cli/</code>).</li> <li>Follow existing code style and patterns. We aim for clean, readable, and type-hinted Python code.</li> <li>Ensure new functions, classes, and modules have appropriate docstrings.</li> </ul> </li> <li>Testing:<ul> <li>Write Tests: Add new unit or integration tests for your changes within the corresponding component's <code>tests/</code> directory.</li> <li>Run Tests: Navigate to the component's directory (e.g., <code>cd agentvault_library</code>) and run <code>pytest</code>. Ensure all tests pass, including your new ones.</li> <li>Run All Tests (Optional): From the project root, you can run <code>pytest</code> to execute tests for all components (ensure <code>pytest.ini</code> at the root is configured correctly).</li> </ul> </li> <li>Linting &amp; Formatting: (Tooling setup TBD - e.g., Black, Ruff) Run the project's code formatter and linter to ensure consistency.</li> <li>Documentation: If your changes affect user-facing behavior, APIs, or architecture, update the relevant documentation pages in the <code>/docs</code> directory. Build the docs locally (<code>mkdocs serve</code> from the root) to preview your changes.</li> <li>Committing: Write clear, concise commit messages using conventional commit style (e.g., <code>feat(sdk): Add helper for SSE events</code>, <code>fix(cli): Correct handling of --output-artifacts</code>, <code>docs(library): Improve KeyManager examples</code>). Reference the relevant GitHub issue number (e.g., <code>feat(registry): Implement tag filtering (#42)</code>).</li> <li>Pull Request:<ul> <li>Push your feature branch to your fork: <code>git push origin feat/my-new-feature</code></li> <li>Go to the main AgentVault repository on GitHub and open a Pull Request (PR) from your branch to the <code>main</code> branch.</li> <li>Provide a clear title and description for your PR, explaining the changes and linking to the relevant issue(s).</li> <li>Ensure all automated checks (CI workflows like tests and dependency audits) pass on your PR. Address any failures.</li> <li>Engage in the code review process if feedback is provided.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#code-style","title":"Code Style","text":"<p>(Placeholder: This section will be updated once specific tools like Black/Ruff are enforced via pre-commit hooks or CI.)</p> <p>Generally, adhere to PEP 8 guidelines and follow the style of the existing codebase. Use type hints extensively.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<ul> <li>Unit Tests: Focus on testing individual functions and classes in isolation. Place these in the relevant component's <code>tests/</code> directory (e.g., <code>agentvault_library/tests/library/</code>).</li> <li>Integration Tests: Test the interaction between different parts of a component or between components (e.g., CLI using the Library against a mock server). Place these in appropriate subdirectories within <code>tests/</code>.</li> <li>Coverage: Aim for high test coverage for new code. (Coverage reporting setup TBD).</li> <li>Running Tests: Activate the virtual environment and run <code>pytest</code> from the component directory or the project root.</li> </ul>"},{"location":"CONTRIBUTING/#dependency-security","title":"Dependency Security","text":"<p>This project uses <code>pip-audit</code> via a GitHub Actions workflow (<code>.github/workflows/dependency_audit.yml</code>) to automatically check for known vulnerabilities in project dependencies based on the <code>poetry.lock</code> files.</p> <ul> <li>Workflow: Triggers on pushes/PRs to <code>main</code>. Audits each component separately.</li> <li>Reviewing Audits: Check the \"Actions\" tab on GitHub for the \"Security Dependency Audit\" results. Failures indicate known vulnerabilities.</li> <li>Updating Dependencies: Use <code>poetry update &lt;package_name&gt;</code> within a component directory to update specific dependencies, or <code>poetry update</code> to update all allowed by <code>pyproject.toml</code>. Always re-run <code>poetry lock</code> and commit the updated lock file. Re-run tests thoroughly after updates.</li> </ul>"},{"location":"CONTRIBUTING/#reporting-issues-security-vulnerabilities","title":"Reporting Issues &amp; Security Vulnerabilities","text":"<ul> <li>Bugs &amp; Feature Requests: Please check existing GitHub Issues first. If your issue isn't there, open a new one with detailed information.</li> <li>Security Vulnerabilities: DO NOT report security issues publicly. Please follow the instructions in our Security Policy (security_policy.md).</li> </ul>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>This project adheres to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code.</p> <p>Thank you for contributing to AgentVault!</p>"},{"location":"REGISTRY_POLICY/","title":"AgentVault Registry Policy","text":""},{"location":"REGISTRY_POLICY/#1-purpose-of-the-registry","title":"1. Purpose of the Registry","text":"<p>The AgentVault Registry serves as a public discovery hub for AI agents compatible with the AgentVault ecosystem and the Agent-to-Agent (A2A) protocol. Its primary purpose is to store and serve standardized Agent Card metadata submitted by agent developers.</p> <p>The Registry DOES NOT:</p> <ul> <li>Execute or host third-party agents.</li> <li>Handle, store, or process end-user API keys (like OpenAI, Anthropic keys).</li> <li>Proxy or monitor A2A communication between clients and agents.</li> <li>Guarantee the functionality, security, safety, or ethical behavior of the agents listed.</li> </ul>"},{"location":"REGISTRY_POLICY/#2-agent-card-submissions","title":"2. Agent Card Submissions","text":"<ul> <li>Eligibility: Only authenticated developers who have registered with the AgentVault Registry service (process TBD, currently via API key assigned by maintainers) can submit, update, or deactivate Agent Cards.</li> <li>Responsibility: Developers are solely responsible for the accuracy and completeness of the information provided in their submitted Agent Cards, including endpoint URLs, authentication details, descriptions, and links to their own policies.</li> </ul>"},{"location":"REGISTRY_POLICY/#3-vetting-process","title":"3. Vetting Process","text":"<ul> <li>Automated Validation: Submitted Agent Cards undergo automated validation against the official A2A Agent Card schema (<code>agentvault.models.AgentCard</code>) to ensure structural correctness. Basic checks may also be performed to verify the format of the specified A2A endpoint URL.</li> <li>No Behavioral Vetting: The AgentVault Registry does not perform manual reviews or vetting of the underlying agent's functionality, security practices, data handling procedures, or ethical alignment. Listing in the registry does not imply endorsement or certification by the AgentVault project.</li> </ul>"},{"location":"REGISTRY_POLICY/#4-content-guidelines-summary","title":"4. Content Guidelines (Summary)","text":"<p>Agent Card metadata submitted to the registry must not:</p> <ul> <li>Promote or facilitate illegal activities.</li> <li>Contain hateful, discriminatory, or harassing content.</li> <li>Be intentionally deceptive or misleading about the agent's capabilities or purpose.</li> <li>Infringe on the intellectual property rights of others.</li> <li>Link to malicious websites or resources.</li> </ul> <p>(A more detailed content policy may be developed later).</p>"},{"location":"REGISTRY_POLICY/#5-reporting-problematic-agents","title":"5. Reporting Problematic Agents","text":"<p>Users who encounter Agent Cards that appear to violate the Content Guidelines, are misleading, link to non-functional or malicious endpoints, or represent agents engaging in harmful activities are encouraged to report them.</p> <ul> <li> <p>How to Report: Please send a detailed report including the Agent Card ID (the UUID) and a description of the issue to:</p> <p><code>[AgentVault@proton.me]</code></p> </li> <li> <p>Review Process: Reports will be reviewed by the AgentVault maintainers based on this policy.</p> </li> </ul>"},{"location":"REGISTRY_POLICY/#6-enforcement","title":"6. Enforcement","text":"<p>AgentVault maintainers reserve the right, at their sole discretion, to:</p> <ul> <li>Deactivate (soft delete, making <code>is_active=False</code>) any Agent Card found to violate the Registry Policy or Content Guidelines.</li> <li>Temporarily or permanently suspend a developer's ability to submit or manage Agent Cards in response to repeated or severe violations.</li> <li>Remove Agent Cards linking to endpoints that are consistently unavailable or return errors indicative of non-compliance with the A2A protocol.</li> </ul>"},{"location":"REGISTRY_POLICY/#7-disclaimer","title":"7. Disclaimer","text":"<p>The AgentVault Registry is provided \"as is\". Users interact with third-party agents discovered through this registry at their own risk. The AgentVault project makes no warranties regarding the agents listed and is not liable for any damages or issues arising from interactions with those agents. Please review the agent provider's own Terms of Service and Privacy Policy before use.</p>"},{"location":"ROADMAP/","title":"AgentVault Project Roadmap","text":"<p>This document outlines the planned development phases and features for the AgentVault ecosystem. Our goal is to create a secure, interoperable, and easy-to-use platform for AI agent communication based on open standards like A2A and MCP concepts.</p> <p>Disclaimer: This roadmap represents our current plans and priorities. It is subject to change based on development progress, community feedback, and the evolution of underlying standards.</p>"},{"location":"ROADMAP/#current-status-april-2025-phase-25-underway","title":"Current Status (April 2025 - Phase 2.5 Underway)","text":"<p>The AgentVault project has established a functional baseline across its core components and is actively refining the ecosystem based on initial implementation and usability testing.</p> <ul> <li><code>agentvault</code> Library: Core client implemented (A2A JSON-RPC/SSE, Auth Schemes, KeyManager, Models, Utils). Published.</li> <li><code>agentvault_registry</code> API &amp; UI: Operational API (Card CRUD, Validation, Discovery Filters incl. TEE/Tags). New: Developer authentication via email/password (JWT), email verification, recovery keys, programmatic API key management (<code>/developers/me/apikeys</code>), Agent Builder endpoint (<code>/agent-builder/generate</code>). Web UI for public discovery (<code>/ui</code>) and developer portal (<code>/ui/developer</code>) with login/register/recovery flows implemented. Uses PostgreSQL/Alembic. Rate limiting/CORS active. (Note: Email sending depends on deployment configuration).</li> <li><code>agentvault_cli</code>: Functional CLI (<code>config</code>, <code>discover</code>, <code>run</code>). Supports KeyManager (keyring, oauth config), SSE streaming, artifact saving.</li> <li><code>agentvault_server_sdk</code>: Foundational SDK (<code>BaseA2AAgent</code>, FastAPI integration, <code>@a2a_method</code>, <code>InMemoryTaskStore</code> with notifications), packaging tool (<code>agentvault-sdk package</code>). Published.</li> <li><code>agentvault_testing_utils</code>: Shared utilities (<code>MockAgentVaultClient</code>, <code>mock_a2a_server</code> fixture, factory, <code>EchoAgent</code>, assertions).</li> <li>Examples: Basic Server, LangChain Tool, OAuth Agent, Stateful Agent, Library Usage examples available.</li> <li>Documentation: Structure established, core concepts/architecture/security documented, component guides drafted, A2A/TEE profiles documented, examples included. Deployed via GitHub Pages.</li> <li>CI/CD: Dependency audit and docs deployment workflows functional.</li> </ul>"},{"location":"ROADMAP/#next-steps-phase-26-automation-robustness-polish","title":"Next Steps: Phase 2.6 - Automation, Robustness &amp; Polish","text":"<p>Objective: Complete automation scripts, improve robustness (testing, error handling, scalability), and polish the developer/user experience.</p> <p>Key Tasks:</p> <ol> <li>Automation Scripts:<ul> <li>TODO: Finalize and test <code>automation_scripts/</code> (<code>av_create_package_agent</code>, <code>av_deploy_register_agent</code>, <code>av_find_run_task</code>). Ensure they work reliably with the latest components.</li> <li>TODO: Refine agent template generation (e.g., better <code>.env</code> setup based on selected options).</li> </ul> </li> <li>Testing &amp; Coverage:<ul> <li>TODO: Implement CI workflow for running <code>pytest</code> across all components.</li> <li>TODO: Integrate <code>pytest-cov</code> and add coverage reporting/thresholds to CI.</li> <li>TODO: Increase test coverage, focusing on complex logic (client state machine, registry auth flows, SDK router edge cases, CLI interactions).</li> <li>TODO: Add basic end-to-end tests (e.g., CLI -&gt; Registry -&gt; Mock Agent).</li> </ul> </li> <li>Registry Enhancements:<ul> <li>TODO: Investigate and potentially optimize developer programmatic API key lookup performance if needed for scale.</li> <li>TODO: Implement email-based password reset flow (currently placeholder).</li> <li>TODO: Further UI/UX improvements for the Developer Portal (e.g., easier card editing interface, clearer API key management).</li> </ul> </li> <li>SDK &amp; Error Handling:<ul> <li>TODO: Provide examples or interfaces for persistent <code>BaseTaskStore</code> implementations (e.g., Redis, SQL).</li> <li>TODO: Review and standardize error handling and logging across all components for consistency.</li> </ul> </li> <li>Documentation Polish:<ul> <li>TODO: Fill in remaining placeholders in policy documents (Contact emails).</li> <li>TODO: Add more diagrams where helpful (e.g., auth flows).</li> <li>TODO: Review all guides for clarity and accuracy against latest code.</li> </ul> </li> </ol>"},{"location":"ROADMAP/#future-considerations-phase-3-beyond","title":"Future Considerations (Phase 3 &amp; Beyond)","text":"<ul> <li>Multimodality (WebRTC): Integrate <code>aiortc</code> for optional real-time audio/video streaming.</li> <li>Deeper MCP Integration: Align with finalized MCP specifications, provide SDK helpers.</li> <li>TEE Attestation Verification: Implement client-side verification of TEE attestations.</li> <li>Registry Features: Community reviews/ratings, usage analytics (opt-in), advanced search, key rotation.</li> <li>Other Language SDKs/Libraries: Explore SDKs for Node.js, Go, etc.</li> <li>Security Audits: Formal third-party security reviews.</li> </ul>"},{"location":"ROADMAP/#contributing","title":"Contributing","text":"<p>We welcome community contributions! Please see our CONTRIBUTING.md for guidelines.</p>"},{"location":"TERMS_OF_SERVICE/","title":"AgentVault Registry API - Terms of Service","text":"<p>Last Updated: [April 12, 2025]</p> <p>PLEASE READ THESE TERMS OF SERVICE CAREFULLY. By accessing or using the AgentVault Registry API (the \"Service\"), provided by the AgentVault Project Maintainers (\"we\", \"us\", \"our\"), you (\"Developer\", \"you\") agree to be bound by these Terms of Service (\"Terms\"). If you do not agree to these Terms, do not use the Service.</p> <p>1. The Service</p> <p>The AgentVault Registry API is a service designed to facilitate the discovery of AI agents compatible with the AgentVault ecosystem. It allows registered developers to submit, manage, and publish metadata (\"Agent Cards\") describing their agents. The Service provides public endpoints for listing and retrieving these Agent Cards.</p> <p>The Service DOES NOT: *   Host or execute third-party AI agents. *   Store, handle, or process end-user API keys (e.g., OpenAI keys) used by agents. *   Monitor or proxy communication between users and agents. *   Endorse, certify, or guarantee the functionality, security, or behavior of any agent listed in the registry.</p> <p>2. Developer Accounts &amp; API Keys</p> <ul> <li>Access to submit or manage Agent Cards requires authentication using an API key provided by us.</li> <li>You are responsible for maintaining the confidentiality and security of your assigned API key. Do not share your key.</li> <li>You are responsible for all activities that occur under your API key. Notify us immediately of any unauthorized use.</li> <li>We reserve the right to revoke or suspend API keys if we suspect misuse or violation of these Terms.</li> </ul> <p>3. Agent Card Submissions &amp; Content</p> <ul> <li>By submitting an Agent Card to the Service, you represent and warrant that:<ul> <li>You own or have the necessary rights to the content included in the Agent Card.</li> <li>The information provided in the Agent Card is accurate, complete, and not misleading.</li> <li>The Agent Card content and the agent it describes comply with the AgentVault Registry Policy and all applicable laws and regulations.</li> <li>The Agent Card content does not infringe upon the intellectual property rights, privacy rights, or other rights of any third party.</li> </ul> </li> <li>You grant the AgentVault Project Maintainers a worldwide, non-exclusive, royalty-free license to host, display, reproduce, and distribute the submitted Agent Card metadata solely for the purpose of operating and promoting the AgentVault Registry and ecosystem.</li> <li>You are solely responsible for the agent service described in your Agent Card, including its operation, security, data handling, and compliance with its own terms and privacy policy.</li> </ul> <p>4. Prohibited Use</p> <p>You agree not to use the Service to:</p> <ul> <li>Submit Agent Cards that violate the AgentVault Registry Policy.</li> <li>Engage in any activity that is illegal, fraudulent, or harmful.</li> <li>Attempt to gain unauthorized access to the Service, other accounts, or related systems.</li> <li>Disrupt, interfere with, or place an unreasonable load on the Service or its infrastructure (e.g., excessive scraping, denial-of-service attacks).</li> <li>Misrepresent your identity or affiliation.</li> </ul> <p>5. Disclaimers</p> <ul> <li>THE SERVICE IS PROVIDED \"AS IS\" AND \"AS AVAILABLE\" WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.</li> <li>WE DO NOT WARRANT THAT THE SERVICE WILL BE UNINTERRUPTED, ERROR-FREE, OR SECURE.</li> <li>WE EXPLICITLY DISCLAIM ANY AND ALL LIABILITY AND RESPONSIBILITY FOR ANY THIRD-PARTY AGENTS DISCOVERED THROUGH THE SERVICE. YOUR INTERACTION WITH ANY AGENT LISTED IN THE REGISTRY IS SOLELY AT YOUR OWN RISK. WE DO NOT VET, ENDORSE, OR GUARANTEE ANY AGENT'S PERFORMANCE, SECURITY, DATA PRACTICES, OR COMPLIANCE. YOU ARE RESPONSIBLE FOR REVIEWING THE TERMS AND PRIVACY POLICY OF ANY AGENT BEFORE INTERACTING WITH IT.</li> </ul> <p>6. Intellectual Property</p> <ul> <li>The AgentVault name, logos, and the Service software are the property of the AgentVault Project Maintainers or its licensors and are protected by intellectual property laws.</li> <li>You retain ownership of the content within your submitted Agent Cards, subject to the license granted in Section 3.</li> </ul> <p>7. Termination</p> <ul> <li>We reserve the right to suspend or terminate your access to the Service (including revoking API keys and deactivating Agent Cards) at any time, with or without cause or notice, for conduct that we believe violates these Terms or is otherwise harmful to the Service or community.</li> <li>You may stop using the Service at any time.</li> </ul> <p>8. Limitation of Liability</p> <p>TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL THE AGENTVAULT PROJECT MAINTAINERS, THEIR AFFILIATES, OR THEIR LICENSORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, OR ANY LOSS OF PROFITS OR REVENUES, WHETHER INCURRED DIRECTLY OR INDIRECTLY, OR ANY LOSS OF DATA, USE, GOODWILL, OR OTHER INTANGIBLE LOSSES, RESULTING FROM (a) YOUR ACCESS TO OR USE OF OR INABILITY TO ACCESS OR USE THE SERVICE; (b) ANY CONDUCT OR CONTENT OF ANY THIRD PARTY ON THE SERVICE, INCLUDING THIRD-PARTY AGENTS DISCOVERED VIA THE SERVICE; OR (c) UNAUTHORIZED ACCESS, USE, OR ALTERATION OF YOUR TRANSMISSIONS OR CONTENT.</p> <p>9. Governing Law</p> <p>These Terms shall be governed by and construed in accordance with the laws of [Bavaria, Germany], without regard to its conflict of law principles.</p> <p>10. Changes to Terms</p> <p>We reserve the right to modify these Terms at any time. If we make changes, we will provide notice, such as by updating the \"Last Updated\" date at the top of these Terms. Your continued use of the Service after any modification constitutes your acceptance of the revised Terms.</p> <p>11. Contact Information</p> <p>For questions about these Terms of Service, please contact:</p> <p><code>[AgentVault@proton.me]</code></p>"},{"location":"a2a_profile_v0.2/","title":"AgentVault A2A Profile v0.2","text":"<p>This document specifies the Agent-to-Agent (A2A) communication profile implemented by AgentVault components (as of v0.2.x of the libraries/SDK). It defines how clients interact with A2A-compliant agent servers, aligning with concepts from emerging A2A standards like Google's A2A protocol.</p>"},{"location":"a2a_profile_v0.2/#overview","title":"Overview","text":"<ul> <li>Protocol: JSON-RPC 2.0 Specification.</li> <li>Transport: HTTP/1.1 or HTTP/2. HTTPS is REQUIRED for all communication except potentially during local development targeting <code>localhost</code>.</li> <li>Request Method: <code>POST</code> for all JSON-RPC requests.</li> <li>Streaming: Server-Sent Events (SSE) via the <code>tasks/sendSubscribe</code> method for real-time updates.</li> <li>Data Format: JSON (UTF-8 encoding).</li> <li>Authentication: Defined via <code>authSchemes</code> in the Agent Card. Supported schemes include <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials Grant). See Authentication section below.</li> <li>Models: Data structures (AgentCard, Task, Message, etc.) are defined using Pydantic in the <code>agentvault.models</code> module of the core library.</li> </ul>"},{"location":"a2a_profile_v0.2/#transport-details","title":"Transport Details","text":"<p>All JSON-RPC requests MUST be sent using the HTTP <code>POST</code> method to the agent's designated A2A endpoint URL (found in the <code>url</code> field of its Agent Card).</p> <ul> <li>Request Headers:<ul> <li><code>Content-Type: application/json</code> is REQUIRED.</li> <li><code>Accept: application/json</code> is RECOMMENDED.</li> <li>Authentication headers (e.g., <code>X-Api-Key</code> or <code>Authorization: Bearer &lt;token&gt;</code>) MUST be included if required by the agent's <code>authSchemes</code>.</li> </ul> </li> <li>Request Body: Contains the standard JSON-RPC 2.0 request object.</li> <li>Response Body (Non-Streaming): Contains the standard JSON-RPC 2.0 response object (either <code>result</code> or <code>error</code>). The HTTP status code SHOULD be <code>200 OK</code> even for JSON-RPC errors, as per JSON-RPC spec recommendations.</li> <li>Response Body (Streaming via <code>tasks/sendSubscribe</code>): The server responds with HTTP <code>200 OK</code> and <code>Content-Type: text/event-stream</code>. The body then contains a stream of Server-Sent Events (see SSE section).</li> </ul>"},{"location":"a2a_profile_v0.2/#authentication","title":"Authentication","text":"<p>Agents declare their supported authentication methods in the <code>authSchemes</code> list within their Agent Card. The <code>agentvault</code> client library (<code>AgentVaultClient</code> using <code>KeyManager</code>) handles these schemes automatically:</p> <ul> <li><code>none</code>: No authentication headers are sent. Suitable only for public, non-sensitive agents.</li> <li><code>apiKey</code>:<ul> <li>Client retrieves the API key associated with the <code>service_identifier</code> (from the Agent Card or user override) using <code>KeyManager</code>.</li> <li>Client sends the key in the <code>X-Api-Key</code> HTTP header.</li> <li>Server MUST validate the received key against its secure storage.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant Flow):<ul> <li>Requires the <code>AgentAuthentication</code> object in the card to include <code>tokenUrl</code>. <code>scopes</code> are optional.</li> <li>Client retrieves its own Client ID and Secret associated with the <code>service_identifier</code> using <code>KeyManager</code>.</li> <li>Client POSTs <code>grant_type=client_credentials</code>, <code>client_id</code>, <code>client_secret</code> (and optionally <code>scope</code>) to the agent's <code>tokenUrl</code>.</li> <li>Agent's token endpoint validates credentials and returns a JSON response with <code>access_token</code> (required), <code>token_type</code> (must be \"Bearer\", case-insensitive check), and optionally <code>expires_in</code>.</li> <li>Client sends the received <code>access_token</code> in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent A2A requests to the agent's main <code>url</code>.</li> <li>The <code>AgentVaultClient</code> automatically handles token fetching and caching (respecting <code>expires_in</code> if provided).</li> <li>Server's main A2A endpoint MUST validate the Bearer token (signature, expiry, audience, scopes if applicable).</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Client assumes the user/application has already obtained a valid Bearer token through other means.</li> <li>Client sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>The <code>agentvault</code> library currently requires explicit configuration or extension to handle this scheme, as it doesn't manage the token lifecycle.</li> <li>Server MUST validate the received Bearer token.</li> </ul> </li> </ul> <p>Refer to the main Security Considerations document for more details.</p>"},{"location":"a2a_profile_v0.2/#json-rpc-20-structure","title":"JSON-RPC 2.0 Structure","text":"<p>All requests and responses adhere to the JSON-RPC 2.0 specification.</p> <p>Request Object:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"method_name\",\n  \"params\": &lt;parameters_object_or_array&gt;,\n  \"id\": &lt;request_id_string_or_number_or_null&gt;\n}\n</code></pre> <ul> <li><code>jsonrpc</code>: MUST be exactly \"2.0\".</li> <li><code>method</code>: A string containing the name of the method (e.g., \"tasks/send\").</li> <li><code>params</code>: An optional structured value (object or array). AgentVault methods use parameter objects (dictionaries).</li> <li><code>id</code>: An identifier established by the Client. If included, the response MUST include the same value. If omitted (notification), the server MUST NOT reply. AgentVault methods generally expect an ID.</li> </ul> <p>Response Object (Success):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": &lt;result_value&gt;,\n  \"id\": &lt;matching_request_id&gt;\n}\n</code></pre> <ul> <li><code>result</code>: The value returned by the method invocation. Its structure depends on the method called (see method definitions below).</li> <li><code>id</code>: Must match the <code>id</code> from the Request Object.</li> </ul> <p>Response Object (Error):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": &lt;integer&gt;,\n    \"message\": &lt;string&gt;,\n    \"data\": &lt;optional_any&gt;\n  },\n  \"id\": &lt;matching_request_id_or_null&gt;\n}\n</code></pre> <ul> <li><code>error</code>: An object describing the error.<ul> <li><code>code</code>: A Number indicating the error type. See Error Codes.</li> <li><code>message</code>: A String providing a short description of the error.</li> <li><code>data</code>: Optional. A Primitive or Structured value containing additional information.</li> </ul> </li> <li><code>id</code>: Must match the <code>id</code> from the Request Object. If the error occurred before the ID could be determined (e.g., Parse Error), it SHOULD be <code>null</code>.</li> </ul>"},{"location":"a2a_profile_v0.2/#standard-a2a-methods","title":"Standard A2A Methods","text":"<p>These methods form the core of the AgentVault A2A interaction model, implemented by the <code>agentvault</code> client library and expected by servers built with the <code>agentvault-server-sdk</code>.</p>"},{"location":"a2a_profile_v0.2/#taskssend","title":"<code>tasks/send</code>","text":"<p>Initiates a new task or sends a subsequent message to an existing task.</p> <ul> <li>Params: <code>TaskSendParams</code> object (<code>agentvault.models.TaskSendParams</code>)<ul> <li><code>id</code> (Optional[str]): Task ID if continuing an existing task. Omit or null if initiating a new task.</li> <li><code>message</code> (Message): The message object (<code>agentvault.models.Message</code>) to send.</li> <li>(Optional) <code>webhookUrl</code> (Optional[str]): URL for agent push notifications (if agent supports <code>supportsPushNotifications</code>). Client is responsible for handling POST requests to this URL from the agent. (Note: Push notification handling is not fully implemented in client/SDK v0.2).</li> </ul> </li> <li>Result: <code>TaskSendResult</code> object (<code>agentvault.models.TaskSendResult</code>)<ul> <li><code>id</code> (str): The ID of the task (newly created or existing).</li> </ul> </li> <li>Example Request (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}],\n      \"metadata\": {\n        \"mcp_context\": { \"user_pref\": \"celsius\" }\n      }\n    }\n    {# Example including optional webhook: #}\n    {# \"webhookUrl\": \"https://my-client.example.com/webhook/task-updates\" #}\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Response (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Request (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-abc-123\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What about tomorrow?\"}]\n    }\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> <li>Example Response (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#tasksget","title":"<code>tasks/get</code>","text":"<p>Retrieve the current status and details of a specific task.</p> <ul> <li>Params: <code>TaskGetParams</code> object (<code>agentvault.models.TaskGetParams</code>)<ul> <li><code>id</code> (str): The ID of the task to retrieve.</li> </ul> </li> <li>Result: <code>Task</code> object (<code>agentvault.models.Task</code>) representing the full task state.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/get\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\",\n    \"state\": \"WORKING\",\n    \"createdAt\": \"2024-04-15T10:00:00Z\",\n    \"updatedAt\": \"2024-04-15T10:05:30Z\",\n    \"messages\": [\n      {\"role\": \"user\", \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}], \"metadata\": null},\n      {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Fetching weather...\"}], \"metadata\": null}\n    ],\n    \"artifacts\": [\n      {\"id\": \"artifact-1\", \"type\": \"log\", \"content\": \"API call made\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}\n    ],\n    \"metadata\": null\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskscancel","title":"<code>tasks/cancel</code>","text":"<p>Request the cancellation of an ongoing task.</p> <ul> <li>Params: <code>TaskCancelParams</code> object (<code>agentvault.models.TaskCancelParams</code>)<ul> <li><code>id</code> (str): The ID of the task to cancel.</li> </ul> </li> <li>Result: <code>TaskCancelResult</code> object (<code>agentvault.models.TaskCancelResult</code>)<ul> <li><code>success</code> (bool): Indicates if the cancellation request was accepted by the agent (doesn't guarantee immediate cancellation).</li> <li><code>message</code> (Optional[str]): Optional message from the agent regarding the cancellation request.</li> </ul> </li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/cancel\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"success\": true,\n    \"message\": \"Cancellation request received.\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskssendsubscribe","title":"<code>tasks/sendSubscribe</code>","text":"<p>Initiates a subscription to real-time updates for a task via Server-Sent Events (SSE).</p> <ul> <li>Params: Object containing the task ID.<ul> <li><code>id</code> (str): The ID of the task to subscribe to.</li> </ul> </li> <li>Response: HTTP <code>200 OK</code> with <code>Content-Type: text/event-stream</code>. The HTTP response body contains the SSE stream. No JSON-RPC <code>result</code> field is sent in the initial HTTP response body.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-5\"\n}\n</code></pre></li> <li>Example Response (HTTP Headers &amp; Body Start): <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\n... (more events) ...\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#task-states-taskstate-enum","title":"Task States (<code>TaskState</code> Enum)","text":"<p>The defined states for an A2A task lifecycle (<code>agentvault.models.TaskState</code>):</p> <ul> <li><code>SUBMITTED</code>: Task received, awaiting execution.</li> <li><code>WORKING</code>: Task actively being processed.</li> <li><code>INPUT_REQUIRED</code>: Task paused, awaiting further client input (advanced use case).</li> <li><code>COMPLETED</code>: Task finished successfully. (Terminal)</li> <li><code>FAILED</code>: Task terminated due to an error. (Terminal)</li> <li><code>CANCELED</code>: Task canceled by request. (Terminal)</li> </ul>"},{"location":"a2a_profile_v0.2/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Used for the <code>tasks/sendSubscribe</code> stream.</p> <ul> <li>Format: Standard SSE. Each event consists of <code>event:</code> and <code>data:</code> lines, terminated by <code>\\n\\n</code>. The <code>data:</code> field contains a single line JSON string.     <pre><code>event: &lt;event_type&gt;\ndata: &lt;json_payload_string&gt;\n\nevent: &lt;another_event_type&gt;\ndata: &lt;another_json_payload_string&gt;\n</code></pre></li> <li>Event Types (<code>event:</code> field):<ul> <li><code>task_status</code>: Task state change. <code>data</code> is JSON of <code>TaskStatusUpdateEvent</code>.</li> <li><code>task_message</code>: New message added. <code>data</code> is JSON of <code>TaskMessageEvent</code>.</li> <li><code>task_artifact</code>: Artifact created/updated. <code>data</code> is JSON of <code>TaskArtifactUpdateEvent</code>.</li> <li><code>error</code>: Server-side error during streaming. <code>data</code> is a JSON object like <code>{\"error\": \"code\", \"message\": \"desc\"}</code>.</li> </ul> </li> <li>Data Payload (<code>data:</code> field): A JSON string representing the corresponding event model (<code>agentvault.models.TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>). The client library validates these payloads against the Pydantic models.</li> </ul> <p>Example SSE Stream:</p> <pre><code>event: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\nevent: task_artifact\ndata: {\"taskId\": \"task-abc-123\", \"artifact\": {\"id\": \"log-1\", \"type\": \"debug_log\", \"content\": \"Processing step 1\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:10Z\"}\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"COMPLETED\", \"timestamp\": \"2024-04-15T10:05:15Z\", \"message\": \"Task finished successfully.\"}\n</code></pre>"},{"location":"a2a_profile_v0.2/#json-rpc-error-codes","title":"JSON-RPC Error Codes","text":"<p>Standard JSON-RPC codes MUST be used where applicable. AgentVault defines application-specific codes in the <code>-32000</code> to <code>-32099</code> range for agent-level errors.</p> Code Message Meaning Standard/App -32700 Parse error Invalid JSON received by the server. Standard -32600 Invalid Request The JSON sent is not a valid Request object. Standard -32601 Method not found The method does not exist / is not available. Standard -32602 Invalid Params Invalid method parameter(s). Standard -32603 Internal error Internal JSON-RPC error on the server. Standard -32000 Agent Server Error Generic application error on the agent. Application -32001 Task Not Found Specified <code>task_id</code> does not exist. Application -32002 Authentication Error API Key / Token invalid or missing. Application -32003 Authorization Error Authenticated user cannot perform action. Application -32004 Invalid State Operation not allowed in current task state. Application others Implementation Defined Server may define other -320xx errors. Application <p>Servers SHOULD include meaningful information in the <code>message</code> and optionally the <code>data</code> part of the error object. The client library (<code>A2ARemoteAgentError</code>) makes this information accessible.</p>"},{"location":"architecture/","title":"AgentVault Architecture","text":"<p>This document provides a high-level overview of the AgentVault ecosystem architecture, illustrating how the different components interact to enable secure agent discovery and communication.</p>"},{"location":"architecture/#vision","title":"Vision","text":"<p>AgentVault aims to be the open-source backbone for a thriving multi-agent ecosystem. It provides the standards, tools, and infrastructure necessary for agents built by anyone, anywhere, to find each other and collaborate effectively and securely.</p>"},{"location":"architecture/#component-overview","title":"Component Overview","text":"<p>The ecosystem consists of several distinct but interconnected Python packages and services:</p> <ol> <li><code>agentvault_library</code> (Core Client Library): The foundation for client-side interactions. Contains the <code>AgentVaultClient</code> (handles A2A protocol logic), <code>KeyManager</code> (secure credential storage), Pydantic models (AgentCard, A2A messages), and utility functions (card parsing, MCP handling). Used by the CLI and any custom application wanting to interact with agents.</li> <li><code>agentvault_cli</code> (Command Line Interface): The primary tool for end-users and developers to interact with the system from the terminal. Uses the <code>agentvault_library</code> to perform actions like configuring keys, discovering agents via the registry, and running tasks on agents.</li> <li><code>agentvault_registry</code> (Registry API &amp; UI): A central FastAPI web service acting as the discovery hub. It stores Agent Card metadata submitted by developers in a PostgreSQL database. It provides a public REST API (<code>/api/v1</code>) for searching/retrieving cards and an authenticated API for developers to manage their listings. It also serves a basic Web UI for public discovery (<code>/ui</code>) and developer management (<code>/ui/developer</code>).</li> <li><code>agentvault_server_sdk</code> (Server SDK): A toolkit for developers building A2A-compliant agents. Provides base classes (<code>BaseA2AAgent</code>), FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code>), task state management abstractions, and packaging utilities (<code>agentvault-sdk package</code>) to simplify agent development and deployment.</li> <li><code>agentvault_testing_utils</code> (Testing Utilities): A shared internal package containing mocks, pytest fixtures, factories, and assertion helpers used across the test suites of the other components to ensure consistency and reduce boilerplate. Not intended for direct use by end-users.</li> </ol>"},{"location":"architecture/#interaction-flow-diagram","title":"Interaction Flow Diagram","text":"<pre><code>graph LR\n    subgraph User/Client Side\n        User[User / Client App] --&gt;|Uses| CLI(agentvault_cli)\n        CLI --&gt;|Uses| Lib(agentvault_library)\n        User --&gt;|Uses| Lib\n        Lib --&gt;|Manages Keys via KeyManager| KeyStore[Local Credential Store Env/File/Keyring]\n    end\n\n    subgraph Developer Side\n        Dev[Agent Developer] --&gt;|Uses| SDK(agentvault_server_sdk)\n        SDK --&gt;|Builds Agent + Card| AgentServer(A2A Agent Server FastAPI)\n        Dev --&gt;|Creates/Manages Registry Key| DevKeyStore[Developer API Key Stored by Dev]\n        Dev --&gt;|Submits Card via API Uses DevKeyStore| RegistryAPI(Registry API /api/v1)\n    end\n\n    subgraph Central Service\n        RegistryAPI --&gt;|Reads/Writes Hashes| DB[Registry DB Cards Hashed Keys]\n        RegistryAPI --&gt;|Serves UI| RegistryUI(Registry Web UI /ui)\n        User --&gt;|Browses| RegistryUI\n    end\n\n    subgraph Communication Paths\n        Lib --&gt;|Discover Agent Public API| RegistryAPI\n        Lib --&gt;|Get Agent Card Public API| RegistryAPI\n        Lib --&gt;|Run Task A2A Protocol| AgentServer\n        AgentServer --&gt;|Optional: Uses Lib/SDK| ExternalService[External APIs / Services]\n    end\n\n    style Dev fill:#ff99ff,stroke:#333333,stroke-width:2px\n    style User fill:#ccccff,stroke:#333333,stroke-width:2px\n    style KeyStore stroke-dasharray: 5 5\n    style DevKeyStore stroke-dasharray: 5 5</code></pre> <p>Explanation of Flows:</p> <ol> <li>Discovery: A user or client application (using the Library or CLI) queries the Registry API's public endpoints (<code>/api/v1/...</code>) or browses the public Web UI (<code>/ui</code>) to find agents based on criteria.</li> <li>Card Retrieval: The client retrieves the specific Agent Card for the desired agent from the Registry API (public endpoint).</li> <li>Interaction (Client -&gt; Agent):<ul> <li>The client application uses the information in the retrieved Agent Card (endpoint <code>url</code>, <code>authSchemes</code>).</li> <li>The <code>agentvault_library</code>'s <code>KeyManager</code> component attempts to load the necessary local credentials.</li> <li>The <code>AgentVaultClient</code> constructs and sends A2A protocol requests directly to the target Agent Server's endpoint, automatically adding required authentication headers.</li> <li>The Agent Server receives the request, authenticates it, processes the task, and sends back responses/events.</li> </ul> </li> <li>Registration (Developer -&gt; Registry):<ul> <li>The Agent Developer uses their unique Developer API Key with the authenticated endpoints of the Registry API (<code>/api/v1/...</code>) or potentially the Developer Portal UI (<code>/ui/developer</code>) to submit or manage their Agent Cards.</li> <li>The Registry API verifies the key against stored hashes.</li> </ul> </li> </ol>"},{"location":"architecture/#key-architectural-principles","title":"Key Architectural Principles","text":"<ul> <li>Decentralized Execution: Agents run independently. The Registry is only for discovery metadata.</li> <li>Standardized Interface: Communication relies on the defined AgentVault A2A Profile v0.2 and the <code>AgentCard</code> schema.</li> <li>Component-Based: Logical components (library, CLI, registry, SDK, testing utils) with distinct responsibilities.</li> <li>Security Focus: Secure credential management, hashed keys, HTTPS enforcement, TEE awareness.</li> <li>Developer Experience: SDK and CLI tools simplify common tasks.</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This page defines the key concepts and terminology used throughout the AgentVault ecosystem. Understanding these concepts is crucial for effectively using the tools and contributing to the project.</p>"},{"location":"concepts/#agent-card","title":"Agent Card","text":"<ul> <li>Definition: A standardized JSON document (typically named <code>agent-card.json</code>) containing metadata that describes an A2A-compliant agent. It's the agent's \"business card\" for the digital world.</li> <li>Purpose: Enables discovery via the AgentVault Registry and provides essential information for clients (other agents or applications) to connect, authenticate, and interact with the agent.</li> <li>Schema: The structure and required fields are defined by the <code>agentvault.models.AgentCard</code> Pydantic model, aligning with emerging A2A standards. See the A2A Profile v0.2 for protocol details derived from the card.</li> <li>Key Fields: Includes the agent's unique <code>humanReadableId</code>, display <code>name</code>, <code>description</code>, the A2A endpoint <code>url</code>, technical <code>capabilities</code> (like supported protocol versions, TEE usage), required <code>authSchemes</code>, and details about the <code>provider</code>.</li> </ul>"},{"location":"concepts/#agent-to-agent-a2a-protocol","title":"Agent-to-Agent (A2A) Protocol","text":"<ul> <li>Definition: The standardized communication protocol enabling direct interaction between AgentVault clients and A2A-compliant agent servers. It defines the methods, message formats, and interaction patterns.</li> <li>Based On: Inspired by and aligned with concepts from the Google A2A Protocol specification, utilizing JSON-RPC 2.0 over HTTP POST for requests and Server-Sent Events (SSE) over HTTP for asynchronous streaming updates.</li> <li>Key Methods: Defines standard operations like initiating tasks (<code>tasks/send</code>), retrieving task status (<code>tasks/get</code>), requesting cancellation (<code>tasks/cancel</code>), and subscribing to real-time updates (<code>tasks/sendSubscribe</code>).</li> <li>Profile: The specific implementation details, method signatures, payload structures, and state transitions used within AgentVault are documented in the AgentVault A2A Profile v0.2.</li> </ul>"},{"location":"concepts/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Definition: (Conceptual / Future Work) A protocol intended for exchanging richer, structured contextual information between agents beyond simple text prompts.</li> <li>Status: Currently conceptual within AgentVault. Basic embedding in message metadata is supported. A formal specification is planned.</li> <li>Goal: Enable more sophisticated, context-aware collaboration.</li> </ul>"},{"location":"concepts/#agentvault-registry","title":"AgentVault Registry","text":"<ul> <li>Definition: A central API service (<code>agentvault_registry</code>) and web UI acting as the discovery hub. Developers register agents by submitting Agent Cards. Clients query the registry to find agents.</li> <li>Component: <code>agentvault_registry</code></li> <li>Features: Public REST API for discovery (list, search, get). Authenticated REST API and Developer Portal UI (<code>/ui/developer</code>) for developers to manage cards (submit, update, deactivate) and programmatic API keys. Includes Agent Card validation, developer account management (email/password login, JWT sessions, recovery keys), and a public discovery UI (<code>/ui</code>). See the Registry API Guide.</li> </ul>"},{"location":"concepts/#agentvault-library-client","title":"AgentVault Library (Client)","text":"<ul> <li>Definition: The core Python library (<code>agentvault</code>) providing client-side tools.</li> <li>Component: <code>agentvault_library</code></li> <li>Features: <code>AgentVaultClient</code> (A2A calls, SSE, auth handling), <code>KeyManager</code> (secure local credential storage), Agent Card utilities, MCP helpers, Pydantic models. See the Library Guide.</li> </ul>"},{"location":"concepts/#agentvault-server-sdk","title":"AgentVault Server SDK","text":"<ul> <li>Definition: Python SDK (<code>agentvault-server-sdk</code>) to accelerate building A2A-compliant agent servers.</li> <li>Component: <code>agentvault_server_sdk</code></li> <li>Features: <code>BaseA2AAgent</code> class, FastAPI integration (<code>create_a2a_router</code>, <code>@a2a_method</code>), task state abstractions, packaging tool (<code>agentvault-sdk package</code>). See the Server SDK Guide.</li> </ul>"},{"location":"concepts/#agentvault-cli","title":"AgentVault CLI","text":"<ul> <li>Definition: Command-line interface (<code>agentvault-cli</code>) for users/developers.</li> <li>Component: <code>agentvault_cli</code></li> <li>Features: Manage local credentials (<code>config</code>), discover agents (<code>discover</code>), execute tasks (<code>run</code>). See the CLI User Guide.</li> </ul>"},{"location":"concepts/#keymanager","title":"KeyManager","text":"<ul> <li>Definition: Component in <code>agentvault_library</code> for secure local credential management (API keys, OAuth Client ID/Secrets).</li> <li>Component: Part of <code>agentvault_library</code> (<code>key_manager.py</code>)</li> <li>Sources: Loads from file (<code>.env</code> or <code>.json</code>), environment variables, or OS Keyring (recommended).</li> <li>Lookup: Uses a Service Identifier to find the correct credential set.</li> </ul>"},{"location":"concepts/#service-identifier","title":"Service Identifier","text":"<ul> <li>Definition: A string used by <code>KeyManager</code> to look up local credentials. Acts as a local alias.</li> <li>Source: Defined in <code>AgentCard</code> (<code>authSchemes[].service_identifier</code>) or specified by the user/client (e.g., <code>agentvault_cli run --key-service &lt;your_local_id&gt;</code>).</li> <li>Purpose: Allows reusing a single local credential (e.g., \"openai\" key) for multiple agents requiring the same authentication.</li> </ul>"},{"location":"concepts/#trusted-execution-environment-tee","title":"Trusted Execution Environment (TEE)","text":"<ul> <li>Definition: Secure, isolated hardware environment (e.g., Intel SGX, AWS Nitro Enclaves).</li> <li>Relevance: Agents can declare TEE usage in their Agent Card (<code>capabilities.teeDetails</code>). Registry allows filtering by TEE support.</li> <li>Current Scope: Declarative only. Automated attestation verification is future work. See the TEE Profile.</li> </ul>"},{"location":"concepts/#developer-authentication-registry","title":"Developer Authentication (Registry)","text":"<ul> <li>Login: Developers authenticate to the registry API and Developer Portal UI using email and password, receiving a JWT session token.</li> <li>Programmatic Access: Developers can generate separate, long-lived API Keys (prefixed <code>avreg_</code>) via the Developer Portal for use in scripts or CI/CD to manage their agent cards. These are sent via the <code>X-Api-Key</code> header.</li> <li>Recovery: Account access can be recovered using Recovery Keys generated during registration if the password is lost.</li> </ul>"},{"location":"examples/","title":"AgentVault Examples","text":"<p>This section provides practical examples demonstrating how to use the various components of the AgentVault ecosystem.</p> <p>These examples are designed to help you get started quickly, whether you are building an A2A-compliant agent, using the client library to interact with agents, or utilizing the command-line interface.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>The source code for these examples can be found in the <code>/examples/</code> directory of the AgentVault GitHub repository.</p> <ul> <li> <p>Basic A2A Server: (View Code)</p> <ul> <li>Focus: Demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</li> <li>Features: Implements a simple \"EchoAgent\", uses the SDK's router integration (<code>create_a2a_router</code>), includes a basic <code>agent-card.json</code>, and shows how to run the server with Uvicorn.</li> <li>Good for: Developers starting to build their first A2A agent.</li> </ul> </li> <li> <p>LangChain Integration: (View Code)</p> <ul> <li>Focus: Shows how to wrap an AgentVault A2A agent as a custom <code>Tool</code> within the LangChain framework.</li> <li>Features: Defines an <code>A2AAgentTool</code> class that uses the <code>agentvault</code> client library internally to communicate with a remote agent based on an agent reference (ID, URL, or file path). Includes example usage.</li> <li>Good for: Developers wanting to integrate existing or new A2A agents into LangChain applications and agentic workflows.</li> </ul> </li> <li> <p>OAuth Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates implementing the <code>oauth2</code> (Client Credentials) authentication scheme using the Server SDK and FastAPI.</li> <li>Features: Includes a custom <code>/token</code> endpoint, uses environment variables for mock credentials, and protects the <code>/a2a</code> endpoint using a FastAPI dependency.</li> <li>Good for: Developers needing to implement OAuth2 authentication for their agents.</li> </ul> </li> <li> <p>Stateful Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates managing task state (like chat history) across multiple client interactions within a single task ID using the Server SDK.</li> <li>Features: Uses a custom <code>TaskContext</code> subclass, <code>InMemoryTaskStore</code>, and <code>asyncio.Event</code> to handle multi-turn interactions and background processing.</li> <li>Good for: Developers building conversational agents or agents that require maintaining context over several requests.</li> </ul> </li> <li> <p>Direct Library Usage: (View Code)</p> <ul> <li>Focus: Shows how to use the <code>agentvault</code> client library directly in a Python script to interact with an agent.</li> <li>Features: Demonstrates loading agent cards, using <code>KeyManager</code>, calling <code>AgentVaultClient</code> methods (<code>initiate_task</code>, <code>receive_messages</code>), and handling events and errors.</li> <li>Good for: Developers integrating AgentVault client functionality into custom applications or scripts.</li> </ul> </li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Please refer to the <code>README.md</code> file within each specific example directory (linked via \"[View Code]\" above) for detailed setup and execution instructions. Generally, you will need to:</p> <ol> <li>Ensure you have the main development environment set up (see Installation Guide).</li> <li>Navigate to the specific example directory (e.g., <code>cd examples/basic_a2a_server</code>).</li> <li>Install any example-specific requirements (usually via <code>pip install -r requirements.txt</code>).</li> <li>Follow the instructions in the example's <code>README.md</code> to run the server or script.</li> </ol> <p>We encourage you to explore these examples and adapt them for your own use cases!</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide covers how to install the different parts of the AgentVault ecosystem, depending on your needs.</p>"},{"location":"installation/#1-installing-for-usage-cli-client-library","title":"1. Installing for Usage (CLI &amp; Client Library)","text":"<p>If you want to use the AgentVault CLI to interact with agents or use the <code>agentvault</code> client library in your own Python projects, install directly from PyPI.</p> <p>Prerequisites:</p> <ul> <li>Python 3.10 or 3.11 installed.</li> <li><code>pip</code> (Python's package installer).</li> </ul> <p>Installation Options:</p> <ul> <li> <p>CLI Only: <pre><code>pip install agentvault-cli\n</code></pre> To include optional OS Keyring support for secure credential storage: <pre><code>pip install \"agentvault-cli[os_keyring]\"\n</code></pre></p> </li> <li> <p>Client Library Only (<code>agentvault</code>): <pre><code>pip install agentvault\n</code></pre> To include optional OS Keyring support: <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre></p> </li> <li> <p>Server SDK Only (<code>agentvault-server-sdk</code>): (Note: This also installs the <code>agentvault</code> client library as a dependency) <pre><code>pip install agentvault-server-sdk\n</code></pre></p> </li> </ul> <p>Verification (CLI):</p> <p>After installing the CLI, check that the command is available:</p> <p><code>bash agentvault_cli --version</code></p> <p>Connecting to the Public Registry:</p> <p>You can use the installed CLI or library with the publicly hosted registry:</p> <ul> <li>URL: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Usage:<ul> <li>Set the environment variable: <code>export AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code> (Linux/macOS) or <code>set AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code> (Windows Cmd) or <code>$env:AGENTVAULT_REGISTRY_URL='https://agentvault-registry-api.onrender.com'</code> (PowerShell).</li> <li>Or use the <code>--registry</code> flag with CLI commands: <code>agentvault_cli discover --registry https://agentvault-registry-api.onrender.com</code></li> </ul> </li> <li>Note (Cold Start): This instance runs on Render's free tier. If it hasn't received traffic recently, it might take up to 60 seconds to respond to the first request while it \"wakes up\". Subsequent requests will be faster. You can send a simple request like <code>curl https://agentvault-registry-api.onrender.com/health</code> to wake it up before running commands if needed.</li> <li>Developer Registration: You can register for a developer account on the public registry via the UI at <code>https://agentvault-registry-api.onrender.com/ui/register</code>. Follow the email verification steps.</li> </ul>"},{"location":"installation/#2-setting-up-for-development-contributing-or-running-from-source","title":"2. Setting up for Development (Contributing or Running from Source)","text":"<p>If you want to contribute to AgentVault, run components locally from the source code (like the registry), or use features not yet released on PyPI, follow these steps. This sets up the entire monorepo.</p> <p>Prerequisites:</p> <ul> <li>Git</li> <li>Python 3.10 or 3.11</li> <li>Poetry (Python dependency management and packaging tool)</li> <li>PostgreSQL Server (Required only if running the <code>agentvault_registry</code> locally).</li> <li>(Optional) SMTP Server/Service: Required only if running the <code>agentvault_registry</code> locally and you want email verification/password reset emails to be sent. Configure credentials in the registry's <code>.env</code> file.</li> </ul> <p>Steps:</p> <ol> <li> <p>Clone the Repository: <code>bash     git clone https://github.com/SecureAgentTools/AgentVault.git     cd AgentVault</code></p> </li> <li> <p>Install Dependencies (including Development Tools): Navigate to the project root (<code>AgentVault/</code>) and use Poetry to install all dependencies for all workspace packages:     ```bash     # Installs production AND development dependencies (pytest, httpx, mkdocs, etc.)     poetry install --with dev</p> </li> <li> <p>Activate Virtual Environment: Before running any commands or tests from source, activate the environment created by Poetry:</p> <ul> <li>Linux/macOS (bash/zsh): <code>bash     source .venv/bin/activate</code></li> <li>Windows (PowerShell): <code>powershell     .\\.venv\\Scripts\\Activate.ps1</code></li> <li>Windows (Command Prompt): <code>cmd     .\\.venv\\Scripts\\activate.bat</code> You should see <code>(.venv)</code> appear at the beginning of your command prompt line.</li> </ul> </li> <li> <p>Verify Installation: You can now run commands from different components, e.g.:     <code>bash     # Check CLI version (running from source)     agentvault_cli --version     # Run library tests     pytest agentvault_library/tests/     # Check docs tool     mkdocs --version</code></p> </li> </ol>"},{"location":"installation/#to-include-optional-os-keyring-support-for-development","title":"To include optional OS Keyring support for development:","text":""},{"location":"installation/#poetry-install-with-dev-extras-os_keyring","title":"poetry install --with dev --extras os_keyring","text":"<p><code>`` *   This command reads the</code>pyproject.toml<code>files in each component directory (</code>agentvault_library<code>,</code>agentvault_cli<code>, etc.). *   It resolves all dependencies across the workspace. *   It installs everything into a single virtual environment located in the project root (usually</code>.venv/`).</p>"},{"location":"installation/#3-running-the-registry-local-development","title":"3. Running the Registry (Local Development)","text":"<p>To run the <code>agentvault_registry</code> API locally (e.g., for testing agents or the CLI against it):</p> <ol> <li>Complete Development Setup: Follow the steps in section 2 above. Ensure you have a running PostgreSQL server accessible.</li> <li>Navigate: <code>bash     cd agentvault_registry</code></li> <li>Configure Database, Secrets &amp; Email:<ul> <li>Copy <code>.env.example</code> to <code>.env</code> (if it exists) or create a <code>.env</code> file in the <code>agentvault_registry/</code> directory.</li> <li>Set the <code>DATABASE_URL</code> environment variable in the <code>.env</code> file to point to your local PostgreSQL instance (ensure it uses the <code>asyncpg</code> driver, e.g., <code>postgresql+asyncpg://user:pass@host:port/dbname</code>).</li> <li>Set the <code>API_KEY_SECRET</code> environment variable in the <code>.env</code> file (generate a strong secret, e.g., <code>openssl rand -hex 32</code>). This is used for signing JWTs.</li> <li>(Optional) Configure Email Settings: If you want email verification and password reset to work, configure the <code>MAIL_...</code> variables in your <code>.env</code> file (e.g., <code>MAIL_USERNAME</code>, <code>MAIL_PASSWORD</code>, <code>MAIL_SERVER</code>, <code>MAIL_PORT</code>, <code>MAIL_FROM</code>). If these are not set, registration will still work, but verification/reset emails will not be sent. You can use a local SMTP debugging server (like <code>python -m smtpd -c DebuggingServer -n localhost:1025</code>) and configure the <code>.env</code> accordingly for testing email content without actually sending.</li> </ul> </li> <li>Database Setup:<ul> <li>Ensure your PostgreSQL server is running and the specified database exists.</li> <li>Run database migrations using Alembic (make sure your virtual environment is activated):     <code>bash     # Run from the agentvault_registry/ directory     alembic upgrade head</code></li> </ul> </li> <li>Run the Server: Use Uvicorn (which was installed as part of development dependencies):     <code>bash     # Run from the agentvault_registry/ directory     uvicorn agentvault_registry.main:app --reload --host 0.0.0.0 --port 8000</code><ul> <li><code>--reload</code>: Automatically restarts the server when code changes.</li> <li><code>--host 0.0.0.0</code>: Makes the server accessible from other devices on your network (use <code>127.0.0.1</code> for localhost only).</li> <li><code>--port 8000</code>: The default port.</li> </ul> </li> </ol> <p>The registry API should now be running at <code>http://localhost:8000</code>. You can access the API docs at <code>http://localhost:8000/docs</code> and the Developer Portal UI at <code>http://localhost:8000/ui/developer</code>. You can register a local developer account via <code>http://localhost:8000/ui/register</code>.</p>"},{"location":"privacy_policy/","title":"AgentVault Registry API - Privacy Policy","text":"<p>Last Updated: [April 12, 2025]</p> <p>This Privacy Policy describes how the AgentVault Project Maintainers (\"we\", \"us\", \"our\") collect, use, and handle information in connection with your use of the AgentVault Registry API (the \"Service\").</p> <p>1. Data Controller</p> <p>The data controller for the information processed via the Service is The AgentVault Project Maintainers. You can contact us regarding privacy matters at:</p> <p><code>[AgentVault@proton.me]</code></p> <p>2. Information We Collect</p> <p>We collect the following types of information:</p> <ul> <li> <p>Information Provided by Developers:</p> <ul> <li>Developer Name: When a developer account is created or associated with an API key (process TBD).</li> <li>Hashed API Key: We store a cryptographically hashed version of the API key assigned to developers for authentication purposes. We never store the plain-text API key after initial generation and verification.</li> <li>Agent Card Metadata: The full JSON content of Agent Cards submitted by developers, which may include agent names, descriptions, endpoint URLs, provider details, etc., as defined by the A2A Agent Card schema.</li> <li>(Optional - If Implemented Later): Developer Email Address: If we implement features requiring direct communication (e.g., account recovery, important service notifications), we may collect developer email addresses. This will be clearly indicated at the time of collection.</li> </ul> </li> <li> <p>Information Collected Automatically:</p> <ul> <li>Log Data: Like most web services, our servers automatically record information (\"Log Data\") created by your use of the Service. Log Data may include information such as your IP address, browser type, operating system, the referring web page, pages visited, location (if enabled by your browser), device information, search terms (for the registry search endpoint), and cookie information (if applicable, though the API itself likely doesn't use persistent cookies). We use Log Data for security monitoring, service operation, debugging, and aggregated analytics.</li> </ul> </li> </ul> <p>3. How We Use Information</p> <p>We use the information we collect for the following purposes:</p> <ul> <li>To Provide and Maintain the Service: To operate the registry, allow agent discovery, authenticate developers, store and serve Agent Cards.</li> <li>To Improve the Service: To analyze usage patterns (using aggregated/anonymized data where possible) to understand how the Service is used and identify areas for improvement.</li> <li>To Ensure Security: To monitor for and prevent fraudulent activity, abuse, and security incidents. To verify developer identities via API keys.</li> <li>To Communicate (If Applicable): If we collect email addresses, we may use them to communicate important service updates, security notices, or respond to support requests or reports. We will provide opt-out mechanisms for non-essential communications.</li> <li>To Comply with Law: To comply with applicable legal obligations, regulations, or valid legal processes.</li> </ul> <p>4. Data Sharing and Disclosure</p> <ul> <li>Public Agent Card Data: The Agent Card metadata submitted by developers (excluding potentially sensitive internal details not part of the standard schema display) is intended to be publicly accessible via the API for discovery purposes.</li> <li>Service Providers: We may engage third-party companies or individuals as service providers (e.g., hosting providers, database providers) to process information on our behalf based on our instructions and in compliance with this Privacy Policy and appropriate confidentiality and security measures.</li> <li>Legal Requirements: We may disclose information if required to do so by law or in the good faith belief that such action is necessary to comply with a legal obligation, protect and defend our rights or property, prevent fraud, act in urgent circumstances to protect the personal safety of users of the Service or the public, or protect against legal liability.</li> <li>Aggregated/Anonymized Data: We may share aggregated or anonymized information (which does not identify individuals) for research, analytics, or reporting purposes.</li> <li>We do not sell developer personal information.</li> </ul> <p>5. Data Security</p> <p>We implement reasonable technical and organizational measures to protect the information we collect from loss, misuse, unauthorized access, disclosure, alteration, and destruction. This includes using HTTPS for API communication and hashing developer API keys. However, no internet transmission or electronic storage is 100% secure.</p> <p>6. Data Retention</p> <p>We retain information for as long as necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law.</p> <ul> <li>Developer Information: Retained as long as the developer account is active or as needed for operational purposes.</li> <li>Agent Card Data: Retained as long as the card is active or for a reasonable period after deactivation for archival purposes, unless requested otherwise by the developer under their rights.</li> <li>Log Data: Typically retained for a limited period (e.g., 30-90 days) for security and debugging purposes, unless required for ongoing investigations or legal obligations.</li> </ul> <p>7. Your Rights (GDPR and other applicable laws)</p> <p>Depending on your location, you may have certain rights regarding your personal information, including:</p> <ul> <li>The right to access the personal information we hold about you.</li> <li>The right to request correction of inaccurate personal information.</li> <li>The right to request erasure of your personal information (subject to legal/operational constraints).</li> <li>The right to object to or restrict processing of your personal information.</li> <li>The right to data portability.</li> </ul> <p>To exercise these rights, please contact us at:</p> <p><code>[AgentVault@proton.me]</code></p> <p>We will respond to your request consistent with applicable law.</p> <p>8. International Data Transfers</p> <p>The Service may be hosted and operated in jurisdictions outside of your own. By using the Service, you consent to the transfer of your information to these jurisdictions, which may have data protection rules that are different from those of your country.</p> <p>9. Children's Privacy</p> <p>The Service is not directed to individuals under the age of 16 (or the relevant age of digital consent in your jurisdiction). We do not knowingly collect personal information from children. If we become aware that a child has provided us with personal information, we will take steps to delete such information.</p> <p>10. Changes to This Privacy Policy</p> <p>We may update this Privacy Policy from time to time. If we make material changes, we will notify you by updating the \"Last Updated\" date at the top of this policy and potentially through other means (e.g., a notice on a project website or mailing list, if available). We encourage you to review this policy periodically.</p> <p>11. Contact Us</p> <p>If you have any questions about this Privacy Policy, please contact us at:</p> <p><code>[AgentVault@proton.me]</code></p>"},{"location":"security/","title":"AgentVault Security Considerations","text":"<p>Note: For the official security policy and vulnerability reporting process, please see the Security Policy document.</p> <p>This document details the security mechanisms, considerations, and best practices within the AgentVault ecosystem. Security is fundamental to enabling trustworthy interactions between agents and protecting user/developer credentials.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Authentication verifies the identity of the communicating parties. AgentVault employs different mechanisms for client-to-agent and developer-to-registry interactions.</p>"},{"location":"security/#1-client-to-agent-authentication-a2a","title":"1. Client-to-Agent Authentication (A2A)","text":"<p>Agents declare how clients should authenticate in their <code>AgentCard</code> (<code>authSchemes</code>). The <code>agentvault</code> library supports:</p> <ul> <li><code>none</code>: No authentication. Use only for public, non-sensitive agents.</li> <li><code>apiKey</code>: Client sends a pre-shared secret in <code>X-Api-Key</code>. Requires secure key management on both client (<code>KeyManager</code>) and server (agent implementation).</li> <li><code>oauth2</code> (Client Credentials Grant): Client uses its ID/Secret (managed by <code>KeyManager</code>) to get a Bearer token from the agent's <code>/token</code> endpoint. The client sends this token in the <code>Authorization: Bearer &lt;token&gt;</code> header for A2A requests. The <code>AgentVaultClient</code> handles token fetching/caching. The agent server must implement the <code>/token</code> endpoint and validate Bearer tokens at its <code>/a2a</code> endpoint.</li> <li><code>bearer</code>: Client sends a pre-obtained Bearer token. Token lifecycle management is external to AgentVault library. Agent server must validate the token.</li> </ul> <p>(Refer to the A2A Profile for more detail)</p>"},{"location":"security/#2-developer-to-registry-authentication","title":"2. Developer-to-Registry Authentication","text":"<p>The registry uses a multi-faceted approach for developers managing their agents:</p> <ul> <li>Account Creation: Developers register using email and password. Passwords are hashed using bcrypt (<code>passlib</code>) before storage. Email verification is required.</li> <li>Login (JWT): Successful login (<code>POST /auth/login</code>) returns a JSON Web Token (JWT) signed using a server-side secret (<code>API_KEY_SECRET</code> from config). This JWT acts as a session token.</li> <li>Authenticated Requests (JWT): Developers include the JWT in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent requests to protected endpoints (e.g., managing agent cards, API keys, using the agent builder). The registry API verifies the token's signature and expiry.</li> <li>Account Recovery (Recovery Keys): During registration, single-use recovery keys are generated. One representative key's hash (using bcrypt) is stored. If a developer loses their password, they can use their email and one of the plain text recovery keys (which they stored securely offline) via <code>POST /auth/recover-account</code>. The server verifies the key against the stored hash. If valid, it issues a very short-lived JWT specifically for setting a new password (<code>POST /auth/set-new-password</code>). The recovery key hash is then invalidated in the database.</li> <li>Programmatic API Keys:<ul> <li>Purpose: For non-interactive use (scripts, CI/CD) to manage agent cards.</li> <li>Generation: Developers generate these keys via the Developer Portal UI or <code>POST /developers/me/apikeys</code>. The full key (e.g., <code>avreg_...</code>) is shown only once.</li> <li>Storage: The hash of the full key (using <code>passlib</code> with bcrypt) and the non-secret prefix (<code>avreg_</code>) are stored in the <code>developer_api_keys</code> database table.</li> <li>Verification: For requests using the <code>X-Api-Key</code> header, the registry API finds potential keys based on the prefix, then uses <code>passlib.verify()</code> to check the provided plain key against the stored hashes for active keys belonging to the developer associated with the prefix match (lookup logic might need optimization for scale).</li> </ul> </li> </ul> <p>Security Implications:</p> <ul> <li>JWTs provide standard session management but require secure handling of the <code>API_KEY_SECRET</code> on the server.</li> <li>Recovery keys provide a fallback but must be stored securely by the developer; losing them means losing account access if password reset fails. Hashing the stored key prevents direct compromise from database leaks.</li> <li>Programmatic API keys offer convenience for automation but must be treated as sensitive secrets by the developer. Hashing provides database-level protection.</li> </ul>"},{"location":"security/#credential-management-keymanager-client-side","title":"Credential Management (<code>KeyManager</code> - Client Side)","text":"<p>(This section remains largely the same as before, emphasizing keyring usage)</p> <p>The <code>agentvault</code> library's <code>KeyManager</code> provides a unified way for clients (like the CLI) to manage credentials needed for agent authentication.</p> <ul> <li>Secure Storage: Strongly recommends using the OS Keyring (<code>--keyring</code> or <code>--oauth-configure</code> options in CLI <code>config set</code>) for storing sensitive API keys and OAuth secrets.</li> <li>Alternative Sources: Supports loading from environment variables and <code>.env</code>/<code>.json</code> files, but users must ensure appropriate security for these methods.</li> <li>Abstraction: Client code interacts with <code>KeyManager</code> without needing to know the storage location.</li> </ul>"},{"location":"security/#transport-security","title":"Transport Security","text":"<ul> <li>HTTPS is MANDATORY for all communication with the AgentVault Registry API and any A2A agent endpoint not run on <code>localhost</code>.</li> </ul>"},{"location":"security/#data-validation","title":"Data Validation","text":"<ul> <li>Pydantic: Used extensively for request/response validation in the registry API, server SDK, and core library models, preventing malformed data issues.</li> <li>Registry: Validates submitted <code>card_data</code> against the canonical <code>agentvault.models.AgentCard</code> schema.</li> </ul>"},{"location":"security/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Registry: Implements basic IP-based rate limiting (<code>slowapi</code>).</li> <li>Agents: Agent developers should implement their own rate limiting.</li> </ul>"},{"location":"security/#trusted-execution-environments-tee","title":"Trusted Execution Environments (TEE)","text":"<ul> <li>Current Status: Declarative only. Agent Cards can specify TEE usage, and the registry supports filtering based on this.</li> <li>Future Work: Automated attestation verification is planned.</li> </ul>"},{"location":"security/#dependency-security","title":"Dependency Security","text":"<ul> <li>Auditing: Automated checks via GitHub Actions (<code>pip-audit</code>).</li> <li>Updates: Regular updates are crucial.</li> </ul>"},{"location":"security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Please report suspected security vulnerabilities privately according to the Security Policy.</p>"},{"location":"security_policy/","title":"Security Policy for AgentVault","text":""},{"location":"security_policy/#introduction","title":"Introduction","text":"<p>The AgentVault project prioritizes security. We appreciate the efforts of security researchers and the community in helping us maintain a secure ecosystem. This document outlines our policy for reporting security vulnerabilities.</p>"},{"location":"security_policy/#scope","title":"Scope","text":"<p>This policy applies to the following components and repositories within the AgentVault project:</p> <ul> <li><code>agentvault</code> (Core Library): Located in the <code>agentvault_library/</code> directory.</li> <li><code>agentvault-registry</code> (Registry API): Located in the <code>agentvault_registry/</code> directory.</li> <li><code>agentvault-cli</code> (CLI Client): Located in the <code>agentvault_cli/</code> directory.</li> <li><code>agentvault-server-sdk</code> (Server SDK): Located in the <code>agentvault_server_sdk/</code> directory.</li> </ul> <p>Vulnerabilities discovered in third-party agents listed in the registry should be reported directly to the respective agent provider according to their own security policy. The AgentVault registry itself only stores metadata.</p>"},{"location":"security_policy/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We appreciate responsible disclosure. Please report any suspected security vulnerabilities privately to ensure the security of our users and the ecosystem.</p> <p>Preferred Method:</p> <ul> <li> <p>GitHub Private Vulnerability Reporting: If you are reporting via GitHub, please use the built-in \"Report a vulnerability\" feature within the main AgentVault repository. This allows for secure communication and tracking.</p> <p><code>[https://github.com/SecureAgentTools/AgentVault/]</code></p> </li> </ul> <p>Alternative Method:</p> <ul> <li> <p>Email: If you cannot use GitHub's reporting feature, you can email your report to:</p> <p><code>[AgentVault@proton.com</code></p> <p>Use a clear subject line like \"Security Vulnerability Report: AgentVault [Component Name]\".</p> </li> </ul> <p>What to Include:</p> <p>Please include the following details in your report:</p> <ul> <li>Component: Which part of AgentVault is affected (library, registry, CLI, SDK)?</li> <li>Version: The specific version number or commit hash, if known.</li> <li>Description: A clear and concise description of the vulnerability.</li> <li>Steps to Reproduce: Detailed steps required to reproduce the vulnerability. Include code snippets, configuration details, or specific API requests if applicable.</li> <li>Potential Impact: Your assessment of the potential impact of the vulnerability.</li> <li>Contact Information: Your name or alias and contact email address for follow-up.</li> </ul>"},{"location":"security_policy/#our-commitment","title":"Our Commitment","text":"<ul> <li>We will acknowledge receipt of your vulnerability report, typically within 48 business hours.</li> <li>We will investigate the report promptly and work to validate the vulnerability.</li> <li>We will keep you informed of our progress during the investigation and remediation process.</li> <li>We aim to address critical vulnerabilities as quickly as possible.</li> <li>We will coordinate public disclosure with you after a fix is available, potentially issuing security advisories and crediting you for your discovery (unless you prefer to remain anonymous).</li> </ul>"},{"location":"security_policy/#safe-harbor","title":"Safe Harbor","text":"<p>We consider security research and vulnerability reporting activities conducted under this policy to be authorized and beneficial. We will not pursue legal action against individuals who report vulnerabilities in good faith, adhere to this policy, and do not cause harm to AgentVault, its users, or its infrastructure.</p> <p>Thank you for helping keep AgentVault secure.</p>"},{"location":"tee_profile/","title":"AgentVault TEE Profile (v0.1 - Declarative)","text":"<p>This document outlines the initial support for Trusted Execution Environments (TEEs) within the AgentVault ecosystem, focusing on declaration and discovery.</p> <p>Version: 0.1 (Declarative Phase)</p>"},{"location":"tee_profile/#overview","title":"Overview","text":"<p>Trusted Execution Environments (TEEs) like Intel SGX, AMD SEV, AWS Nitro Enclaves, Azure Confidential Computing, Confidential Space, etc., provide hardware-level isolation to protect the confidentiality and integrity of code and data being processed. Leveraging TEEs can significantly enhance the security posture of AI agents, especially when handling sensitive information or performing critical tasks.</p> <p>AgentVault aims to facilitate the use of TEEs by allowing agents to declare their TEE usage within their Agent Card and enabling clients (like the CLI or library) to discover agents based on this capability via the Registry.</p>"},{"location":"tee_profile/#agent-card-declaration","title":"Agent Card Declaration","text":"<p>Agents running within a TEE can declare this capability in their <code>agent-card.json</code> file within the <code>capabilities</code> object, using the optional <code>teeDetails</code> field. This corresponds to the <code>agentvault.models.TeeDetails</code> Pydantic model.</p> <p>Schema Fields:</p> <ul> <li><code>capabilities.teeDetails</code> (Optional Object): Contains details about the TEE. If this object is present, it indicates the agent utilizes a TEE.<ul> <li><code>type</code> (String, Required if <code>teeDetails</code> is present): An identifier for the specific TEE technology used. Examples: <code>\"Intel SGX\"</code>, <code>\"AMD SEV-SNP\"</code>, <code>\"AWS Nitro Enclaves\"</code>, <code>\"Azure Confidential Computing\"</code>, <code>\"Confidential Space\"</code>. Standardized identifiers are preferred, but custom strings are allowed.</li> <li><code>attestationEndpoint</code> (String, Optional, Format: URL): A URL where clients can potentially obtain or verify an attestation document for the specific TEE instance hosting the agent. The format and verification process for the attestation document are specific to the TEE type and are outside the scope of this profile version.</li> <li><code>publicKey</code> (String, Optional): A public key associated with the TEE instance, potentially used for establishing secure channels or verifying attestations. The format (e.g., PEM, JWK) depends on the TEE type and attestation protocol. Currently informational only.</li> <li><code>description</code> (String, Optional): A human-readable description of the TEE setup, its purpose, or the guarantees it provides for this agent.</li> </ul> </li> </ul> <p>Example <code>agent-card.json</code> Snippet:</p> <pre><code>{\n  \"schemaVersion\": \"1.0\",\n  // ... other fields ...\n  \"capabilities\": {\n    \"a2aVersion\": \"1.0\",\n    // ... other capabilities ...\n    \"teeDetails\": {\n      \"type\": \"AWS Nitro Enclaves\",\n      \"attestationEndpoint\": \"https://attestation.example-agent.com/verify\",\n      \"description\": \"Agent runs within an AWS Nitro Enclave for enhanced data confidentiality during processing.\"\n    }\n  },\n  // ... other fields ...\n}\n</code></pre>"},{"location":"tee_profile/#discovery-via-registry","title":"Discovery via Registry","text":"<p>The AgentVault Registry API (<code>agentvault_registry</code>) supports filtering agents based on their TEE declaration:</p> <ul> <li><code>GET /api/v1/agent-cards/?has_tee=true</code>: Returns only agents whose Agent Card includes the <code>capabilities.teeDetails</code> object (regardless of its content).</li> <li><code>GET /api/v1/agent-cards/?has_tee=false</code>: Returns only agents whose Agent Card does not include the <code>capabilities.teeDetails</code> object.</li> <li><code>GET /api/v1/agent-cards/?tee_type=&lt;type_string&gt;</code>: Returns only agents where <code>capabilities.teeDetails.type</code> matches the provided <code>&lt;type_string&gt;</code> (case-insensitive comparison recommended for the registry implementation). Example: <code>?tee_type=AWS%20Nitro%20Enclaves</code>.</li> </ul> <p>The public Registry Web UI and the <code>agentvault_cli discover</code> command also provide options corresponding to these filters.</p>"},{"location":"tee_profile/#current-scope-limitations-v01","title":"Current Scope &amp; Limitations (v0.1)","text":"<ul> <li>Declarative Only: This version focuses solely on allowing agents to declare their TEE usage and enabling discovery based on that declaration.</li> <li>No Automated Verification: AgentVault clients (library, CLI) do not automatically perform TEE attestation verification based on the <code>attestationEndpoint</code> or <code>publicKey</code>. Implementing robust and generic attestation verification is complex due to the variety of TEE technologies and attestation protocols.</li> <li>Client Responsibility: Clients wishing to verify an agent's TEE status must currently implement the verification logic themselves, specific to the declared <code>teeDetails.type</code> and using the provided <code>attestationEndpoint</code> or other out-of-band mechanisms. The presence of <code>teeDetails</code> in the card is not a guarantee verified by AgentVault itself.</li> <li>No Secure Channel Guarantee: Declaring TEE usage does not automatically establish a TEE-secured communication channel beyond standard transport security (HTTPS). Establishing such channels might be a future enhancement, potentially leveraging the <code>publicKey</code>.</li> </ul>"},{"location":"tee_profile/#future-work","title":"Future Work","text":"<ul> <li>Researching and potentially integrating standardized TEE attestation verification libraries or protocols into the <code>agentvault</code> client library.</li> <li>Defining mechanisms for establishing secure communication channels directly with TEE enclaves, possibly leveraging the declared <code>publicKey</code>.</li> <li>Standardizing <code>teeDetails.type</code> identifiers further.</li> </ul>"},{"location":"use_cases/","title":"AgentVault Use Cases &amp; Scenarios","text":"<p>The core AgentVault Vision is to enable a future where diverse AI agents can collaborate securely and effectively. This page provides concrete examples of complex workflows made possible or significantly easier by the AgentVault ecosystem and its foundational components.</p> <p>These scenarios illustrate how features like standardized discovery (Registry), secure interoperable communication (A2A Profile), robust authentication (Auth Schemes &amp; KeyManager), and developer tooling (SDKs, Library) come together to create powerful, automated solutions.</p>"},{"location":"use_cases/#scenario-1-hyper-personalized-concierge-life-management","title":"Scenario 1: Hyper-Personalized Concierge &amp; Life Management","text":"<p>Goal: An AI personal assistant that proactively manages complex tasks like travel planning by securely coordinating multiple specialized agents based on deep user preferences stored securely.</p> <p>Workflow:</p> <ol> <li>User Request: User asks their primary Orchestrator Agent to plan a trip with specific constraints (destination, budget, preferences).</li> <li>Secure Context: Orchestrator authenticates (e.g., OAuth2) with the user's Profile Agent (running in a TEE) to retrieve relevant, scoped preferences.</li> <li>Discovery: Orchestrator queries the AgentVault Registry for agents capable of <code>flights</code>, <code>hotels</code>, <code>activity-booking</code>, <code>reviews</code>.</li> <li>Task Delegation: Orchestrator tasks discovered agents (<code>FlightSearchAgent</code>, <code>HotelSearchAgent</code>, etc.) via the A2A protocol. Authentication (e.g., API Key via KeyManager) is used for premium or booking agents.</li> <li>Results &amp; Synthesis: Agents return results (potentially streaming via SSE). Orchestrator synthesizes options.</li> <li>Action: Upon user confirmation, Orchestrator securely instructs booking agents via A2A to finalize reservations.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph UserInteraction[\"User Interaction\"]\n        User((\"\ud83d\udc64 User\"))\n        Orchestrator[/\"\ud83e\udde0 OrchestratorAgent\"/]\n    end\n\n    subgraph SecureProfile[\"Secure User Profile\"]\n        ProfileAgent[(\"\ud83d\udc64 Profile Agent(TEE)\")]\n    end\n\n    subgraph AgentDiscovery[\"Agent Discovery\"]\n        Registry[\"\ud83d\udcda Registry\"]\n        FlightAgent[\"\u2708\ufe0f Flight SearchAgent\"]\n        HotelAgent[\"\ud83c\udfe8 Hotel SearchAgent\"]\n        BookingAgent{\"\ud83d\udd10 Booking Agent(Auth Required)\"}\n    end\n\n    User --&gt; Orchestrator\n    Orchestrator --&gt; User\n\n    Orchestrator &lt;--&gt; ProfileAgent\n\n    Orchestrator &lt;--&gt; Registry\n    Orchestrator &lt;--&gt; FlightAgent\n    Orchestrator &lt;--&gt; HotelAgent\n    Orchestrator &lt;--&gt; BookingAgent\n\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style ProfileAgent fill:#ea80fc,stroke:#e040fb,color:black\n    style FlightAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style HotelAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style BookingAgent fill:#84ffff,stroke:#18ffff,color:black\n    style User fill:#fff59d,stroke:#ffee58,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Discovery: Dynamically finds specialized travel agents.</li> <li>Interoperability: Standard A2A ensures communication between diverse agents.</li> <li>Security: Manages authentication for profile access and booking actions via KeyManager &amp; Auth Schemes. TEE declaration enhances trust.</li> </ul>"},{"location":"use_cases/#scenario-2-automated-scientific-discovery-pipeline","title":"Scenario 2: Automated Scientific Discovery Pipeline","text":"<p>Goal: Accelerate research by automating the process of finding relevant studies, extracting key data, running complex simulations (potentially on secure hardware), analyzing results, and drafting reports.</p> <p>Workflow:</p> <ol> <li>Setup: Researcher configures a Pipeline Orchestrator Agent.</li> <li>Literature Search: Orchestrator discovers (<code>Registry</code>) and tasks (<code>A2A</code>) <code>PubMedSearchAgent</code> / <code>ArXivSearchAgent</code>.</li> <li>Information Extraction: Orchestrator tasks <code>PDFDataExtractionAgent</code> with URLs from search results. Agent returns structured data Artifacts.</li> <li>Simulation: Orchestrator discovers <code>ProteinFoldingSimAgent</code> (declaring TEE support) via Registry. Tasks agent via A2A with input data artifacts.</li> <li>Analysis: Orchestrator tasks <code>BioStatAnalysisAgent</code> with simulation result artifacts.</li> <li>Report Generation: Orchestrator sends components to <code>DraftWriterAgent</code>.</li> </ol> <p>Diagram:</p> <pre><code>flowchart LR\n    Researcher((\"\ud83d\udc69\u200d\ud83d\udd2c Researcher\"))\n    Orchestrator[/\"\ud83e\udde0 PipelineOrchestrator\"/]\n    Registry((\"\ud83d\udcda Registry\"))\n\n    subgraph Research[\"Research &amp; Analysis Pipeline\"]\n        direction TB\n        SearchAgent[\"\ud83d\udd0e LiteratureSearch Agent\"]\n        Extractor[\"\ud83d\udcc4 PDF ExtractAgent\"]\n        Simulator[\"\u2699\ufe0f SimulationAgent (TEE)\"]\n        Analyzer[\"\ud83d\udcca AnalysisAgent\"]\n        Writer[\"\ud83d\udcdd Draft WriterAgent\"]\n    end\n\n    Researcher &lt;--&gt; Orchestrator\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; SearchAgent\n    Orchestrator &lt;--&gt; Extractor\n    Orchestrator &lt;--&gt; Simulator\n    Orchestrator &lt;--&gt; Analyzer\n    Orchestrator &lt;--&gt; Writer\n\n    style Researcher fill:#fff59d,stroke:#ffee58,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style SearchAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Extractor fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Simulator fill:#ea80fc,stroke:#e040fb,color:black\n    style Analyzer fill:#b9f6ca,stroke:#69f0ae,color:black\n    style Writer fill:#b9f6ca,stroke:#69f0ae,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Discovery: Finds specialized scientific agents, including filtering by TEE capability.</li> <li>Interoperability: Standard A2A allows complex pipeline construction.</li> <li>Artifacts: Enables exchange of large/complex data (simulation inputs/outputs).</li> <li>TEE Declaration: Allows secure compute agents to advertise their status.</li> </ul>"},{"location":"use_cases/#scenario-3-decentralized-smart-factory-monitoring-control","title":"Scenario 3: Decentralized Smart Factory Monitoring &amp; Control","text":"<p>Goal: Monitor and control factory floor equipment from various vendors in a resilient way, reducing reliance on a single central cloud and enabling faster local responses.</p> <p>Workflow:</p> <ol> <li>Local Deployment: Device Agents (wrapping sensors/actuators) register with a local AgentVault Registry.</li> <li>Monitoring: A local Monitoring Agent discovers Device Agents via Registry and subscribes to data streams (<code>tasks/sendSubscribe</code> via SSE).</li> <li>Alerting: Monitoring Agent detects an anomaly, finds an <code>AlertingAgent</code> via Registry, and sends an alert message via A2A.</li> <li>Response: Alerting Agent notifies humans and tasks a <code>ControlAgent</code> (or specific Device Agent) via A2A using required Auth Scheme (e.g., <code>apiKey</code>) managed by <code>KeyManager</code>.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph FactoryFloor[\"Factory Floor Edge\"]\n        SensorAgent[(\"\ud83c\udf21\ufe0f TemperatureSensor Agent\")]\n        ActuatorAgent{\"\ud83d\udd27 Valve Actuator(Auth Required)\"}\n        MachineAgent[(\"\u2699\ufe0f Machine StatusAgent\")]\n    end\n\n    subgraph ControlNetwork[\"Local Control Network\"]\n        LocalRegistry[(\"\ud83d\udcda Local Registry\")]\n        MonitorAgent[/\"\ud83d\udc41\ufe0f MonitoringAgent\"/]\n        AlertAgent[/\"\ud83d\udea8 AlertingAgent\"/]\n        ControlAgent[/\"\ud83c\udfae ControlAgent\"/]\n        Supervisor((\"\ud83d\udc68\u200d\ud83d\udcbc HumanSupervisor\"))\n    end\n\n    %% Registration connections\n    SensorAgent --&gt; LocalRegistry\n    ActuatorAgent --&gt; LocalRegistry\n    MachineAgent --&gt; LocalRegistry\n    AlertAgent --&gt; LocalRegistry\n    ControlAgent --&gt; LocalRegistry\n\n    %% Monitoring flow\n    MonitorAgent --&gt; LocalRegistry\n    SensorAgent --&gt; MonitorAgent\n    MachineAgent --&gt; MonitorAgent\n\n    %% Alert flow\n    MonitorAgent --&gt; AlertAgent\n    AlertAgent --&gt; Supervisor\n    AlertAgent --&gt; ControlAgent\n    ControlAgent --&gt; ActuatorAgent\n\n    style SensorAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ActuatorAgent fill:#84ffff,stroke:#18ffff,color:black\n    style MachineAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style LocalRegistry fill:#80d8ff,stroke:#40c4ff,color:black\n    style MonitorAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style AlertAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style ControlAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style Supervisor fill:#fff59d,stroke:#ffee58,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Decentralization: Enables local discovery and communication via a local Registry.</li> <li>Interoperability: Standard A2A connects heterogeneous devices/agents.</li> <li>Real-time Data: SSE facilitates efficient monitoring streams.</li> <li>Security: Secures control commands locally via Auth Schemes &amp; KeyManager.</li> </ul>"},{"location":"use_cases/#scenario-4-automated-crm-lead-enrichment","title":"Scenario 4: Automated CRM Lead Enrichment","text":"<p>Goal: Automatically enrich new CRM leads with verified external data (LinkedIn, company info, contact validation) to accelerate sales qualification and improve data quality.</p> <p>Workflow:</p> <ol> <li>Trigger: A new lead is created in the CRM.</li> <li>Orchestration: A CRM Orchestrator Agent is triggered.</li> <li>Discovery: Orchestrator queries the AgentVault Registry for agents tagged <code>enrichment</code>, <code>linkedin</code>, <code>firmographics</code>, <code>validation</code>.</li> <li>Task Delegation (A2A): Orchestrator tasks the discovered agents (<code>LinkedIn Enricher</code>, <code>Firmographics Agent</code>, <code>Contact Validator</code>) via A2A, using appropriate authentication (API Keys via <code>KeyManager</code>) for premium data sources.</li> <li>Data Aggregation: Orchestrator receives structured results (profile URLs, company size, email validity) potentially as Artifacts or direct results.</li> <li>CRM Update: Orchestrator updates the lead record in the CRM with the enriched data.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TD\n    subgraph CRMSystem[\"CRM System\"]\n        User((\"\ud83d\udc69\u200d\ud83d\udcbc Sales Rep\"))\n        CRM[(\"\ud83d\udcca CRM Platform\")]\n        Trigger[/\"\ud83d\udd14 Webhook/Trigger\"/]\n    end\n\n    subgraph AgentNetwork[\"Agent Network\"]\n        Orchestrator[/\"\ud83e\udde0 CRM OrchestratorAgent\"/]\n        Registry[\"\ud83d\udcda Registry\"]\n\n        subgraph EnrichmentServices[\"Enrichment Services\"]\n            direction LR\n            LinkedInAgent{\"\ud83d\udd17 LinkedIn Enricher(Auth Required)\"}\n            FirmographicsAgent{\"\ud83c\udfe2 Firmographics(Auth Required)\"}\n            ValidatorAgent[\"\u2713 ContactValidator\"]\n        end\n    end\n\n    User --&gt; CRM\n    CRM --&gt; Trigger\n    Trigger --&gt; Orchestrator\n\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; LinkedInAgent\n    Orchestrator &lt;--&gt; FirmographicsAgent\n    Orchestrator &lt;--&gt; ValidatorAgent\n\n    Orchestrator --&gt; CRM\n\n    style User fill:#fff59d,stroke:#ffee58,color:black\n    style CRM fill:#bbdefb,stroke:#64b5f6,color:black\n    style Trigger fill:#ffcc80,stroke:#ffa726,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style LinkedInAgent fill:#84ffff,stroke:#18ffff,color:black\n    style FirmographicsAgent fill:#84ffff,stroke:#18ffff,color:black\n    style ValidatorAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n</code></pre> <p>AgentVault Value:</p> <ul> <li>Modularity: Easily find and swap enrichment agents via the Registry.</li> <li>Standardization: A2A protocol simplifies interaction with diverse data providers.</li> <li>Security: KeyManager handles API keys for premium enrichment services securely.</li> <li>Automation: Reduces manual data entry and improves lead quality efficiently.</li> </ul>"},{"location":"use_cases/#scenario-5-automated-order-processing-fulfillment-erp-integration","title":"Scenario 5: Automated Order Processing &amp; Fulfillment (ERP Integration)","text":"<p>Goal: Streamline order fulfillment by automating inventory checks, shipping label generation, billing updates, and CRM notifications when a new order is placed.</p> <p>Workflow:</p> <ol> <li>Trigger: New order received in E-commerce Platform.</li> <li>Orchestration: Order Processing Agent is triggered.</li> <li>Inventory Check (A2A): Orchestrator tasks <code>Inventory Agent</code> (connected to ERP/WMS) via A2A.</li> <li>Shipping Label (A2A + Auth): If stock confirmed, Orchestrator discovers (<code>Registry</code>) and tasks <code>Shipping Label Agent</code> (e.g., ShipStation, EasyPost wrapper) using required API Key (<code>KeyManager</code>). Agent returns label data Artifact.</li> <li>Billing (A2A): Orchestrator tasks <code>Billing Agent</code> to generate invoice in ERP/Accounting system.</li> <li>CRM Update (A2A): Orchestrator tasks <code>CRM Update Agent</code> to log order status against customer record.</li> <li>Notification: Orchestrator notifies E-commerce platform/user of completion.</li> </ol> <p>Diagram:</p> <pre><code>flowchart TB\n    Ecommerce[(\"\ud83d\udecd\ufe0f E-commercePlatform\")] --&gt; OrderAgent[/\"\ud83d\udce6 Order ProcessingAgent\"/]\n\n    subgraph Systems[\"Enterprise Systems\"]\n        ERP[(\"\ud83d\udcbb ERP / WMS\")]\n        ShippingAPI[(\"\ud83d\ude9a Shipping API\")]\n        CRM[(\"\ud83d\udc65 CRM System\")]\n    end\n\n    subgraph AgentNetwork[\"Agent Network\"]\n        Registry[(\"\ud83d\udcda Registry\")]\n        InventoryAgent[\"\ud83d\udd22 InventoryAgent\"]\n        ShippingAgent{\"\ud83c\udff7\ufe0f Shipping Label(Auth Required)\"}\n        BillingAgent[\"\ud83d\udcb0 BillingAgent\"]\n        CRMUpdateAgent[\"\ud83d\udcdd CRM UpdateAgent\"]\n    end\n\n    OrderAgent &lt;--&gt; Registry\n\n    OrderAgent &lt;--&gt; InventoryAgent\n    InventoryAgent &lt;--&gt; ERP\n\n    OrderAgent &lt;--&gt; ShippingAgent\n    ShippingAgent &lt;--&gt; ShippingAPI\n\n    OrderAgent &lt;--&gt; BillingAgent\n    BillingAgent &lt;--&gt; ERP\n\n    OrderAgent &lt;--&gt; CRMUpdateAgent\n    CRMUpdateAgent &lt;--&gt; CRM\n\n    OrderAgent --&gt; Ecommerce\n\n    style Ecommerce fill:#bbdefb,stroke:#64b5f6,color:black\n    style OrderAgent fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style InventoryAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ShippingAgent fill:#84ffff,stroke:#18ffff,color:black\n    style BillingAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style CRMUpdateAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style ERP fill:#bbdefb,stroke:#64b5f6,color:black\n    style ShippingAPI fill:#bbdefb,stroke:#64b5f6,color:black\n    style CRM fill:#bbdefb,stroke:#64b5f6,color:black</code></pre> <p>AgentVault Value:</p> <ul> <li>Process Automation: Connects disparate systems (E-commerce, ERP, Shipping, CRM) via standardized agents.</li> <li>Interoperability: A2A allows communication between custom internal agents (Inventory, Billing) and external service wrappers (Shipping).</li> <li>Security: Securely manages API keys for external services like shipping providers.</li> <li>Flexibility: Easily replace the Shipping Label Agent if switching providers, without changing the Orchestrator significantly.</li> </ul>"},{"location":"use_cases/#scenario-6-intelligent-customer-support-ticket-routing","title":"Scenario 6: Intelligent Customer Support Ticket Routing","text":"<p>Goal: Improve customer support efficiency by automatically analyzing incoming tickets, enriching them with context, and routing them to the best-suited queue or agent, potentially providing automated answers for common issues.</p> <p>Workflow:</p> <ol> <li>Trigger: New support ticket created in Helpdesk System.</li> <li>Orchestration: Support Orchestrator Agent is triggered.</li> <li>Initial Analysis (A2A): Orchestrator tasks <code>SentimentAnalysisAgent</code> and <code>TopicClassificationAgent</code> via A2A.</li> <li>Context Enrichment (Discovery &amp; A2A): Orchestrator discovers (<code>Registry</code>) and tasks <code>CRMLookupAgent</code> (using auth via <code>KeyManager</code>) to fetch customer history/details based on ticket submitter's email.</li> <li>Knowledge Base Check (A2A): Orchestrator tasks <code>KnowledgeBaseSearchAgent</code> with classified topic and ticket content.</li> <li>Decision &amp; Routing:<ul> <li>If KB Agent finds a high-confidence answer, Orchestrator sends automated reply via <code>HelpdeskUpdateAgent</code>.</li> <li>If no KB match, Orchestrator uses sentiment, topic, and customer context to task <code>RoutingAgent</code> to assign the ticket to the appropriate human support queue (e.g., Tier 1, Billing, Technical) via <code>HelpdeskUpdateAgent</code>.</li> </ul> </li> </ol> <p>Diagram:</p> <pre><code>flowchart LR\n    User((\"\ud83d\udc64 User\")) --&gt; Helpdesk[(\"\ud83c\udfab HelpdeskSystem\")]\n    Helpdesk --&gt; Orchestrator[/\"\ud83e\udde0 SupportOrchestrator\"/]\n\n    subgraph AgentNetwork[\"Agent Ecosystem\"]\n        Registry[\"\ud83d\udcda Registry\"]\n\n        subgraph Analysis[\"Analysis Agents\"]\n            direction TB\n            SentimentAgent[\"\ud83d\ude0a SentimentAnalysis\"]\n            TopicAgent[\"\ud83c\udff7\ufe0f TopicClassification\"]\n            CRMAgent{\"\ud83d\udc65 CRM Lookup(Auth Required)\"}\n        end\n\n        subgraph Resolution[\"Resolution Path\"]\n            direction TB\n            KBAgent[\"\ud83d\udcda Knowledge BaseAgent\"]\n            RoutingAgent[\"\ud83d\udd00 Routing LogicAgent\"]\n            HelpdeskUpdateAgent{\"\u270f\ufe0f Helpdesk Update(Auth Required)\"}\n        end\n    end\n\n    Orchestrator &lt;--&gt; Registry\n\n    Orchestrator &lt;--&gt; SentimentAgent\n    Orchestrator &lt;--&gt; TopicAgent\n    Orchestrator &lt;--&gt; CRMAgent\n\n    Orchestrator &lt;--&gt; KBAgent\n    Orchestrator &lt;--&gt; RoutingAgent\n    Orchestrator &lt;--&gt; HelpdeskUpdateAgent\n\n    HelpdeskUpdateAgent --&gt; Helpdesk\n\n    style User fill:#fff59d,stroke:#ffee58,color:black\n    style Helpdesk fill:#bbdefb,stroke:#64b5f6,color:black\n    style Orchestrator fill:#ff9e80,stroke:#ff6e40,color:black\n    style Registry fill:#80d8ff,stroke:#40c4ff,color:black\n    style SentimentAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style TopicAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style CRMAgent fill:#84ffff,stroke:#18ffff,color:black\n    style KBAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style RoutingAgent fill:#b9f6ca,stroke:#69f0ae,color:black\n    style HelpdeskUpdateAgent fill:#84ffff,stroke:#18ffff,color:black</code></pre> <p>AgentVault Value:</p> <ul> <li>Workflow Orchestration: Enables complex, multi-step support workflows involving analysis, enrichment, and action.</li> <li>Specialization: Allows using best-of-breed agents for sentiment, classification, KB search, etc.</li> <li>Secure Data Access: Protects access to CRM and Helpdesk systems via authenticated agents.</li> <li>Efficiency: Automates common tasks and routes complex issues effectively, reducing manual triage and resolution time.</li> </ul>"},{"location":"vision/","title":"The AgentVault Vision: Enabling the Collaborative AI Future","text":""},{"location":"vision/#the-fragmented-present-islands-of-intelligence","title":"The Fragmented Present: Islands of Intelligence","text":"<p>The era of Artificial Intelligence is rapidly evolving. We see powerful, specialized AI agents emerging daily, capable of remarkable feats in language, analysis, planning, and execution. Yet, despite their individual brilliance, these agents largely exist as isolated islands of intelligence.</p> <p>Integrating them into complex workflows often requires bespoke, brittle connections. Communicating context and ensuring security between agents from different providers or built with different tools is a significant challenge. Key problems hinder the realization of truly collaborative AI:</p> <ul> <li>Discovery: How can agents dynamically find other agents with the specific capabilities they need?</li> <li>Interoperability: How can agents built by different teams, using different models or platforms, communicate reliably and understand each other?</li> <li>Security &amp; Trust: How can we ensure that interactions between agents are secure, that credentials aren't exposed, and that agents operate within expected boundaries, potentially within verifiable Trusted Execution Environments (TEEs)?</li> <li>Context Management: How can agents efficiently share the necessary context (user goals, history, data references) to perform collaborative tasks without exceeding limitations or losing vital information?</li> <li>Developer Experience: How can we make it easier for developers to build agents that can collaborate, without getting bogged down in complex protocol implementations and security hurdles?</li> </ul> <p>Without addressing these foundational issues, the true potential of multi-agent systems \u2013 where specialized AIs work together to solve problems beyond the scope of any single agent \u2013 remains largely untapped.</p>"},{"location":"vision/#the-agentvault-solution-a-foundation-for-collaboration","title":"The AgentVault Solution: A Foundation for Collaboration","text":"<p>AgentVault is an open-source ecosystem designed to be the bedrock for this collaborative future. We are building the essential infrastructure and standards to tear down the silos and connect the islands of intelligence.</p> <p>AgentVault provides a cohesive set of tools and specifications addressing the core challenges:</p> <ol> <li>Discovery (<code>agentvault_registry</code>): A central, queryable registry where developers can publish standardized \"Agent Cards\". This allows clients (users or other agents) to easily find agents based on name, description, capabilities, tags, TEE support, and other metadata.</li> <li>Standardized Communication (<code>A2A Profile</code>): A defined Agent-to-Agent (A2A) communication protocol based on JSON-RPC 2.0 and Server-Sent Events (SSE). This ensures that agents, regardless of their underlying implementation, can reliably exchange messages, manage task lifecycles (initiate, get status, cancel), and receive real-time updates using a common language.</li> <li>Secure Interaction (<code>KeyManager</code>, Auth Schemes): Robust mechanisms for authenticating agents using various schemes (API Keys, OAuth2 Client Credentials) coupled with secure local credential management (<code>KeyManager</code>) on the client-side and best practices (hashed keys, HTTPS enforcement) throughout the ecosystem.</li> <li>Developer Enablement (<code>SDK</code>, <code>Library</code>, <code>CLI</code>): Practical tools to simplify the process:<ul> <li><code>agentvault-server-sdk</code>: Makes building A2A-compliant agents easier, handling protocol boilerplate and integrating with frameworks like FastAPI.</li> <li><code>agentvault</code> (Library): Provides a Python client for programmatically interacting with agents and the registry.</li> <li><code>agentvault-cli</code>: Offers a user-friendly command-line interface for discovery, interaction, and credential management.</li> </ul> </li> </ol> <p>By focusing on open standards, security, and developer experience, AgentVault aims to provide the essential, non-proprietary plumbing for the multi-agent world.</p>"},{"location":"vision/#the-vision-an-interconnected-ai-ecosystem","title":"The Vision: An Interconnected AI Ecosystem","text":"<p>We envision a future powered by AgentVault where seamless, secure collaboration between diverse AI agents unlocks unprecedented capabilities. This foundation enables complex workflows previously difficult or impossible to achieve:</p> <ul> <li>Imagine hyper-personalized assistants securely coordinating specialized travel, scheduling, and profile agents to manage your life proactively.</li> <li>Picture automated scientific discovery pipelines where research agents seamlessly link literature review, data extraction, secure simulation (potentially in TEEs), and analysis agents.</li> <li>Envisage resilient smart factories where local device agents communicate directly for monitoring and control, reducing reliance on single cloud platforms.</li> </ul> <p>These are just glimpses of the potential. By providing the common rails for discovery, communication, and security, AgentVault fosters an environment where specialized agents can be combined like building blocks, leading to emergent solutions and accelerating innovation across domains.</p> <p>\u27a1\ufe0f See Detailed Use Cases &amp; Scenarios to explore these possibilities in more depth.</p>"},{"location":"vision/#core-principles","title":"Core Principles","text":"<p>Our vision is guided by these fundamental principles:</p> <ul> <li>Open Source: All core components and specifications are developed under the permissive Apache 2.0 license, ensuring transparency, community involvement, and freedom from vendor lock-in.</li> <li>Security-First: Security is not an afterthought. From secure credential management and mandatory HTTPS (for non-localhost) to TEE awareness and robust authentication handling, building a trustworthy ecosystem is paramount.</li> <li>Interoperability: Adherence to open standards (JSON-RPC, SSE, emerging A2A concepts) and well-defined schemas (<code>AgentCard</code>) ensures that agents built by different teams using different technologies can communicate effectively.</li> <li>Decentralization: While the registry provides discovery, agent execution remains decentralized. AgentVault does not dictate where or how agents are hosted, promoting flexibility and resilience.</li> <li>Developer Focus: Providing practical SDKs, libraries, clear documentation, and examples lowers the barrier for developers to build and integrate A2A-compliant agents.</li> </ul>"},{"location":"vision/#why-agentvault","title":"Why AgentVault?","text":"<p>AgentVault differentiates itself by providing a holistic, secure, and open foundation specifically designed for the challenges of A2A interaction. We combine:</p> <ul> <li>Standardized Discovery: A dedicated registry with a defined schema.</li> <li>Secure Communication: A clear A2A protocol profile with built-in support for standard authentication methods.</li> <li>Practical Tooling: SDKs, libraries, and CLI tools designed to work together seamlessly.</li> <li>Security Emphasis: Integrated secure key management and TEE awareness from the outset.</li> </ul>"},{"location":"vision/#join-the-vision","title":"Join the Vision","text":"<p>Building the future of collaborative AI requires a community effort. Whether you are developing agents, building applications that use agents, or are interested in the underlying protocols and security, we invite you to:</p> <ul> <li>Use AgentVault: Build your agents using the Server SDK, interact with agents using the Client Library and CLI.</li> <li>Register Your Agents: Make your agents discoverable by submitting them to the public registry (or run your own!).</li> <li>Contribute: Help improve the code, documentation, and examples. Report issues, suggest features, and submit pull requests. See our Contributing Guide.</li> <li>Engage: Join the discussions on our GitHub Repository.</li> </ul> <p>Let's build the interconnected AI ecosystem, together.</p>"},{"location":"developer_guide/library/","title":"Developer Guide: Client Library (<code>agentvault</code>)","text":"<p>The <code>agentvault</code> library is the core Python package for interacting with the AgentVault ecosystem from the client-side. It enables applications, scripts, or even other agents to discover A2A agents, manage credentials securely, and communicate using the A2A protocol.</p>"},{"location":"developer_guide/library/#installation","title":"Installation","text":"<p>Install the library from PyPI:</p> <pre><code>pip install agentvault\n</code></pre> <p>For optional OS Keyring support (recommended for secure credential storage):</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"developer_guide/library/#key-components","title":"Key Components","text":""},{"location":"developer_guide/library/#keymanager-key_managerpy","title":"<code>KeyManager</code> (<code>key_manager.py</code>)","text":"<p>Handles secure loading, storage, and retrieval of credentials (API keys, OAuth 2.0 Client ID/Secret) needed for agent authentication.</p> <ul> <li>Purpose: Abstracts credential sources so your client code doesn't need to handle each case explicitly. Provides a consistent interface (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) regardless of where the credential is stored.</li> <li>Initialization: <pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Recommended: Load from environment variables AND OS keyring (if available)\n# Keyring is checked only if the key isn't found in env vars first.\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Load ONLY from a specific .env file (disable env vars and keyring)\n# key_file_path = pathlib.Path(\"path/to/your/keys.env\")\n# km_file_only = KeyManager(key_file_path=key_file_path, use_env_vars=False, use_keyring=False)\n\n# Load from file AND environment (file takes priority over env)\n# key_file_path = pathlib.Path(\"path/to/your/keys.json\")\n# km_file_env = KeyManager(key_file_path=key_file_path, use_env_vars=True, use_keyring=False)\n</code></pre></li> <li>Priority Order: When retrieving credentials, <code>KeyManager</code> checks sources in this order:<ol> <li>File Cache: If <code>key_file_path</code> was provided during init and the file contained the credential.</li> <li>Environment Variable Cache: If <code>use_env_vars=True</code> (default) and the corresponding environment variable was set during init.</li> <li>OS Keyring: If <code>use_keyring=True</code> and the credential was not found in the file or environment caches. This check happens on demand when a <code>get_...</code> method is called.</li> </ol> </li> <li>Service Identifier (<code>service_id</code>): This is the crucial string used to look up credentials. It's a local name you choose (e.g., \"openai\", \"my-agent-key\", \"google-oauth-agent\") that maps to the credentials needed for a specific agent or service.<ul> <li>It often corresponds to the <code>authSchemes[].service_identifier</code> field in an Agent Card.</li> <li>If the Agent Card omits <code>service_identifier</code>, the client might default to using the agent's <code>humanReadableId</code> or require the user/developer to specify which local <code>service_id</code> to use (e.g., via <code>agentvault_cli run --key-service &lt;your_local_id&gt;</code>).</li> </ul> </li> <li>Storage Conventions:<ul> <li>Environment Variables:<ul> <li>API Key: <code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code></li> </ul> </li> <li><code>.env</code> File:<ul> <li>API Key: <code>&lt;service_id_lower&gt;=your_api_key</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_ID=your_client_id</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_SECRET=your_client_secret</code></li> </ul> </li> <li><code>.json</code> File: <pre><code>{\n  \"service_id_lower\": \"your_api_key\",\n  \"another_service\": {\n    \"apiKey\": \"another_api_key\",\n    \"oauth\": {\n      \"clientId\": \"oauth_client_id\",\n      \"clientSecret\": \"oauth_client_secret\"\n    }\n  }\n}\n</code></pre></li> <li>OS Keyring: Uses specific service/username conventions (see <code>key_manager.py</code> source for details, e.g., service=<code>agentvault:oauth:&lt;norm_id&gt;</code>, username=<code>clientId</code>). Use <code>agentvault_cli config set &lt;service_id&gt; --keyring</code> or <code>--oauth-configure</code> to store securely.</li> </ul> </li> <li>Retrieving Credentials: <pre><code>km = KeyManager(use_keyring=True) # Example instance\n\n# Get API Key (returns None if not found)\napi_key = km.get_key(\"openai\")\nif api_key:\n    source = km.get_key_source(\"openai\") # 'env', 'file', 'keyring', or None\n    print(f\"Found OpenAI API Key (Source: {source})\")\n\n# Get OAuth Credentials (return None if not found or incomplete)\nclient_id = km.get_oauth_client_id(\"google-oauth-agent\")\nclient_secret = km.get_oauth_client_secret(\"google-oauth-agent\")\nif client_id and client_secret:\n    status = km.get_oauth_config_status(\"google-oauth-agent\")\n    print(f\"Found Google OAuth Credentials ({status})\")\n    print(f\"  Client ID: {client_id}\")\n    # Note: AgentVaultClient uses these to automatically fetch the Bearer token.\n</code></pre></li> <li>Storing Credentials (Primarily for CLI/Setup): <pre><code>from agentvault import KeyManagementError\n\nkm = KeyManager(use_keyring=True)\ntry:\n    # Store API Key securely in OS keyring\n    km.set_key_in_keyring(\"my-new-service\", \"sk-abc...\")\n    print(\"API Key stored successfully.\")\n\n    # Store OAuth creds securely in OS keyring\n    km.set_oauth_creds_in_keyring(\"my-oauth-service\", \"client_id_123\", \"client_secret_xyz\")\n    print(\"OAuth credentials stored successfully.\")\n\nexcept KeyManagementError as e:\n    # Handle cases where keyring is unavailable or write fails\n    print(f\"Failed to store credentials in keyring: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid input for storing credentials: {e}\")\n</code></pre></li> </ul>"},{"location":"developer_guide/library/#agentvaultclient-clientpy","title":"<code>AgentVaultClient</code> (<code>client.py</code>)","text":"<p>The primary class for making asynchronous A2A calls to remote agents.</p> <ul> <li>Purpose: Handles HTTP requests (using <code>httpx</code>), authentication logic (including OAuth2 Client Credentials token fetching/caching), JSON-RPC formatting, SSE streaming, and response parsing according to the A2A Profile v0.2.</li> <li> <p>Usage: Best used as an async context manager (<code>async with</code>) to ensure the underlying HTTP client is properly closed. Requires an <code>AgentCard</code> instance (loaded via <code>agent_card_utils</code>) and a <code>KeyManager</code> instance for authentication.</p> <pre><code>import asyncio\nimport logging\nimport pathlib\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, TextPart,\n    agent_card_utils, exceptions as av_exceptions, models as av_models\n)\n\n# Configure logging for visibility\nlogging.basicConfig(level=logging.INFO)\n\nasync def run_agent_task(agent_ref: str, input_text: str):\n    # Initialize KeyManager - typically done once per application\n    key_manager = KeyManager(use_keyring=True)\n    agent_card = None\n    task_id = None\n\n    try:\n        # --- 1. Load Agent Card ---\n        print(f\"Loading agent card: {agent_ref}\")\n        # (Simplified loading logic - see previous version for URL/File/ID handling)\n        agent_card = await agent_card_utils.fetch_agent_card_from_url(agent_ref) # Example URL load\n\n        if not agent_card:\n             print(f\"Error: Could not load agent card for {agent_ref}\")\n             return\n        print(f\"Loaded Agent: {agent_card.name}\")\n\n        # --- 2. Prepare Initial Message ---\n        initial_message = Message(role=\"user\", parts=[TextPart(content=input_text)])\n        mcp_data = {\"user_preference\": \"verbose\"} # Optional MCP context\n\n        # --- 3. Interact using AgentVaultClient ---\n        async with AgentVaultClient() as client:\n            # Initiate the task\n            # AgentVaultClient automatically handles authentication (apiKey or oauth2)\n            # based on agent_card.authSchemes and credentials from key_manager.\n            print(f\"Initiating task...\")\n            task_id = await client.initiate_task(\n                agent_card=agent_card,\n                initial_message=initial_message,\n                key_manager=key_manager,\n                mcp_context=mcp_data,\n            )\n            print(f\"Task initiated: {task_id}\")\n\n            # Stream and process events\n            print(\"Streaming events...\")\n            final_response_text = \"\"\n            async for event in client.receive_messages(\n                agent_card=agent_card, task_id=task_id, key_manager=key_manager\n            ):\n                if isinstance(event, av_models.TaskStatusUpdateEvent):\n                    print(f\"  Status Update: {event.state} \"\n                          f\"(Msg: {event.message or 'N/A'})\")\n                    if event.state in [av_models.TaskState.COMPLETED,\n                                       av_models.TaskState.FAILED,\n                                       av_models.TaskState.CANCELED]:\n                        print(\"  Terminal state reached.\")\n                        break\n                elif isinstance(event, av_models.TaskMessageEvent):\n                    print(f\"  Message Received (Role: {event.message.role}):\")\n                    for part in event.message.parts:\n                        if isinstance(part, TextPart):\n                            print(f\"    Text: {part.content}\")\n                            if event.message.role == \"assistant\":\n                                final_response_text += part.content + \"\\n\"\n                        # --- ADDED: Example handling other part types ---\n                        elif isinstance(part, av_models.FilePart):\n                            print(f\"    File Ref: {part.url} (Type: {part.media_type}, Name: {part.filename})\")\n                        elif isinstance(part, av_models.DataPart):\n                            print(f\"    Data (Type: {part.media_type}): {part.content}\")\n                        # --- END ADDED ---\n                        else:\n                            print(f\"    Part (Type: {getattr(part, 'type', 'Unknown')}): {part}\")\n                elif isinstance(event, av_models.TaskArtifactUpdateEvent):\n                     artifact = event.artifact\n                     print(f\"  Artifact Update (ID: {artifact.id}, Type: {artifact.type}):\")\n                     if artifact.url: print(f\"    URL: {artifact.url}\")\n                     if artifact.media_type: print(f\"    Media Type: {artifact.media_type}\")\n                     # Handle content display/saving based on size/type\n                     if artifact.content:\n                         content_repr = repr(artifact.content)\n                         print(f\"    Content: {content_repr[:100]}{'...' if len(content_repr) &gt; 100 else ''}\")\n                     else:\n                         print(\"    Content: [Not provided directly]\")\n                # --- ADDED: Handling potential error events within stream ---\n                # Note: A2ARemoteAgentError might also be raised by receive_messages\n                # if the stream itself returns an error status initially.\n                elif isinstance(event, dict) and event.get(\"error\"): # Check for error structure\n                     print(f\"  ERROR received via SSE stream: {event}\")\n                     # Decide how to handle stream errors (e.g., break, log, append to response)\n                     final_response_text += f\"\\n[Stream Error: {event.get('message', 'Unknown')}]\"\n                     break # Example: Stop processing on stream error\n                # --- END ADDED ---\n                else:\n                    print(f\"  Received unknown event type: {type(event)}\")\n\n            print(\"\\n--- Final Aggregated Agent Response ---\")\n            print(final_response_text.strip())\n            print(\"---------------------------------------\")\n\n    # --- 5. Handle Potential Errors ---\n    except av_exceptions.AgentCardError as e:\n        print(f\"Error loading or validating agent card: {e}\")\n    except av_exceptions.A2AAuthenticationError as e:\n        print(f\"Authentication error: {e}\")\n        print(\"Hint: Ensure credentials for the required service_id are configured.\")\n    except av_exceptions.A2AConnectionError as e:\n        print(f\"Connection error communicating with agent or token endpoint: {e}\")\n    except av_exceptions.A2ARemoteAgentError as e:\n        # Agent returned an error (e.g., JSON-RPC error or non-2xx HTTP status)\n        print(f\"Agent returned an error:\")\n        print(f\"  Status Code (if HTTP/RPC error): {e.status_code}\") # Can be HTTP status or RPC code\n        print(f\"  Message: {e}\")\n        print(f\"  Response Body/Data: {e.response_body}\") # Contains JSON RPC error data or HTTP body\n    except av_exceptions.A2AMessageError as e:\n         print(f\"A2A protocol message error (e.g., invalid format): {e}\")\n    except av_exceptions.A2ATimeoutError as e:\n         print(f\"A2A request timed out: {e}\")\n    except av_exceptions.KeyManagementError as e:\n         print(f\"Error managing local keys/credentials: {e}\")\n    except NotImplementedError as e:\n         print(f\"Functionality not implemented: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {type(e).__name__}: {e}\")\n        logging.exception(\"Unexpected error details:\")\n\n# Example usage:\n# asyncio.run(run_agent_task(\"https://some-agent.com/agent-card.json\", \"Summarize this document.\"))\n</code></pre> </li> </ul>"},{"location":"developer_guide/library/#models-agentvaultmodels","title":"Models (<code>agentvault.models</code>)","text":"<p>Pydantic models defining the data structures for Agent Cards and the A2A protocol. Refer to the source code docstrings or the A2A Profile v0.2 for details on specific models like <code>AgentCard</code>, <code>Message</code>, <code>Task</code>, <code>TaskState</code>, <code>A2AEvent</code>, etc.</p>"},{"location":"developer_guide/library/#exceptions-agentvaultexceptions","title":"Exceptions (<code>agentvault.exceptions</code>)","text":"<p>Custom exceptions provide granular error handling. Catching these allows for more robust client applications.</p> <ul> <li><code>AgentCardError</code>: Issues loading/validating the Agent Card.</li> <li><code>A2AAuthenticationError</code>: Missing/invalid credentials, OAuth flow failures. Check KeyManager setup.</li> <li><code>A2AConnectionError</code>: Network issues connecting to the agent or token endpoint (DNS, connection refused).</li> <li><code>A2ATimeoutError</code>: Request timed out.</li> <li><code>A2ARemoteAgentError</code>: The agent returned an error. Check <code>e.status_code</code> (can be HTTP status or JSON-RPC error code) and <code>e.response_body</code> (can be HTTP response text or JSON-RPC error data) for details from the agent.</li> <li><code>A2AMessageError</code>: Invalid JSON-RPC format or unexpected response structure from the agent.</li> <li><code>KeyManagementError</code>: Issues saving/loading keys with <code>KeyManager</code>.</li> </ul> <p>See the example above for a basic <code>try...except</code> block structure.</p>"},{"location":"developer_guide/library/#utilities-agentvaultagent_card_utils-agentvaultmcp_utils","title":"Utilities (<code>agentvault.agent_card_utils</code>, <code>agentvault.mcp_utils</code>)","text":"<ul> <li><code>agent_card_utils</code>: Functions like <code>load_agent_card_from_file</code> and <code>fetch_agent_card_from_url</code> simplify obtaining and validating <code>AgentCard</code> objects.</li> <li><code>mcp_utils</code>: Contains helpers for handling Model Context Protocol data.<ul> <li><code>format_mcp_context</code>: (Primarily for advanced clients or server-side) Validates and formats a dictionary intended as MCP context.</li> <li><code>get_mcp_context</code>: (Client-side) Safely extracts the <code>mcp_context</code> dictionary from a received <code>Message</code>'s metadata.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/","title":"Developer Guide: Registry API (<code>agentvault_registry</code>)","text":"<p>The AgentVault Registry provides a central RESTful API service and Web UI for discovering and managing Agent Cards. Developers interact with it programmatically or via the UI to publish their agents, while clients (like the <code>agentvault_cli</code> or other applications) use it to find agents.</p> <ul> <li>Public Registry &amp; UI: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Public Discovery UI: <code>/ui</code></li> <li>Developer Portal UI: <code>/ui/developer</code></li> <li>API Base Path: <code>/api/v1</code></li> </ul> <p>(Note: The public instance runs on a free tier and may experience cold starts taking up to 60 seconds for the first request after inactivity.)</p>"},{"location":"developer_guide/registry/#authentication-developer-registration","title":"Authentication &amp; Developer Registration","text":"<p>Interacting with the registry requires different levels of authentication:</p> <ol> <li>Public Access: Discovering agents (<code>GET /api/v1/agent-cards/</code>, <code>GET /api/v1/agent-cards/{card_id}</code>, <code>GET /api/v1/agent-cards/id/{human_readable_id}</code>) and validating card data (<code>POST /api/v1/utils/validate-card</code>) are generally public and do not require authentication.</li> <li>Developer Account Authentication (JWT): Managing your own agent cards (create, update, deactivate), managing programmatic API keys, and using the agent builder requires you to be logged in as a registered developer. This uses email/password authentication via the <code>/auth/login</code> endpoint, which returns a JSON Web Token (JWT). Subsequent requests to protected developer endpoints must include this JWT in the <code>Authorization: Bearer &lt;token&gt;</code> HTTP header.</li> <li>Programmatic API Key Authentication: For automated scripts or CI/CD pipelines interacting with the registry API (e.g., to update an agent card automatically), developers can generate programmatic API keys. These keys are sent in the <code>X-Api-Key</code> HTTP header for specific authenticated endpoints (primarily intended for agent card management, though JWT is preferred for user-driven actions).</li> </ol> <p>Registration Workflow:</p> <ul> <li>Self-Registration: Developers can register via the <code>/ui/register</code> page or the <code>POST /auth/register</code> API endpoint.</li> <li>Required Information: Name, Email, Password.</li> <li>Verification: Upon registration, a verification email is sent to the provided address. The developer must click the link in the email to activate their account (<code>GET /auth/verify-email</code>). Unverified accounts cannot log in.</li> <li>Recovery Keys: During registration, a set of single-use recovery keys are generated and displayed only once. These keys are essential for regaining account access if the password is lost and email reset is unavailable. Store these keys securely offline.</li> <li>Password Reset: A password reset can be requested via email (if email sending is configured on the registry instance) using the <code>/ui/forgot-password</code> page or <code>POST /auth/request-password-reset</code> endpoint. Alternatively, account access can be regained using a recovery key via the <code>/ui/recover-with-key</code> page or <code>POST /auth/recover-account</code> endpoint, which provides a temporary token to set a new password via <code>/ui/set-new-password</code> or <code>POST /auth/set-new-password</code>. Using a recovery key invalidates it.</li> </ul>"},{"location":"developer_guide/registry/#api-endpoints","title":"API Endpoints","text":"<p>(Refer to the OpenAPI documentation at <code>/docs</code> or <code>/redoc</code> on the running registry instance for full details, request/response schemas, and interactive testing.)</p>"},{"location":"developer_guide/registry/#authentication-auth","title":"Authentication (<code>/auth</code>)","text":"<p>Handles developer registration, login, email verification, and password/account recovery.</p> <ul> <li><code>POST /register</code>: Creates a new developer account. Requires name, email, password. Returns a success message and one-time recovery keys. Triggers verification email.</li> <li><code>POST /login</code>: Authenticates using email/password (sent as form data). Returns a JWT <code>access_token</code> (<code>schemas.Token</code>). Requires verified email.</li> <li><code>GET /verify-email</code>: Endpoint visited via the link in the verification email. Activates the developer account. Redirects user to success/failure UI pages.</li> <li><code>POST /request-password-reset</code>: (Placeholder/Future) Sends a password reset link to the developer's email.</li> <li><code>POST /reset-password</code>: (Placeholder/Future) Sets a new password using a token from the reset email.</li> <li><code>POST /recover-account</code>: Verifies email and a recovery key. Returns a short-lived JWT (<code>schemas.Token</code>) specifically for setting a new password.</li> <li><code>POST /set-new-password</code>: Sets a new password using the temporary token from <code>/recover-account</code>. Requires <code>Authorization: Bearer &lt;temp_token&gt;</code> header and <code>{\"new_password\": \"...\"}</code> body. Invalidates the used recovery key hash.</li> </ul>"},{"location":"developer_guide/registry/#developers-developers","title":"Developers (<code>/developers</code>)","text":"<p>Endpoints for managing the authenticated developer's own account and resources. Requires JWT authentication (<code>Authorization: Bearer &lt;token&gt;</code>).</p> <ul> <li><code>GET /me</code>: Returns the profile information (<code>schemas.DeveloperRead</code>) for the currently authenticated developer.</li> <li><code>POST /me/apikeys</code>: Generates a new programmatic API key (prefixed <code>avreg_</code>) associated with the developer. Optionally takes a <code>description</code> in the request body. Returns the plain text key once along with key metadata (<code>schemas.NewApiKeyResponse</code>).</li> <li><code>GET /me/apikeys</code>: Lists metadata (<code>schemas.ApiKeyRead</code>) for all active programmatic API keys belonging to the developer.</li> <li><code>DELETE /me/apikeys/{key_id}</code>: Deactivates (soft deletes) a specific programmatic API key by its integer <code>key_id</code>. Returns <code>204 No Content</code> on success.</li> </ul>"},{"location":"developer_guide/registry/#agent-cards-apiv1agent-cards","title":"Agent Cards (<code>/api/v1/agent-cards</code>)","text":"<p>Endpoints for managing and discovering Agent Cards.</p> <ul> <li><code>POST /</code>:<ul> <li>Summary: Submit a new Agent Card.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentCardCreate</code> (contains the <code>card_data</code> dictionary).</li> <li>Response: <code>schemas.AgentCardRead</code> (includes generated UUID, timestamps, <code>developer_is_verified</code> status).</li> <li>Notes: Validates <code>card_data</code>. Extracts <code>name</code>/<code>description</code> for indexing.</li> </ul> </li> <li><code>GET /</code>:<ul> <li>Summary: List Agent Cards (Summaries).</li> <li>Auth: Public, unless <code>owned_only=true</code> is used (requires JWT).</li> <li>Query Params: <code>skip</code>, <code>limit</code>, <code>active_only</code>, <code>search</code>, <code>tags</code>, <code>has_tee</code>, <code>tee_type</code>, <code>owned_only</code>.</li> <li>Response: <code>schemas.AgentCardListResponse</code> (contains <code>items: List[AgentCardSummary]</code> and <code>pagination: PaginationInfo</code>).</li> </ul> </li> <li><code>GET /{card_id}</code>:<ul> <li>Summary: Get Agent Card by UUID.</li> <li>Auth: Public.</li> <li>Response: <code>schemas.AgentCardRead</code> (full card details, including <code>developer_is_verified</code>).</li> </ul> </li> <li><code>GET /id/{human_readable_id:path}</code>:<ul> <li>Summary: Get Agent Card by Human-Readable ID.</li> <li>Auth: Public.</li> <li>Path Param: <code>human_readable_id</code> (e.g., <code>my-org/my-agent</code>). The <code>:path</code> allows slashes.</li> <li>Response: <code>schemas.AgentCardRead</code>.</li> </ul> </li> <li><code>PUT /{card_id}</code>:<ul> <li>Summary: Update an Agent Card.</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Request Body: <code>schemas.AgentCardUpdate</code> (can contain <code>card_data</code> and/or <code>is_active</code>). If <code>card_data</code> is present, it replaces the existing card data after validation.</li> <li>Response: <code>schemas.AgentCardRead</code> (updated card details).</li> </ul> </li> <li><code>DELETE /{card_id}</code>:<ul> <li>Summary: Deactivate an Agent Card (Soft Delete).</li> <li>Auth: Requires JWT authentication; developer must own the card.</li> <li>Response: <code>204 No Content</code>.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#agent-builder-agent-builder","title":"Agent Builder (<code>/agent-builder</code>)","text":"<p>Endpoint for generating agent boilerplate code.</p> <ul> <li><code>POST /generate</code>:<ul> <li>Summary: Generate Agent Package.</li> <li>Auth: Requires JWT authentication.</li> <li>Request Body: <code>schemas.AgentBuildConfig</code> (specifies agent name, description, type, backend details, etc.).</li> <li>Response: <code>200 OK</code> with <code>Content-Type: application/zip</code>. The response body is a downloadable ZIP archive containing the generated agent project structure (source code, Dockerfile, config files).</li> <li>Errors: 422 (invalid build config), 500 (generation error).</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#utilities-apiv1utils","title":"Utilities (<code>/api/v1/utils</code>)","text":"<p>Helper endpoints.</p> <ul> <li><code>POST /validate-card</code>:<ul> <li>Summary: Validate Agent Card Data.</li> <li>Auth: Public.</li> <li>Request Body: <code>schemas.AgentCardValidationRequest</code>.</li> <li>Response: <code>schemas.AgentCardValidationResponse</code> (indicates validity and provides details on errors).</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/#common-error-responses","title":"Common Error Responses","text":"<p>(See previous version or main documentation - standard HTTP codes like 401, 403, 404, 422, 500)</p>"},{"location":"developer_guide/server_sdk/","title":"Developer Guide: Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>The <code>agentvault-server-sdk</code> provides tools and abstractions to simplify the development of A2A-compliant agent servers in Python, particularly when using the FastAPI web framework. It helps you focus on your agent's core logic while the SDK handles much of the A2A protocol boilerplate.</p>"},{"location":"developer_guide/server_sdk/#installation","title":"Installation","text":"<p>Install the SDK from PyPI:</p> <p><pre><code>pip install agentvault-server-sdk\n</code></pre> (Note: This automatically installs the <code>agentvault</code> client library as a dependency).</p> <p>See the main Installation Guide for more details, including setting up a development environment to run from source.</p>"},{"location":"developer_guide/server_sdk/#core-concepts","title":"Core Concepts","text":"<p>The SDK revolves around implementing an agent logic class (inheriting from <code>BaseA2AAgent</code>) and integrating it with a web framework (currently FastAPI).</p>"},{"location":"developer_guide/server_sdk/#1-basea2aagent-agentpy","title":"1. <code>BaseA2AAgent</code> (<code>agent.py</code>)","text":"<p>This is the abstract base class your agent logic should inherit from.</p> <ul> <li>Purpose: Defines the standard interface the A2A protocol expects an agent server to fulfill.</li> <li>Required Methods: If you are not using the <code>@a2a_method</code> decorator for all standard methods, you must implement these <code>async</code> methods in your subclass:<ul> <li><code>handle_task_send(task_id: Optional[str], message: Message) -&gt; str</code>: Processes incoming messages (<code>tasks/send</code> JSON-RPC method). Should handle task creation or updates and return the task ID.</li> <li><code>handle_task_get(task_id: str) -&gt; Task</code>: Retrieves the full state (<code>Task</code> model) of a specific task (<code>tasks/get</code> JSON-RPC method).</li> <li><code>handle_task_cancel(task_id: str) -&gt; bool</code>: Attempts to cancel a task (<code>tasks/cancel</code> JSON-RPC method), returning <code>True</code> if the request is accepted.</li> <li><code>handle_subscribe_request(task_id: str) -&gt; AsyncGenerator[A2AEvent, None]</code>: Returns an async generator yielding <code>A2AEvent</code> objects for SSE streaming (<code>tasks/sendSubscribe</code> JSON-RPC method). The SDK router consumes this generator.</li> </ul> </li> <li>Alternative (<code>@a2a_method</code>): For agents handling only specific or custom methods, or if you prefer a decorator-based approach, you can use the <code>@a2a_method</code> decorator on individual methods instead of implementing all <code>handle_...</code> methods (see below).</li> </ul>"},{"location":"developer_guide/server_sdk/#2-task-state-management-statepy","title":"2. Task State Management (<code>state.py</code>)","text":"<p>Handling asynchronous tasks requires managing their state (Submitted, Working, Completed, etc.) and potentially associated data (messages, artifacts). The SDK provides tools for this.</p> <ul> <li><code>TaskContext</code>: A basic dataclass holding <code>task_id</code>, <code>current_state</code>, <code>created_at</code>, <code>updated_at</code>. You can subclass this to store agent-specific task data.     <pre><code># Example of extending TaskContext\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom agentvault.models import Message, Artifact\nfrom agentvault_server_sdk.state import TaskContext\n\n@dataclass\nclass MyAgentTaskContext(TaskContext):\n    conversation_history: List[Message] = field(default_factory=list)\n    generated_artifacts: List[Artifact] = field(default_factory=list)\n    # Add other fields your agent needs to track per task\n</code></pre></li> <li><code>BaseTaskStore</code>: An abstract base class defining the interface for storing, retrieving, updating, and deleting <code>TaskContext</code> objects (e.g., <code>create_task</code>, <code>get_task</code>, <code>update_task_state</code>, <code>delete_task</code>). It also defines the interface for managing SSE event listeners (<code>add_listener</code>, <code>remove_listener</code>) and notifying them (<code>notify_status_update</code>, <code>notify_message_event</code>, <code>notify_artifact_event</code>).</li> <li><code>InMemoryTaskStore</code>: A simple, non-persistent dictionary-based implementation of <code>BaseTaskStore</code>. Suitable only for development or single-instance agents where task state loss on restart is acceptable. Production agents typically require implementing a custom <code>BaseTaskStore</code> backed by a persistent database (SQL, NoSQL) or a distributed cache (Redis).</li> <li>Notification Helpers: When using a <code>BaseTaskStore</code> implementation (like <code>InMemoryTaskStore</code> or your own), your agent logic (e.g., background processing tasks) should call methods like <code>task_store.notify_status_update(...)</code>, <code>task_store.notify_message_event(...)</code>, <code>task_store.notify_artifact_event(...)</code> whenever a relevant event occurs (e.g., state change, message generation, artifact creation). The <code>create_a2a_router</code> integration uses these notifications to automatically format and send the correct SSE events to subscribed clients via the <code>handle_subscribe_request</code> stream.</li> </ul>"},{"location":"developer_guide/server_sdk/#3-fastapi-integration-fastapi_integrationpy","title":"3. FastAPI Integration (<code>fastapi_integration.py</code>)","text":"<p>The <code>create_a2a_router</code> function bridges your agent logic (either a <code>BaseA2AAgent</code> subclass or a class using <code>@a2a_method</code>) with the FastAPI web framework.</p> <ul> <li>Purpose: Creates a FastAPI <code>APIRouter</code> that automatically exposes the standard A2A JSON-RPC methods (<code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>) and routes them to your agent implementation's corresponding <code>handle_...</code> methods or decorated methods. It also handles JSON-RPC request parsing, basic validation, and SSE stream setup.</li> <li>Authentication: Note that authentication (e.g., checking <code>X-Api-Key</code> or <code>Authorization</code> headers) is typically handled before the request reaches the A2A router, usually via FastAPI Dependencies applied to the router or the main app. The SDK router itself does not perform authentication checks.</li> <li> <p>Usage: The following steps outline how to integrate the router into your FastAPI application:</p> <ol> <li> <p>Instantiate Agent and Task Store: <pre><code>from fastapi import FastAPI\nfrom agentvault_server_sdk import BaseA2AAgent\nfrom agentvault_server_sdk.state import InMemoryTaskStore # Or your custom store\n# Import your agent class\nfrom my_agent_logic import MyAgent\n\ntask_store = InMemoryTaskStore()\nmy_agent_instance = MyAgent(task_store_ref=task_store) # Pass store if needed\n</code></pre></p> </li> <li> <p>Create the A2A Router: Pass the agent instance and the task store to the factory function.     <pre><code>from agentvault_server_sdk import create_a2a_router\n\na2a_router = create_a2a_router(\n    agent=my_agent_instance,\n    task_store=task_store # Required for SSE notifications\n)\n</code></pre></p> </li> <li> <p>Create FastAPI App and Include Router: Mount the router at your desired prefix (typically <code>/a2a</code>).     <pre><code>app = FastAPI(title=\"My A2A Agent\")\napp.include_router(a2a_router, prefix=\"/a2a\") # Mount at standard /a2a path\n</code></pre></p> </li> <li> <p>Add Exception Handlers (CRITICAL): You must add the SDK's exception handlers to your main FastAPI <code>app</code> instance. These handlers translate internal Python exceptions raised by your agent or the SDK (like <code>TaskNotFoundError</code>, <code>ValueError</code>, <code>AgentServerError</code>) into correctly formatted JSON-RPC error responses that clients expect. Without these, clients will receive generic HTTP 500 errors instead of specific, actionable JSON-RPC errors.     <pre><code>from fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError as PydanticValidationError\n# from pydantic_core import ValidationError as PydanticValidationError # If using Pydantic v2\nfrom agentvault_server_sdk.exceptions import AgentServerError, TaskNotFoundError\nfrom agentvault_server_sdk.fastapi_integration import (\n    task_not_found_handler, validation_exception_handler,\n    agent_server_error_handler, generic_exception_handler\n)\n\n# Assuming 'app' is your FastAPI instance from step 3\napp.add_exception_handler(TaskNotFoundError, task_not_found_handler)\napp.add_exception_handler(ValueError, validation_exception_handler)\napp.add_exception_handler(TypeError, validation_exception_handler)\napp.add_exception_handler(PydanticValidationError, validation_exception_handler)\napp.add_exception_handler(AgentServerError, agent_server_error_handler)\napp.add_exception_handler(Exception, generic_exception_handler) # Catch-all\n</code></pre></p> </li> </ol> </li> </ul>"},{"location":"developer_guide/server_sdk/#4-a2a-method-decorator-a2a_method","title":"4. A2A Method Decorator (<code>@a2a_method</code>)","text":"<p>An alternative or supplement to implementing the full <code>BaseA2AAgent</code> interface.</p> <ul> <li>Purpose: Expose individual <code>async def</code> methods within your agent class as specific JSON-RPC methods. Useful for simpler agents, custom methods beyond the standard A2A set, or overriding specific standard methods with custom logic.</li> <li>Usage: <pre><code>from agentvault_server_sdk import BaseA2AAgent, a2a_method\nfrom agentvault.models import Task # Example import\n\nclass DecoratedAgent(BaseA2AAgent): # Still inherit for structure\n\n    @a2a_method(\"custom/ping\")\n    async def ping_handler(self) -&gt; str:\n        # No parameters needed\n        return \"pong\"\n\n    @a2a_method(\"tasks/get\") # Override standard method\n    async def custom_get_task(self, task_id: str) -&gt; Task: # Params validated from type hints\n        # ... custom logic to fetch task ...\n        task_data = await get_my_task_data(task_id)\n        # Return value validated against type hint\n        return Task(**task_data)\n\n    # If using only decorators for standard methods, you don't *need*\n    # to implement the corresponding handle_ methods. The router will\n    # prioritize decorated methods and return \"Method not found\" for others.\n</code></pre></li> <li>Validation: The <code>create_a2a_router</code> automatically validates incoming JSON-RPC <code>params</code> against the decorated function's type hints (using Pydantic internally). If validation fails (e.g., client sends wrong type for <code>task_id</code>), a <code>ValueError</code> or <code>PydanticValidationError</code> will likely be raised, which should be caught by the <code>validation_exception_handler</code> registered on the FastAPI app, returning a JSON-RPC <code>Invalid Params</code> error. The return value is also validated against the function's return type hint.</li> </ul>"},{"location":"developer_guide/server_sdk/#5-packaging-tool-agentvault-sdk-package-packagerclipy","title":"5. Packaging Tool (<code>agentvault-sdk package</code>) (<code>packager/cli.py</code>)","text":"<p>A CLI tool to help prepare your agent project for deployment, typically via Docker.</p> <ul> <li>Command: <code>agentvault-sdk package [OPTIONS]</code></li> <li>Functionality: Generates a standard multi-stage <code>Dockerfile</code>, a <code>.dockerignore</code> file, and copies <code>requirements.txt</code> and optionally <code>agent-card.json</code> to a specified output directory, ready for <code>docker build</code>.</li> <li>Key Options:<ul> <li><code>--output-dir DIRECTORY</code> / <code>-o DIRECTORY</code>: (Required) Directory to write Dockerfile and other artifacts.</li> <li><code>--entrypoint TEXT</code>: (Required) Python import path to the FastAPI app instance (e.g., <code>my_agent.main:app</code>).</li> <li><code>--python TEXT</code>: Python version for the base image tag (e.g., 3.10, 3.11). [default: 3.11]</li> <li><code>--suffix TEXT</code>: Suffix for the python base image (e.g., slim-bookworm, alpine). [default: slim-bookworm]</li> <li><code>--port INTEGER</code>: Port the application will listen on inside the container. [default: 8000]</li> <li><code>--requirements PATH</code> / <code>-r PATH</code>: Path to the requirements.txt file. If not provided, it looks for <code>./requirements.txt</code> in the current directory and copies it if found. Issues a warning if the SDK dependency seems missing.</li> <li><code>--agent-card PATH</code> / <code>-c PATH</code>: Path to the agent-card.json file. If provided, it will be copied into the output directory.</li> <li><code>--app-dir TEXT</code>: Directory inside the container where the application code will reside. [default: /app]</li> </ul> </li> <li>Example: <pre><code># Assuming FastAPI app is in src/my_agent/main.py as 'app'\n# and requirements.txt / agent-card.json are in the current directory\nagentvault-sdk package \\\n    --output-dir ./build \\\n    --entrypoint my_agent.main:app \\\n    --requirements ./requirements.txt \\\n    --agent-card ./agent-card.json \\\n    --python 3.11\n\n# Then build the image from the project root:\n# docker build -t my-agent-image:latest -f ./build/Dockerfile .\n</code></pre></li> </ul>"},{"location":"developer_guide/server_sdk/#building-a-basic-agent-conceptual-steps","title":"Building a Basic Agent (Conceptual Steps)","text":"<ol> <li>Define Agent Logic: Create a class inheriting from <code>BaseA2AAgent</code> (or use decorators).</li> <li>Implement Handlers/Methods: Implement the required <code>async handle_...</code> methods (or decorate specific methods) to handle A2A requests.</li> <li>Manage State: Choose or implement a <code>BaseTaskStore</code> (start with <code>InMemoryTaskStore</code> for development). Pass it to your agent instance. Crucially, call <code>task_store.notify_...</code> methods from your agent's background processing logic (e.g., the code handling the actual work initiated by <code>handle_task_send</code>) to send SSE updates to subscribed clients.</li> <li>Create FastAPI App: Set up a standard FastAPI application (<code>main.py</code>).</li> <li>Instantiate Agent &amp; Store: Create instances of your agent class and task store.</li> <li>Create &amp; Include Router: Use <code>create_a2a_router(agent=..., task_store=...)</code> and include the returned router in your FastAPI app (e.g., at prefix <code>/a2a</code>).</li> <li>Add Exception Handlers: Add the required SDK exception handlers (<code>task_not_found_handler</code>, etc.) to your main FastAPI app instance using <code>app.add_exception_handler(...)</code>.</li> <li>Create Agent Card: Write an <code>agent-card.json</code> describing your agent, ensuring the <code>url</code> points to your FastAPI A2A endpoint (e.g., <code>http://your-host/a2a</code>). Include appropriate <code>authSchemes</code>.</li> <li>Run: Use <code>uvicorn main:app --host ... --port ...</code>.</li> <li>(Optional) Package: Use <code>agentvault-sdk package</code> to generate Docker artifacts for deployment.</li> </ol> <p>Refer to the Basic A2A Server Example for a complete, runnable implementation.</p>"},{"location":"developer_guide/testing/","title":"Developer Guide: Testing Utilities (<code>agentvault-testing-utils</code>)","text":"<p>The <code>agentvault-testing-utils</code> package is an internal development tool providing shared mocks, pytest fixtures, data factories, and helper functions. Its purpose is to streamline and standardize testing across the different AgentVault components (<code>agentvault_library</code>, <code>agentvault_cli</code>, <code>agentvault_registry</code>, <code>agentvault_server_sdk</code>).</p> <p>Note: This package is not intended for end-users or for distribution on PyPI. It's used within the AgentVault monorepo's development workflow.</p>"},{"location":"developer_guide/testing/#installation","title":"Installation","text":"<p>This package is installed as a development dependency when setting up the main project environment using Poetry:</p> <pre><code># From the monorepo root (AgentVault/)\npoetry install --with dev\n</code></pre>"},{"location":"developer_guide/testing/#provided-utilities","title":"Provided Utilities","text":""},{"location":"developer_guide/testing/#1-mocks-mockspy","title":"1. Mocks (<code>mocks.py</code>)","text":"<ul> <li><code>MockAgentVaultClient</code>:<ul> <li>Purpose: A mock implementation of <code>agentvault.client.AgentVaultClient</code>. Use this in tests for components that use the client library (like the CLI or potentially other agents) to simulate A2A interactions without making real network calls.</li> <li>Features:<ul> <li>Configurable return values for async methods (e.g., <code>mock_client.initiate_task_return_value = \"task-abc\"</code>).</li> <li>Configurable side effects (exceptions) for async methods (e.g., <code>mock_client.get_task_status_side_effect = A2AConnectionError(\"Mock connection failed\")</code>).</li> <li>Call recording via the <code>mock_client.call_recorder</code> attribute (an <code>unittest.mock.AsyncMock</code> instance). Use standard <code>assert_awaited_once_with</code>, <code>assert_has_calls</code>, etc. on this recorder.</li> <li>Supports async context management (<code>async with mock_client:</code>).</li> </ul> </li> <li>Example: <pre><code>import pytest\nfrom unittest.mock import call, ANY # Import ANY for flexible matching\nfrom agentvault_testing_utils.mocks import MockAgentVaultClient\nfrom agentvault.models import Task, TaskState # Assuming Task model exists\nfrom agentvault.exceptions import A2AConnectionError\n\n@pytest.mark.asyncio\nasync def test_cli_run_logic(mocker): # Assuming pytest-mock 'mocker' fixture\n    # --- Setup ---\n    mock_client = MockAgentVaultClient()\n    # Patch the location where AgentVaultClient is instantiated in the code under test\n    mocker.patch('agentvault_cli.commands.run.AgentVaultClient', return_value=mock_client)\n\n    # Configure mock behavior\n    mock_client.initiate_task_return_value = \"task-from-mock\"\n    # Create a mock Task object or use a real one if needed\n    mock_task_result = MagicMock(spec=Task)\n    mock_task_result.state = TaskState.COMPLETED\n    mock_client.get_task_status_return_value = mock_task_result\n\n    # --- Action ---\n    # Execute the function or command that uses the AgentVaultClient\n    # e.g., await run_cli_command_logic(...)\n\n    # --- Assertions ---\n    # Check initiate_task was called correctly\n    mock_client.call_recorder.initiate_task.assert_awaited_once_with(\n        agent_card=ANY, initial_message=ANY, key_manager=ANY,\n        mcp_context=None, webhook_url=None # Check default args if needed\n    )\n    # Check get_task_status was called with the ID returned by initiate_task\n    mock_client.call_recorder.get_task_status.assert_awaited_with(\n         agent_card=ANY, task_id=\"task-from-mock\", key_manager=ANY\n    )\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#2-mock-server-fixtures-mock_serverpy-fixturespy","title":"2. Mock Server &amp; Fixtures (<code>mock_server.py</code>, <code>fixtures.py</code>)","text":"<ul> <li> <p><code>mock_a2a_server</code> (Pytest Fixture):</p> <ul> <li>Purpose: Provides a more realistic testing environment by mocking the HTTP endpoints of an A2A agent server (<code>/a2a</code>) and its associated OAuth token endpoint (<code>/token</code>) using <code>respx</code>. Useful for testing the <code>AgentVaultClient</code> itself or components that make real HTTP requests to agents.</li> <li>Features:<ul> <li>Sets up <code>respx</code> routes for <code>POST /a2a</code> and <code>POST /token</code> at a test URL.</li> <li>Handles basic JSON-RPC routing for standard A2A methods (<code>tasks/send</code>, <code>get</code>, <code>cancel</code>, <code>sendSubscribe</code>).</li> <li>Simulates basic task state via an in-memory <code>task_store</code> dictionary accessible from the fixture. You can pre-populate this store in your test.</li> <li>Simulates SSE streaming for <code>tasks/sendSubscribe</code> based on an <code>sse_event_store</code> list accessible from the fixture. You pre-populate this list with the <code>A2AEvent</code> objects you want the mock server to stream back.</li> <li>Provides the <code>base_url</code> of the mock server.</li> </ul> </li> <li>Return Type: <code>MockServerInfo</code> (NamedTuple) with fields:<ul> <li><code>base_url</code> (str): The base URL of the mock server (e.g., <code>https://mock-a2a-agent.test</code>).</li> <li><code>task_store</code> (Dict[str, Dict]): Dictionary mapping task IDs to their simple state dict (e.g., <code>{'state': TaskState.WORKING}</code>).</li> <li><code>sse_event_store</code> (Dict[str, List[A2AEvent]]): Dictionary mapping task IDs to a list of <code>A2AEvent</code> objects to be yielded by the mock SSE stream.</li> </ul> </li> <li>Example: <pre><code>import pytest\nimport httpx\nfrom agentvault_testing_utils.fixtures import mock_a2a_server, MockServerInfo\n# Import necessary models\nfrom agentvault.models import TaskState, TaskStatusUpdateEvent, Message, TextPart\nfrom agentvault.client import AgentVaultClient # Import the real client\nimport datetime\n\n@pytest.mark.asyncio\nasync def test_client_get_status_against_mock_server(mock_a2a_server: MockServerInfo, mocker):\n    # --- Setup Mock Server State ---\n    task_id = \"live-test-task-get\"\n    # Pre-populate the task store the mock server will use\n    mock_a2a_server.task_store[task_id] = {\"state\": TaskState.WORKING}\n\n    # --- Action ---\n    # Use the real AgentVaultClient against the mock server's URL\n    mock_card = mocker.MagicMock() # Mock the card\n    mock_card.url = f\"{mock_a2a_server.base_url}/a2a\"\n    mock_card.auth_schemes = [] # Assume no auth for simplicity\n\n    async with AgentVaultClient() as client:\n         # This call will hit the respx route set up by the fixture\n         task_details = await client.get_task_status(\n             agent_card=mock_card,\n             task_id=task_id,\n             key_manager=mocker.MagicMock() # Mock key manager\n         )\n\n    # --- Assertions ---\n    assert task_details.id == task_id\n    assert task_details.state == TaskState.WORKING # Check state returned by mock\n</code></pre></li> </ul> </li> <li> <p><code>setup_mock_a2a_routes</code>: The underlying function used by the <code>mock_a2a_server</code> fixture to configure <code>respx</code> routes. Can be used directly for more complex or custom mock server setups outside the fixture.</p> </li> <li>JSON-RPC Helpers: <code>create_jsonrpc_success_response</code>, <code>create_jsonrpc_error_response</code> for constructing standard JSON-RPC response dictionaries in custom mock handlers.</li> </ul>"},{"location":"developer_guide/testing/#3-factories-factoriespy","title":"3. Factories (<code>factories.py</code>)","text":"<ul> <li><code>create_test_agent_card(**overrides)</code>:<ul> <li>Purpose: Generates <code>agentvault.models.AgentCard</code> Pydantic model instances with sensible default values. Simplifies creating valid test data for agent cards.</li> <li>Features: Accepts keyword arguments to override any top-level or nested field in the default card structure (uses deep merging for nested dicts). Performs validation using the actual <code>AgentCard</code> model.</li> <li>Example: <pre><code>from agentvault_testing_utils.factories import create_test_agent_card\n\n# Create a card with default values\ndefault_card = create_test_agent_card()\n\n# Create a card overriding name and adding an OAuth scheme\ncustom_card = create_test_agent_card(\n    name=\"My Custom OAuth Agent\",\n    authSchemes=[ # Overwrites the default 'none' scheme\n        {\"scheme\": \"oauth2\", \"tokenUrl\": \"https://my-agent.test/token\"}\n    ],\n    tags=[\"custom\", \"oauth\"] # Overwrites default tags\n)\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#4-test-agents-agentspy","title":"4. Test Agents (<code>agents.py</code>)","text":"<ul> <li><code>EchoAgent</code>:<ul> <li>Purpose: A minimal, functional implementation of <code>agentvault_server_sdk.BaseA2AAgent</code>. It uses an <code>InMemoryTaskStore</code> to manage state, echoes the first message content back via SSE notification, and transitions through basic states (Submitted -&gt; Working -&gt; Completed).</li> <li>Use Case: Ideal for testing the Server SDK's <code>create_a2a_router</code>, basic A2A client interactions, and SSE streaming logic without needing a complex real agent implementation. Useful for end-to-end tests of the client library or CLI against a basic functional agent.</li> <li>Example (Testing SDK Router): See the Server SDK Developer Guide or the Basic A2A Server Example.</li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#5-assertion-helpers-assertionspy","title":"5. Assertion Helpers (<code>assertions.py</code>)","text":"<ul> <li>Purpose: Provide convenient functions for asserting that specific A2A JSON-RPC calls were made, simplifying tests that interact with <code>MockAgentVaultClient</code> or <code>respx</code>.</li> <li>Key Functions:<ul> <li><code>assert_a2a_call(mock_calls, method, params_contain=None, req_id=None)</code>: Checks if any call in the provided list (<code>httpx.Request</code> list from <code>respx.calls</code> or <code>MagicMock.call_args_list</code> from <code>MockAgentVaultClient.call_recorder</code>) matches the specified JSON-RPC <code>method</code>, optional <code>req_id</code>, and optionally contains the key-value pairs in <code>params_contain</code> within its <code>params</code> object (performs a subset check).</li> <li><code>assert_a2a_sequence(mock_calls, expected_sequence)</code>: Checks if the sequence of parseable A2A calls matches the <code>expected_sequence</code> (a list of <code>(method, params_contain)</code> tuples). Ignores non-JSON-RPC calls in the list.</li> <li>Example: <pre><code>from agentvault_testing_utils.assertions import assert_a2a_call, assert_a2a_sequence\nfrom unittest.mock import call # For sequence assertion with MagicMock\n\n# --- Using MockAgentVaultClient ---\n# await mock_client.initiate_task(...)\n# await mock_client.get_task_status(task_id=\"task-123\", ...)\n\n# Assert a specific call was made (anywhere in the list)\nassert_a2a_call(\n    mock_client.call_recorder.call_args_list, # Pass the call list\n    method=\"tasks/get\",\n    params_contain={\"id\": \"task-123\"}\n)\n\n# Assert the exact sequence of calls\nexpected_seq = [\n    (\"initiate_task\", None), # Use the Python method name for MagicMock recorder\n    (\"get_task_status\", {\"task_id\": \"task-123\"}) # Use Python param names\n]\n# Note: assert_a2a_sequence expects JSON-RPC method names in the sequence definition\n# Adjust if using MagicMock recorder directly vs parsing httpx requests.\n# Example below assumes parsing logic handles method name mapping if needed.\nexpected_rpc_seq = [\n     (\"tasks/send\", None), # Assuming initiate_task maps to tasks/send\n     (\"tasks/get\", {\"id\": \"task-123\"})\n]\n# assert_a2a_sequence(mock_client.call_recorder.call_args_list, expected_rpc_seq)\n\n\n# --- Using respx ---\n# with respx.mock:\n#     # setup routes...\n#     # await http_client.post(url, json=payload1)\n#     # await http_client.post(url, json=payload2)\n\n# Assert a specific call was made\nassert_a2a_call(\n    respx.calls, # Pass the list of httpx.Request objects\n    method=\"tasks/send\",\n    params_contain={\"message\": {\"role\": \"user\"}}\n)\n\n# Assert the sequence\nexpected_respx_seq = [\n    (\"tasks/send\", {\"id\": None}),\n    (\"tasks/get\", {\"id\": \"task-abc\"})\n]\nassert_a2a_sequence(respx.calls, expected_respx_seq)\n</code></pre></li> </ul> </li> </ul>"},{"location":"examples/basic_a2a_server/","title":"AgentVault Server SDK - Basic A2A Server Example","text":"<p>This example demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/basic_a2a_server/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>main.py</code>:<ul> <li>Defines a simple <code>MySimpleAgent</code> class inheriting from <code>BaseA2AAgent</code>.</li> <li>Implements basic logic for the required A2A methods (<code>handle_task_send</code>, <code>handle_task_get</code>, <code>handle_task_cancel</code>, <code>handle_subscribe_request</code>).</li> <li>Uses the SDK's <code>create_a2a_router</code> to automatically generate the <code>/a2a</code> JSON-RPC endpoint.</li> <li>Includes necessary FastAPI exception handlers required by the router.</li> <li>Sets up a FastAPI application.</li> <li>Serves the agent's <code>agent-card.json</code> at <code>/agent-card.json</code>.</li> <li>Includes a <code>uvicorn</code> runner block.</li> </ul> </li> <li><code>agent-card.json</code>: A minimal, valid Agent Card describing this example agent.</li> </ul>"},{"location":"examples/basic_a2a_server/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/basic_a2a_server</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements. This will install the local SDK package.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This assumes the <code>agentvault-server-sdk</code> and <code>agentvault_library</code> directories are located correctly relative to this example as specified in <code>requirements.txt</code>. Adjust the <code>-e ../../...</code> paths if your structure differs.</li> </ol>"},{"location":"examples/basic_a2a_server/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <pre><code>uvicorn main:app --reload --port 8000\n</code></pre> <ul> <li><code>--reload</code>: Enables auto-reloading when code changes (useful for development).</li> <li><code>--port 8000</code>: Specifies the port to run on (matches the default <code>url</code> in <code>agent-card.json</code>).</li> </ul> <p>You should see Uvicorn startup messages indicating the server is running on <code>http://127.0.0.1:8000</code>.</p>"},{"location":"examples/basic_a2a_server/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Once the server is running, you can interact with it using the <code>agentvault-cli</code>:</p> <ol> <li> <p>Check Agent Card: Open <code>http://localhost:8000/agent-card.json</code> in your browser or use <code>curl</code> to verify the card is served correctly.</p> </li> <li> <p>Run a Task: Use the <code>agentvault run</code> command, pointing the <code>--agent</code> flag to the card URL.     <pre><code>agentvault run --agent http://localhost:8000/agent-card.json --input \"Hello SDK Agent!\"\n</code></pre></p> </li> </ol> <p>You should see output similar to this:</p> <pre><code>SUCCESS: Successfully loaded agent: SDK Basic Echo Agent (examples/simple-agent)\nINFO: Agent A2A Endpoint: http://localhost:8000/a2a\nINFO: Initiating task with agent...\nSUCCESS: Task initiated successfully. Task ID: simple-xxxxxxxx\nINFO: Waiting for events... (Press Ctrl+C to request cancellation)\nINFO: Task Status: WORKING\n\u250c Message from Assistant \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Echo: Hello SDK Agent!                                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nINFO: Task Status: COMPLETED\nINFO: Task reached terminal state.\nINFO: --------------------\nINFO: Final Task State: COMPLETED\nSUCCESS: Task completed.\n</code></pre> <p>This confirms the CLI can load the card, initiate a task via the SDK-generated router, stream the status updates and the echo message, and recognize task completion.</p>"},{"location":"examples/langchain_integration/","title":"AgentVault LangChain Integration Example","text":"<p>This directory contains a basic example demonstrating how to integrate an AgentVault A2A compliant agent as a tool within the LangChain framework.</p>"},{"location":"examples/langchain_integration/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines the necessary Python dependencies (<code>langchain-core</code>, <code>agentvault</code>, <code>httpx</code>).</li> <li><code>a2a_tool.py</code>: Contains the <code>A2AAgentTool</code> class, which inherits from LangChain's <code>BaseTool</code>. This tool handles the interaction with a remote A2A agent using the <code>agentvault</code> client library.</li> <li><code>example_usage.py</code>: A simple script showing how to instantiate and invoke the <code>A2AAgentTool</code>.</li> </ul>"},{"location":"examples/langchain_integration/#setup","title":"Setup","text":"<ol> <li> <p>Install Dependencies: Navigate to this directory (<code>examples/langchain_integration</code>) in your terminal and install the requirements. This includes installing the local <code>agentvault</code> library in editable mode.     <pre><code>pip install -r requirements.txt\n</code></pre> Note: This assumes your virtual environment is activated and you are in the correct directory. The <code>-e ../../agentvault_library</code> line installs the library from your local source tree.</p> </li> <li> <p>Configure Agent Reference: Open <code>example_usage.py</code> and modify the <code>EXAMPLE_AGENT_REF</code> variable to point to a valid agent:</p> <ul> <li>Agent ID: If using an ID from a running AgentVault Registry (e.g., <code>test-org/my-agent</code>), ensure the <code>AGENTVAULT_REGISTRY_URL</code> environment variable is set correctly or modify the default in <code>a2a_tool.py</code>.</li> <li>Agent URL: Provide the direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>Local File: Provide the path to a local <code>agent-card.json</code> file (e.g., <code>./path/to/your/agent-card.json</code>).</li> </ul> </li> <li> <p>Configure Credentials: If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are set up using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card.</p> </li> </ol>"},{"location":"examples/langchain_integration/#running-the-example","title":"Running the Example","text":"<p>Once set up, you can run the example script:</p> <pre><code>python example_usage.py\n</code></pre> <p>The script will:</p> <ol> <li>Instantiate the <code>A2AAgentTool</code>.</li> <li>Prepare the input (agent reference and text prompt).</li> <li>Invoke the tool's <code>_arun</code> method.</li> <li>The tool will internally use <code>AgentVaultClient</code> to:<ul> <li>Load the agent card.</li> <li>Initiate a task.</li> <li>Stream events (though only assistant text messages are captured in this basic example).</li> <li>Wait for the task to complete.</li> </ul> </li> <li>Print the final aggregated text response from the agent.</li> </ol> <p>Note: This example primarily demonstrates the tool's structure and integration. For it to fully succeed, you need a running A2A agent accessible at the specified <code>EXAMPLE_AGENT_REF</code> that can handle the input prompt. You can use the <code>agentvault-server-sdk</code> examples or your own agent implementation.</p>"},{"location":"examples/library_usage_example/","title":"AgentVault Library Usage Example","text":"<p>This example demonstrates how to use the core <code>agentvault</code> Python client library directly to interact with an A2A-compliant agent, without using the <code>agentvault_cli</code>.</p>"},{"location":"examples/library_usage_example/#concept","title":"Concept","text":"<p>The <code>agentvault</code> library provides the <code>AgentVaultClient</code> class, which handles the complexities of the A2A protocol (JSON-RPC, SSE, authentication via <code>KeyManager</code>). This script shows the basic workflow:</p> <ol> <li>Load the target agent's <code>AgentCard</code>.</li> <li>Instantiate <code>KeyManager</code> to handle potential authentication credentials.</li> <li>Instantiate <code>AgentVaultClient</code> (using <code>async with</code>).</li> <li>Call <code>client.initiate_task</code> to start the interaction.</li> <li>Use <code>async for event in client.receive_messages(...)</code> to stream and process events (status updates, messages, artifacts) from the agent.</li> <li>Handle potential exceptions.</li> </ol>"},{"location":"examples/library_usage_example/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Lists the <code>agentvault</code> library dependency.</li> <li><code>main.py</code>: The Python script demonstrating the library usage. It takes the agent reference and input text as command-line arguments.</li> </ul>"},{"location":"examples/library_usage_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/library_usage_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the <code>agentvault</code> library from your local source tree.</li> <li>Target Agent: By default, the script targets the Basic A2A Server example agent card URL (<code>http://localhost:8000/agent-card.json</code>). Ensure that agent is running if you use the default. You can target other agents using the <code>--agent-ref</code> argument.</li> <li>Credentials (If Needed): If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are configured using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card. The <code>KeyManager</code> within the script will automatically pick them up.</li> </ol>"},{"location":"examples/library_usage_example/#running-the-example","title":"Running the Example","text":"<p>Execute the Python script from your terminal, providing the input text:</p> <pre><code># Run against the default Basic Echo Agent (make sure it's running on port 8000)\npython main.py --input \"Hello from the library!\"\n\n# Run against a different agent (e.g., one requiring auth)\n# Ensure 'my-api-key-service' is configured via `agentvault config` if needed\n# python main.py --agent-ref \"https://some-other-agent.com/card.json\" --input \"Process this data\" --key-service \"my-api-key-service\"\n</code></pre> <p>Expected Output:</p> <p>The script will print logs indicating the steps it's taking (loading card, initiating task) and then print details for each event received from the agent via the SSE stream (status changes, messages, artifacts).</p> <pre><code>INFO:root:Loading agent card: http://localhost:8000/agent-card.json\nINFO:root:Loaded Agent: SDK Basic Echo Agent\nINFO:root:Initiating task...\nINFO:agentvault.client:Initiating task with agent: examples/simple-agent\nINFO:agentvault.client:Task successfully initiated with agent examples/simple-agent. Task ID: simple-xxxxxx\nINFO:root:Task initiated: simple-xxxxxx\nINFO:root:Streaming events...\nINFO:agentvault.client:Subscribing to events for task simple-xxxxxx on agent: examples/simple-agent\nINFO:root:  Status Update: WORKING (Msg: N/A)\nINFO:root:  Message Received (Role: assistant):\nINFO:root:    Text: Echo response for task simple-xxxxxx\nINFO:root:  Status Update: COMPLETED (Msg: N/A)\nINFO:root:  Terminal state reached.\nINFO:root:\n--- Final Aggregated Agent Response ---\nEcho response for task simple-xxxxxx\n---------------------------------------\n</code></pre>"},{"location":"examples/oauth_agent_example/","title":"AgentVault Server SDK - OAuth2 Agent Example","text":"<p>This example demonstrates how to build an A2A agent that requires OAuth2 Client Credentials authentication using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/oauth_agent_example/#components","title":"Components","text":"<ul> <li><code>.env.example</code>: Example environment variables for setting the mock Client ID and Secret the server will accept.</li> <li><code>agent-card.json</code>: Describes the agent, specifying the <code>oauth2</code> auth scheme and the <code>/token</code> endpoint URL.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>, <code>python-dotenv</code>).</li> <li><code>src/oauth_agent_example/agent.py</code>: Defines the simple <code>OAuthProtectedAgent</code> logic.</li> <li><code>src/oauth_agent_example/main.py</code>:<ul> <li>Sets up the FastAPI application.</li> <li>Includes the SDK's A2A router at <code>/a2a</code>.</li> <li>Adds a custom <code>POST /token</code> endpoint to handle the OAuth2 Client Credentials grant flow, validating against environment variables.</li> <li>Adds a FastAPI dependency (<code>verify_token</code>) using <code>HTTPBearer</code> to protect the <code>/a2a</code> router, ensuring requests have a valid mock Bearer token obtained from <code>/token</code>.</li> <li>Includes the required SDK exception handlers.</li> </ul> </li> </ul>"},{"location":"examples/oauth_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/oauth_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> <li>Configure Server Credentials:<ul> <li>Copy <code>.env.example</code> to <code>.env</code>.</li> <li>Review the <code>MOCK_CLIENT_ID</code> and <code>MOCK_CLIENT_SECRET</code> in <code>.env</code>. These are the credentials the server will expect the client to provide to the <code>/token</code> endpoint. You can change them if desired.</li> </ul> </li> </ol>"},{"location":"examples/oauth_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn. It will load the credentials from the <code>.env</code> file.</p> <p><pre><code>uvicorn src.oauth_agent_example.main:app --reload --port 8002\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8002</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint and the <code>/token</code> endpoint.</p>"},{"location":"examples/oauth_agent_example/#configuring-client-credentials","title":"Configuring Client Credentials","text":"<p>Before you can interact with this agent using <code>agentvault_cli</code>, you need to configure the client-side credentials that match the ones the server expects.</p> <ol> <li>Open a NEW terminal window/tab (keep the server running).</li> <li>Activate the AgentVault virtual environment if you haven't already (<code>source .venv/bin/activate</code> or similar).</li> <li> <p>Use <code>agentvault config set</code>: Use the <code>service_identifier</code> from <code>agent-card.json</code> (<code>example-oauth-agent</code>) and the <code>--oauth-configure</code> flag. Enter the same Client ID and Secret that are defined in the server's <code>.env</code> file when prompted.</p> <pre><code>agentvault config set example-oauth-agent --oauth-configure\n# --&gt; Enter OAuth Client ID for 'example-oauth-agent': test-client-id-123\n# --&gt; Enter OAuth Client Secret for 'example-oauth-agent': ************************\n# --&gt; Confirm OAuth Client Secret for 'example-oauth-agent': ************************\n# SUCCESS: OAuth credentials for 'example-oauth-agent' stored successfully in keyring.\n</code></pre> </li> </ol>"},{"location":"examples/oauth_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Now that the server is running and client credentials are configured, you can test the interaction:</p> <pre><code>agentvault run --agent http://localhost:8002/agent-card.json --input \"Test OAuth Auth\"\n</code></pre> <p>Expected Behavior:</p> <ol> <li>The <code>agentvault</code> client library (used by the CLI) will load the agent card.</li> <li>It sees the <code>oauth2</code> scheme and the <code>tokenUrl</code>.</li> <li>It uses the <code>KeyManager</code> to retrieve the Client ID/Secret you configured for <code>example-oauth-agent</code>.</li> <li>It makes a <code>POST</code> request to <code>http://localhost:8002/token</code> with the credentials.</li> <li>The server's <code>/token</code> endpoint validates the credentials against the <code>.env</code> file and returns a mock access token.</li> <li>The client library receives the token.</li> <li>It makes the <code>POST</code> request to <code>http://localhost:8002/a2a</code> for the <code>tasks/send</code> method, including the <code>Authorization: Bearer &lt;mock_access_token&gt;</code> header.</li> <li>The server's <code>verify_token</code> dependency validates the token.</li> <li>The SDK router calls the agent's <code>handle_task_send</code> method.</li> <li>The agent starts the task and sends back SSE events confirming authentication worked.</li> </ol> <p>You should see output similar to the Basic Echo example, but the underlying process involves the OAuth token exchange. If authentication fails (e.g., wrong client credentials configured), the <code>run</code> command will report an authentication error.</p>"},{"location":"examples/stateful_agent_example/","title":"AgentVault Server SDK - Stateful Agent Example","text":"<p>This example demonstrates how to build an A2A agent that maintains state across multiple interactions within a single task lifecycle using the <code>agentvault-server-sdk</code>.</p>"},{"location":"examples/stateful_agent_example/#concept","title":"Concept","text":"<p>Many agent tasks aren't single-shot requests but involve a conversation or a process that evolves over time. This requires the agent to:</p> <ol> <li>Store Task-Specific State: Remember information relevant to the ongoing task (e.g., conversation history, intermediate results, user preferences).</li> <li>Update State: Modify the stored state based on new messages or internal processing.</li> <li>Handle Multiple Interactions: Accept subsequent <code>tasks/send</code> requests for the same task ID and use the stored state to continue processing.</li> </ol> <p>This example implements a simple chat agent that stores the message history in memory for each task.</p>"},{"location":"examples/stateful_agent_example/#components","title":"Components","text":"<ul> <li><code>agent-card.json</code>: Describes the agent.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>src/stateful_agent_example/state.py</code>: Defines <code>ChatTaskContext</code> which inherits from the SDK's <code>TaskContext</code> and adds a <code>history</code> list to store messages.</li> <li><code>src/stateful_agent_example/agent.py</code>: Defines the <code>StatefulChatAgent</code> logic:<ul> <li>Uses <code>InMemoryTaskStore</code> to store <code>ChatTaskContext</code> instances.</li> <li><code>handle_task_send</code>: Creates a new task context on the first call, storing the initial message. For subsequent calls with the same task ID, it appends the new message to the existing context's history and signals a background processing loop using an <code>asyncio.Event</code>.</li> <li><code>_process_task</code>: A background <code>asyncio</code> task started for each new chat task. It waits for new messages (signaled via the <code>asyncio.Event</code>) and generates simple responses based on the message count.</li> <li>Other handlers (<code>get</code>, <code>cancel</code>, <code>subscribe</code>) interact with the task store.</li> </ul> </li> <li><code>src/stateful_agent_example/main.py</code>: Sets up the FastAPI application, includes the SDK's A2A router, and required exception handlers.</li> </ul>"},{"location":"examples/stateful_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/stateful_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> </ol>"},{"location":"examples/stateful_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <p><pre><code>uvicorn src.stateful_agent_example.main:app --reload --port 8003\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8003</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint.</p>"},{"location":"examples/stateful_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>You can test the stateful interaction using the <code>agentvault_cli</code>:</p> <ol> <li> <p>Initiate Task: Send the first message. Note the <code>Task ID</code> returned.     <pre><code>agentvault run --agent http://localhost:8003/agent-card.json --input \"Hello stateful agent!\"\n# --&gt; SUCCESS: Task initiated successfully. Task ID: stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: WORKING\n# --&gt; Message from Assistant: Received message 1. History length is now 1.\n# --&gt; INFO: Task Status: WORKING # (Agent waits for more input)\n# (Press Ctrl+C here or leave it running)\n</code></pre> Note: The agent stays in the <code>WORKING</code> state, waiting for more input or cancellation.</p> </li> <li> <p>Send Subsequent Message: Open a new terminal (or stop the previous <code>run</code> command with Ctrl+C if desired) and use the same Task ID obtained in step 1 to send another message.     <pre><code># Replace stateful-task-xxxxxx with the actual ID from step 1\nagentvault run --agent http://localhost:8003/agent-card.json --input \"This is the second message.\" --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task message sent successfully to task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; Message from Assistant: Received message 2. History length is now 2.\n# --&gt; INFO: Task Status: WORKING\n# (Press Ctrl+C or leave running)\n</code></pre>     The running agent (or its background task) should detect the new message and send another response via SSE.</p> </li> <li> <p>(Optional) Cancel Task: You can cancel the task using its ID.     <pre><code># Replace stateful-task-xxxxxx with the actual ID\nagentvault run --agent http://localhost:8003/agent-card.json --cancel --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task cancellation request sent successfully for task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: CANCELED\n</code></pre></p> </li> </ol> <p>This demonstrates how the agent uses the <code>task_id</code> to access and update the correct state (<code>ChatTaskContext</code>) stored by the <code>InMemoryTaskStore</code> across multiple <code>run</code> command invocations. In a real application, you would likely use a persistent store instead of <code>InMemoryTaskStore</code>.</p>"},{"location":"user_guide/cli/","title":"User Guide: AgentVault CLI (<code>agentvault_cli</code>)","text":"<p>The <code>agentvault_cli</code> is your command-line tool for interacting with the AgentVault ecosystem. It allows you to manage credentials for accessing agents, discover agents registered in the central registry, and execute tasks on remote A2A-compliant agents.</p>"},{"location":"user_guide/cli/#installation","title":"Installation","text":"<p>Please refer to the main Installation Guide for instructions on installing the CLI using <code>pip</code>.</p>"},{"location":"user_guide/cli/#core-commands","title":"Core Commands","text":"<p>The CLI is structured around several main commands. Get an overview by running:</p> <pre><code>agentvault_cli --help\n</code></pre>"},{"location":"user_guide/cli/#config","title":"<code>config</code>","text":"<p>Manage local API keys and OAuth credentials required to authenticate with different agents or services. Credentials can be stored securely in the OS keyring or referenced via environment variables or files.</p> <p>Usage:</p> <pre><code>agentvault_cli config --help\n</code></pre> <p>This command group helps you configure how the <code>agentvault_cli run</code> command (and underlying library) finds the necessary secrets to talk to different agents.</p> <p>Key Subcommands:</p> <ul> <li> <p><code>set &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Configure how credentials for a specific service (identified by <code>&lt;service_id&gt;</code>) are sourced or stored. The <code>&lt;service_id&gt;</code> is a name you choose locally (e.g., <code>openai</code>, <code>my-custom-agent-key</code>, <code>google-oauth-agent</code>) that the <code>KeyManager</code> uses to find the right secret. It often corresponds to the <code>service_identifier</code> in an Agent Card's <code>authSchemes</code>, but can be different.</li> <li>Options:<ul> <li><code>--env</code>: Guidance Only. Prints instructions on how to set environment variables (<code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code>). It does not store anything itself.</li> <li><code>--file &lt;path&gt;</code>: Guidance Only. Prints instructions on how to format a <code>.env</code> or <code>.json</code> file to store credentials that the <code>KeyManager</code> could potentially load (if configured during library initialization, which the CLI doesn't do by default).</li> <li><code>--keyring</code>: Stores API Key. Securely prompts for an API key and stores it in your operating system's default keyring, associated with the <code>&lt;service_id&gt;</code>. This is the recommended secure method for storing API keys via the CLI.</li> <li><code>--oauth-configure</code>: Stores OAuth Credentials. Securely prompts for an OAuth 2.0 Client ID and Client Secret and stores them in the OS keyring, associated with the <code>&lt;service_id&gt;</code>. Required for agents using the <code>oauth2</code> authentication scheme.</li> </ul> </li> </ul> <p>Example (Store OpenAI API Key securely): <pre><code># Use 'openai' as the local service_id\nagentvault_cli config set openai --keyring\n# --&gt; Enter API key: ************\n# --&gt; Confirm API key: ************\n# SUCCESS: API key for 'openai' stored successfully in keyring.\n</code></pre> Example (Configure OAuth for a Google agent): <pre><code># Use 'google-agent-oauth' as the local service_id\nagentvault_cli config set google-agent-oauth --oauth-configure\n# --&gt; Enter OAuth Client ID for 'google-agent-oauth': &lt;paste_client_id&gt;\n# --&gt; Enter OAuth Client Secret for 'google-agent-oauth': ************\n# --&gt; Confirm OAuth Client Secret for 'google-agent-oauth': ************\n# SUCCESS: OAuth credentials for 'google-agent-oauth' stored successfully in keyring.\n</code></pre> Example (Guidance for Environment Variables): <pre><code>agentvault_cli config set anthropic --env\n# --&gt; Guidance: To use environment variables for 'anthropic':\n# --&gt;   For API Key: Set AGENTVAULT_KEY_ANTHROPIC=&lt;your_api_key&gt;\n# --&gt;   ... (OAuth guidance also shown) ...\n</code></pre></p> </li> <li> <p><code>get &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Checks how credentials for a given <code>&lt;service_id&gt;</code> are currently being sourced by the <code>KeyManager</code> (Environment, File, Keyring). It checks the cache first, then attempts to load from the keyring if enabled.</li> <li>Options:<ul> <li><code>--show-key</code>: Displays the first few characters of the found API key (use with caution).</li> <li><code>--show-oauth-id</code>: Displays the configured OAuth Client ID if found. Example: <pre><code>agentvault_cli config get openai\n# --&gt; Credential status for service 'openai':\n# --&gt;   API Key: Found (Source: KEYRING)\n# --&gt;     (Use --show-key to display a masked version)\n# --&gt;   OAuth Credentials: Not Configured\n\nagentvault_cli config get google-agent-oauth --show-oauth-id\n# --&gt; Credential status for service 'google-agent-oauth':\n# --&gt;   API Key: Not Found\n# --&gt;   OAuth Credentials: Configured (Source: KEYRING)\n# --&gt;     Client ID: 12345-abcde.apps.googleusercontent.com\n</code></pre></li> </ul> </li> </ul> </li> <li> <p><code>list</code>:</p> <ul> <li>Purpose: Shows a summary of services for which credentials have been detected during initialization from environment variables or specified key files (if the underlying library was configured with a key file path, which the default CLI is not).</li> <li>Note: This command does not actively scan the OS keyring. Keys stored only in the keyring will typically not appear in this list unless they were accessed previously by a <code>get</code> command in the same CLI invocation.</li> </ul> </li> </ul>"},{"location":"user_guide/cli/#discover","title":"<code>discover</code>","text":"<p>Search for agents registered in the central AgentVault Registry.</p> <p>Usage:</p> <pre><code>agentvault_cli discover --help\nagentvault_cli discover [SEARCH_QUERY] [OPTIONS]\n</code></pre> <ul> <li><code>[SEARCH_QUERY]</code> (Optional): Text to search for (case-insensitive) in agent names or descriptions.</li> <li><code>--registry &lt;url&gt;</code>: Specify the URL of the AgentVault Registry API.<ul> <li>Defaults to the value of the <code>AGENTVAULT_REGISTRY_URL</code> environment variable if set.</li> <li>If the environment variable is not set, it defaults to the public registry: <code>https://agentvault-registry-api.onrender.com</code>.</li> <li>(Note: The public registry runs on a free tier and may take up to 60 seconds to wake up on the first request.)</li> </ul> </li> <li><code>--limit &lt;n&gt;</code>: Maximum results per page (default: 25, max: 250).</li> <li><code>--offset &lt;n&gt;</code>: Number of results to skip (for pagination, default: 0).</li> <li><code>--tags &lt;tag&gt;</code> (Repeatable): Filter by tags. Only agents possessing all specified tags will be returned (e.g., <code>--tags weather --tags forecast</code>).</li> <li><code>--has-tee [true|false]</code> (Optional): Filter agents based on whether they declare TEE support in their Agent Card.</li> <li><code>--tee-type &lt;type&gt;</code> (Optional): Filter agents by the specific TEE type declared (e.g., <code>AWS Nitro Enclaves</code>, <code>Intel SGX</code>).</li> </ul> <p>Example: <pre><code># List first 10 agents containing \"weather\" from the public registry\nagentvault_cli discover weather --limit 10\n\n# List agents tagged with \"nlp\" from a local registry\nagentvault_cli discover --tags nlp --registry http://localhost:8000\n\n# Find agents declaring TEE support on the public registry\nagentvault_cli discover --has-tee true\n</code></pre></p> <p>The output is displayed in a table format.</p>"},{"location":"user_guide/cli/#run","title":"<code>run</code>","text":"<p>Execute a task on a specific remote agent using the A2A protocol.</p> <p>Usage:</p> <pre><code>agentvault_cli run --help\nagentvault_cli run --agent &lt;agent_ref&gt; --input &lt;input_data&gt; [OPTIONS]\n</code></pre> <ul> <li><code>--agent &lt;agent_ref&gt;</code> / <code>-a &lt;agent_ref&gt;</code> (Required): Identifies the target agent. This is crucial. It can be:<ul> <li>An Agent ID from the registry (e.g., <code>examples/simple-agent</code>, <code>my-org/my-agent</code>). The CLI will use the <code>--registry</code> URL to fetch the corresponding Agent Card.</li> <li>A direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>A local file path to the agent's <code>agent-card.json</code> (e.g., <code>../examples/basic_a2a_server/agent-card.json</code>).</li> </ul> </li> <li><code>--input &lt;input_data&gt;</code> / <code>-i &lt;input_data&gt;</code> (Required): The input text for the agent's task.<ul> <li>To read input from a file, prefix the path with <code>@</code>. Example: <code>--input @./prompts/my_request.txt</code>.</li> </ul> </li> <li><code>--context-file &lt;path&gt;</code>: Path to a local JSON file containing MCP context data to send with the initial message.</li> <li><code>--registry &lt;url&gt;</code>: Registry URL (only used if <code>&lt;agent_ref&gt;</code> is an Agent ID). Defaults to <code>AGENTVAULT_REGISTRY_URL</code> env var or the public registry <code>https://agentvault-registry-api.onrender.com</code>. (Note the cold start delay for the public instance).</li> <li><code>--key-service &lt;service_id&gt;</code>: Important for Authentication. If the agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>) and its Agent Card doesn't specify a <code>service_identifier</code>, or if you want to use credentials stored under a different local name, use this flag to tell the <code>KeyManager</code> which local service ID to use for lookup. Example: <code>--key-service openai</code>.</li> <li><code>--auth-key &lt;key&gt;</code>: INSECURE - FOR TESTING ONLY. Directly provide the API key on the command line. This bypasses the <code>KeyManager</code> lookup for agents using the <code>apiKey</code> scheme. Avoid using this for sensitive keys.</li> <li><code>--output-artifacts &lt;directory&gt;</code>: If provided, artifact content larger than 1KB received via SSE will be saved to files in this directory (named using artifact ID and inferred extension) instead of being printed (truncated) to the console.</li> </ul> <p>Example (Running the basic SDK example agent locally): <pre><code># Assumes the basic_a2a_server example is running on port 8000\nagentvault_cli run --agent http://localhost:8000/agent-card.json --input \"Hello Agent!\"\n</code></pre></p> <p>Example (Running an agent from the public registry requiring an OpenAI key): <pre><code># First, ensure the key is configured:\n# agentvault config set openai --keyring (and enter key)\n\n# Then run the task (assuming agent 'some-org/openai-agent' uses 'openai' service ID)\n# The --registry flag is omitted, so it uses the default public registry\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize the concept of AI agents.\"\n\n# Or, if the agent card didn't specify 'openai' as service_identifier:\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize...\" --key-service openai\n</code></pre></p> <p>The <code>run</code> command connects to the agent and streams Server-Sent Events (SSE) back to your terminal, showing status updates, messages from the agent/tools, and artifact information using <code>rich</code> formatting for better readability.</p>"},{"location":"user_guide/cli/#usage-tips","title":"Usage Tips","text":"<p>(Same as before - Shell History, fzf + awk)</p>"},{"location":"user_guide/cli/#re-running-run-commands","title":"Re-running <code>run</code> Commands","text":"<p>The <code>agentvault_cli run</code> command can sometimes involve long agent identifiers or input strings. To easily recall and reuse previous commands:</p> <ul> <li>Shell History Search (Ctrl+R): Most shells allow you to search your command history interactively. Press <code>Ctrl+R</code> and start typing parts of the command you want to find (e.g., <code>run</code>, the agent ID, part of the input).</li> <li><code>history</code> Command: Use <code>history | grep agentvault_cli run</code> (or similar filter) to list previous run commands. You can then execute a specific command number (e.g., <code>!123</code>).</li> <li><code>fzf</code> (Fuzzy Finder): If you have <code>fzf</code> installed, you can pipe your history to it for interactive fuzzy searching: <code>history | fzf</code>. Select the desired command and press Enter to execute it. This is very powerful for quickly finding complex commands.</li> </ul>"},{"location":"user_guide/cli/#interactive-agent-selection-discover-fzf","title":"Interactive Agent Selection (<code>discover</code> + <code>fzf</code>)","text":"<p>If you have command-line tools like <code>fzf</code> (fuzzy finder) and <code>awk</code> installed, you can create powerful interactive workflows. For example, to discover agents, select one interactively, and then immediately run a task on it:</p> <pre><code># Example: Discover agents matching \"weather\", select one, run with input\n# Assumes default public registry or AGENTVAULT_REGISTRY_URL is set\nagentvault_cli discover weather | fzf --height 40% --border --header \"Select Agent:\" | awk '{print $1}' | xargs -I {} agentvault_cli run --agent {} --input \"What is the forecast for London?\"\n</code></pre> <p>Explanation:</p> <ol> <li><code>agentvault_cli discover weather</code>: Lists agents matching \"weather\" from the configured registry.</li> <li><code>| fzf ...</code>: Pipes the list to <code>fzf</code> for interactive selection.</li> <li><code>| awk '{print $1}'</code>: Extracts the first column (the Agent ID) from the line selected in <code>fzf</code>. Note: You might need to adjust <code>$1</code> if the ID is in a different column based on your terminal width or <code>discover</code> output format.</li> <li><code>| xargs -I {} ...</code>: Takes the extracted ID (<code>{}</code>) and inserts it into the <code>agentvault_cli run</code> command.</li> </ol> <p>This allows you to quickly find and use agents without manually copying and pasting IDs.</p>"}]}